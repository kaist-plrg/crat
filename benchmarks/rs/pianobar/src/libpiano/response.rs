use ::libc;
extern "C" {
    pub type json_object;
    pub type gcry_cipher_handle;
    fn json_object_put(obj: *mut json_object) -> libc::c_int;
    fn strtoul(
        _: *const libc::c_char,
        _: *mut *mut libc::c_char,
        _: libc::c_int,
    ) -> libc::c_ulong;
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    fn free(__ptr: *mut libc::c_void);
    fn json_object_array_length(obj: *const json_object) -> size_t;
    fn json_object_array_get_idx(
        obj: *const json_object,
        idx: size_t,
    ) -> *mut json_object;
    fn json_object_get_boolean(obj: *const json_object) -> json_bool;
    fn json_object_get_int(obj: *const json_object) -> int32_t;
    fn json_object_get_double(obj: *const json_object) -> libc::c_double;
    fn json_object_get_string(obj: *mut json_object) -> *const libc::c_char;
    fn json_tokener_parse(str: *const libc::c_char) -> *mut json_object;
    fn json_object_object_get_ex(
        obj: *const json_object,
        key: *const libc::c_char,
        value: *mut *mut json_object,
    ) -> json_bool;
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn strncpy(
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> *mut libc::c_char;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strdup(__s: *const libc::c_char) -> *mut libc::c_char;
    fn time(__timer: *mut time_t) -> time_t;
    fn PianoFindStationById(
        _: *mut PianoStation_t,
        _: *const libc::c_char,
    ) -> *mut PianoStation_t;
    fn PianoListAppend(
        l: *mut PianoListHead_t,
        e: *mut PianoListHead_t,
    ) -> *mut libc::c_void;
    fn PianoListDelete(
        l: *mut PianoListHead_t,
        e: *mut PianoListHead_t,
    ) -> *mut libc::c_void;
    fn PianoDestroyPlaylist(_: *mut PianoSong_t);
    fn PianoDestroyStation(station: *mut PianoStation_t);
    fn PianoDestroyUserInfo(user: *mut PianoUserInfo_t);
    fn PianoDecryptString(
        _: gcry_cipher_hd_t,
        _: *const libc::c_char,
        _: *mut size_t,
    ) -> *mut libc::c_char;
}
pub type size_t = libc::c_ulong;
pub type __int32_t = libc::c_int;
pub type __time_t = libc::c_long;
pub type int32_t = __int32_t;
pub type json_bool = libc::c_int;
pub type time_t = __time_t;
pub type gcry_cipher_hd_t = *mut gcry_cipher_handle;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoListHead {
    pub next: *mut PianoListHead,
}
pub type PianoListHead_t = PianoListHead;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoUserInfo {
    pub listenerId: *mut libc::c_char,
    pub authToken: *mut libc::c_char,
}
pub type PianoUserInfo_t = PianoUserInfo;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoStation {
    pub head: PianoListHead_t,
    pub isCreator: libc::c_char,
    pub isQuickMix: libc::c_char,
    pub useQuickMix: libc::c_char,
    pub name: *mut libc::c_char,
    pub id: *mut libc::c_char,
    pub seedId: *mut libc::c_char,
}
pub type PianoStation_t = PianoStation;
pub type PianoSongRating_t = libc::c_uint;
pub const PIANO_RATE_TIRED: PianoSongRating_t = 3;
pub const PIANO_RATE_BAN: PianoSongRating_t = 2;
pub const PIANO_RATE_LOVE: PianoSongRating_t = 1;
pub const PIANO_RATE_NONE: PianoSongRating_t = 0;
pub type PianoAudioFormat_t = libc::c_uint;
pub const PIANO_AF_MP3: PianoAudioFormat_t = 2;
pub const PIANO_AF_AACPLUS: PianoAudioFormat_t = 1;
pub const PIANO_AF_UNKNOWN: PianoAudioFormat_t = 0;
pub type PianoAudioQuality_t = libc::c_uint;
pub const PIANO_AQ_HIGH: PianoAudioQuality_t = 3;
pub const PIANO_AQ_MEDIUM: PianoAudioQuality_t = 2;
pub const PIANO_AQ_LOW: PianoAudioQuality_t = 1;
pub const PIANO_AQ_UNKNOWN: PianoAudioQuality_t = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoSong {
    pub head: PianoListHead_t,
    pub artist: *mut libc::c_char,
    pub stationId: *mut libc::c_char,
    pub album: *mut libc::c_char,
    pub audioUrl: *mut libc::c_char,
    pub coverArt: *mut libc::c_char,
    pub musicId: *mut libc::c_char,
    pub title: *mut libc::c_char,
    pub seedId: *mut libc::c_char,
    pub feedbackId: *mut libc::c_char,
    pub detailUrl: *mut libc::c_char,
    pub trackToken: *mut libc::c_char,
    pub fileGain: libc::c_float,
    pub length: libc::c_uint,
    pub rating: PianoSongRating_t,
    pub audioFormat: PianoAudioFormat_t,
}
pub type PianoSong_t = PianoSong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoArtist {
    pub head: PianoListHead_t,
    pub name: *mut libc::c_char,
    pub musicId: *mut libc::c_char,
    pub seedId: *mut libc::c_char,
    pub score: libc::c_int,
}
pub type PianoArtist_t = PianoArtist;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoGenre {
    pub head: PianoListHead_t,
    pub name: *mut libc::c_char,
    pub musicId: *mut libc::c_char,
}
pub type PianoGenre_t = PianoGenre;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoGenreCategory {
    pub head: PianoListHead_t,
    pub name: *mut libc::c_char,
    pub genres: *mut PianoGenre_t,
}
pub type PianoGenreCategory_t = PianoGenreCategory;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoPartner {
    pub in_0: gcry_cipher_hd_t,
    pub out: gcry_cipher_hd_t,
    pub authToken: *mut libc::c_char,
    pub device: *mut libc::c_char,
    pub user: *mut libc::c_char,
    pub password: *mut libc::c_char,
    pub id: libc::c_uint,
}
pub type PianoPartner_t = PianoPartner;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoHandle {
    pub user: PianoUserInfo_t,
    pub stations: *mut PianoStation_t,
    pub genreStations: *mut PianoGenreCategory_t,
    pub partner: PianoPartner_t,
    pub timeOffset: libc::c_int,
}
pub type PianoHandle_t = PianoHandle;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoSearchResult {
    pub songs: *mut PianoSong_t,
    pub artists: *mut PianoArtist_t,
}
pub type PianoSearchResult_t = PianoSearchResult;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoStationInfo_t {
    pub songSeeds: *mut PianoSong_t,
    pub artistSeeds: *mut PianoArtist_t,
    pub stationSeeds: *mut PianoStation_t,
    pub feedback: *mut PianoSong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoSettings_t {
    pub username: *mut libc::c_char,
    pub explicitContentFilter: bool,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoStationMode_t {
    pub head: PianoListHead_t,
    pub name: *mut libc::c_char,
    pub description: *mut libc::c_char,
    pub isAlgorithmic: bool,
    pub isTakeover: bool,
    pub active: bool,
    pub id: libc::c_int,
}
pub type PianoRequestType_t = libc::c_uint;
pub const PIANO_REQUEST_SET_STATION_MODE: PianoRequestType_t = 26;
pub const PIANO_REQUEST_GET_STATION_MODES: PianoRequestType_t = 25;
pub const PIANO_REQUEST_CHANGE_SETTINGS: PianoRequestType_t = 24;
pub const PIANO_REQUEST_GET_SETTINGS: PianoRequestType_t = 23;
pub const PIANO_REQUEST_DELETE_SEED: PianoRequestType_t = 22;
pub const PIANO_REQUEST_DELETE_FEEDBACK: PianoRequestType_t = 21;
pub const PIANO_REQUEST_GET_STATION_INFO: PianoRequestType_t = 20;
pub const PIANO_REQUEST_BOOKMARK_ARTIST: PianoRequestType_t = 19;
pub const PIANO_REQUEST_BOOKMARK_SONG: PianoRequestType_t = 18;
pub const PIANO_REQUEST_EXPLAIN: PianoRequestType_t = 16;
pub const PIANO_REQUEST_TRANSFORM_STATION: PianoRequestType_t = 15;
pub const PIANO_REQUEST_GET_GENRE_STATIONS: PianoRequestType_t = 14;
pub const PIANO_REQUEST_SET_QUICKMIX: PianoRequestType_t = 13;
pub const PIANO_REQUEST_ADD_TIRED_SONG: PianoRequestType_t = 12;
pub const PIANO_REQUEST_ADD_SEED: PianoRequestType_t = 11;
pub const PIANO_REQUEST_CREATE_STATION: PianoRequestType_t = 10;
pub const PIANO_REQUEST_SEARCH: PianoRequestType_t = 9;
pub const PIANO_REQUEST_DELETE_STATION: PianoRequestType_t = 8;
pub const PIANO_REQUEST_RENAME_STATION: PianoRequestType_t = 7;
pub const PIANO_REQUEST_ADD_FEEDBACK: PianoRequestType_t = 5;
pub const PIANO_REQUEST_RATE_SONG: PianoRequestType_t = 4;
pub const PIANO_REQUEST_GET_PLAYLIST: PianoRequestType_t = 3;
pub const PIANO_REQUEST_GET_STATIONS: PianoRequestType_t = 2;
pub const PIANO_REQUEST_LOGIN: PianoRequestType_t = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoRequest {
    pub type_0: PianoRequestType_t,
    pub secure: bool,
    pub data: *mut libc::c_void,
    pub urlPath: [libc::c_char; 1024],
    pub postData: *mut libc::c_char,
    pub responseData: *mut libc::c_char,
}
pub type PianoRequest_t = PianoRequest;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoRequestDataLogin_t {
    pub user: *mut libc::c_char,
    pub password: *mut libc::c_char,
    pub step: libc::c_uchar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoRequestDataGetPlaylist_t {
    pub station: *mut PianoStation_t,
    pub quality: PianoAudioQuality_t,
    pub retPlaylist: *mut PianoSong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoRequestDataRateSong_t {
    pub song: *mut PianoSong_t,
    pub rating: PianoSongRating_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoRequestDataRenameStation_t {
    pub station: *mut PianoStation_t,
    pub newName: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoRequestDataSearch_t {
    pub searchStr: *mut libc::c_char,
    pub searchResult: PianoSearchResult_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoRequestDataExplain_t {
    pub song: *mut PianoSong_t,
    pub retExplain: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoRequestDataGetStationInfo_t {
    pub station: *mut PianoStation_t,
    pub info: PianoStationInfo_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoRequestDataGetStationModes_t {
    pub station: *mut PianoStation_t,
    pub retModes: *mut PianoStationMode_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PianoRequestDataSetStationMode_t {
    pub station: *mut PianoStation_t,
    pub id: libc::c_uint,
}
pub type PianoReturn_t = libc::c_uint;
pub const PIANO_RET_P_RATE_LIMIT: PianoReturn_t = 2063;
pub const PIANO_RET_P_ZIP_CODE_INVALID: PianoReturn_t = 2048;
pub const PIANO_RET_P_USER_NOT_AUTHORIZED: PianoReturn_t = 2028;
pub const PIANO_RET_P_LISTENER_NOT_AUTHORIZED: PianoReturn_t = 2027;
pub const PIANO_RET_P_USER_ALREADY_USED_TRIAL: PianoReturn_t = 2061;
pub const PIANO_RET_P_USERNAME_ALREADY_EXISTS: PianoReturn_t = 2037;
pub const PIANO_RET_P_URL_PARAM_MISSING_USER_ID: PianoReturn_t = 1029;
pub const PIANO_RET_P_URL_PARAM_MISSING_PARTNER_ID: PianoReturn_t = 1028;
pub const PIANO_RET_P_URL_PARAM_MISSING_METHOD: PianoReturn_t = 1026;
pub const PIANO_RET_P_URL_PARAM_MISSING_AUTH_TOKEN: PianoReturn_t = 1027;
pub const PIANO_RET_P_UPGRADE_DEVICE_MODEL_INVALID: PianoReturn_t = 2039;
pub const PIANO_RET_P_STATION_DOES_NOT_EXIST: PianoReturn_t = 2030;
pub const PIANO_RET_P_SECURE_PROTOCOL_REQUIRED: PianoReturn_t = 1030;
pub const PIANO_RET_P_READ_ONLY_MODE: PianoReturn_t = 2024;
pub const PIANO_RET_P_PARTNER_NOT_AUTHORIZED: PianoReturn_t = 2034;
pub const PIANO_RET_P_PARAMETER_VALUE_INVALID: PianoReturn_t = 1034;
pub const PIANO_RET_P_PARAMETER_TYPE_MISMATCH: PianoReturn_t = 1032;
pub const PIANO_RET_P_PARAMETER_MISSING: PianoReturn_t = 1033;
pub const PIANO_RET_P_MAX_STATIONS_REACHED: PianoReturn_t = 2029;
pub const PIANO_RET_P_MAINTENANCE_MODE: PianoReturn_t = 1025;
pub const PIANO_RET_P_LICENSING_RESTRICTIONS: PianoReturn_t = 1036;
pub const PIANO_RET_P_INVALID_USERNAME: PianoReturn_t = 2035;
pub const PIANO_RET_P_INVALID_SPONSOR: PianoReturn_t = 2060;
pub const PIANO_RET_P_INVALID_PASSWORD: PianoReturn_t = 2036;
pub const PIANO_RET_P_INVALID_PARTNER_LOGIN: PianoReturn_t = 2026;
pub const PIANO_RET_P_INVALID_GENDER: PianoReturn_t = 2051;
pub const PIANO_RET_P_INVALID_COUNTRY_CODE: PianoReturn_t = 2051;
pub const PIANO_RET_P_INVALID_AUTH_TOKEN: PianoReturn_t = 2025;
pub const PIANO_RET_P_INSUFFICIENT_CONNECTIVITY: PianoReturn_t = 1037;
pub const PIANO_RET_P_EXPLICIT_PIN_MALFORMED: PianoReturn_t = 2044;
pub const PIANO_RET_P_EXPLICIT_PIN_INCORRECT: PianoReturn_t = 2042;
pub const PIANO_RET_P_DEVICE_NOT_FOUND: PianoReturn_t = 2033;
pub const PIANO_RET_P_DEVICE_MODEL_INVALID: PianoReturn_t = 2047;
pub const PIANO_RET_P_DEVICE_DISABLED: PianoReturn_t = 2058;
pub const PIANO_RET_P_DEVICE_ALREADY_ASSOCIATED_TO_ACCOUNT: PianoReturn_t = 2038;
pub const PIANO_RET_P_DAILY_TRIAL_LIMIT_REACHED: PianoReturn_t = 2059;
pub const PIANO_RET_P_COMPLIMENTARY_PERIOD_ALREADY_IN_USE: PianoReturn_t = 2031;
pub const PIANO_RET_P_CERTIFICATE_REQUIRED: PianoReturn_t = 1031;
pub const PIANO_RET_P_CALL_NOT_ALLOWED: PianoReturn_t = 2032;
pub const PIANO_RET_P_BIRTH_YEAR_TOO_YOUNG: PianoReturn_t = 2050;
pub const PIANO_RET_P_BIRTH_YEAR_INVALID: PianoReturn_t = 2049;
pub const PIANO_RET_P_API_VERSION_NOT_SUPPORTED: PianoReturn_t = 1035;
pub const PIANO_RET_P_INTERNAL: PianoReturn_t = 1024;
pub const PIANO_RET_GCRY_ERR: PianoReturn_t = 7;
pub const PIANO_RET_QUALITY_UNAVAILABLE: PianoReturn_t = 6;
pub const PIANO_RET_INVALID_LOGIN: PianoReturn_t = 5;
pub const PIANO_RET_OUT_OF_MEMORY: PianoReturn_t = 4;
pub const PIANO_RET_CONTINUE_REQUEST: PianoReturn_t = 3;
pub const PIANO_RET_INVALID_RESPONSE: PianoReturn_t = 2;
pub const PIANO_RET_OK: PianoReturn_t = 1;
pub const PIANO_RET_ERR: PianoReturn_t = 0;
unsafe extern "C" fn PianoJsonStrdup(
    mut j: *mut json_object,
    mut key: *const libc::c_char,
) -> *mut libc::c_char {
    let mut v: *mut json_object = 0 as *mut json_object;
    if json_object_object_get_ex(j, key, &mut v) != 0 {
        return strdup(json_object_get_string(v))
    } else {
        return 0 as *mut libc::c_char
    };
}
unsafe extern "C" fn getBoolDefault(
    j: *mut json_object,
    key: *const libc::c_char,
    def: bool,
) -> bool {
    let mut v: *mut json_object = 0 as *mut json_object;
    if json_object_object_get_ex(j, key, &mut v) != 0 {
        return json_object_get_boolean(v) != 0
    } else {
        return def
    };
}
unsafe extern "C" fn PianoJsonParseStation(
    mut j: *mut json_object,
    mut s: *mut PianoStation_t,
) {
    (*s).name = PianoJsonStrdup(j, b"stationName\0" as *const u8 as *const libc::c_char);
    (*s).id = PianoJsonStrdup(j, b"stationToken\0" as *const u8 as *const libc::c_char);
    (*s)
        .isCreator = !getBoolDefault(
        j,
        b"isShared\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int == 0,
    ) as libc::c_int as libc::c_char;
    (*s)
        .isQuickMix = getBoolDefault(
        j,
        b"isQuickMix\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int != 0,
    ) as libc::c_char;
}
unsafe extern "C" fn PianoStrpcat(
    mut dest: *mut libc::c_char,
    mut src: *const libc::c_char,
    mut len: size_t,
) {
    while *dest as libc::c_int != '\0' as i32 && len > 1 as libc::c_int as libc::c_ulong
    {
        dest = dest.offset(1);
        dest;
        len = len.wrapping_sub(1);
        len;
    }
    while *src as libc::c_int != '\0' as i32 && len > 1 as libc::c_int as libc::c_ulong {
        *dest = *src;
        dest = dest.offset(1);
        dest;
        src = src.offset(1);
        src;
        len = len.wrapping_sub(1);
        len;
    }
    *dest = '\0' as i32 as libc::c_char;
}
pub unsafe extern "C" fn PianoResponse(
    mut ph: *mut PianoHandle_t,
    mut req: *mut PianoRequest_t,
) -> PianoReturn_t {
    let mut result: *mut json_object = 0 as *mut json_object;
    let mut current_block: u64;
    let mut ret: PianoReturn_t = PIANO_RET_OK;
    let j: *mut json_object = json_tokener_parse((*req).responseData);
    let mut status: *mut json_object = 0 as *mut json_object;
    if json_object_object_get_ex(
        j,
        b"stat\0" as *const u8 as *const libc::c_char,
        &mut status,
    ) == 0
    {
        ret = PIANO_RET_INVALID_RESPONSE;
    } else if strcmp(
        json_object_get_string(status),
        b"ok\0" as *const u8 as *const libc::c_char,
    ) != 0 as libc::c_int
    {
        let mut code: *mut json_object = 0 as *mut json_object;
        if json_object_object_get_ex(
            j,
            b"code\0" as *const u8 as *const libc::c_char,
            &mut code,
        ) == 0
        {
            ret = PIANO_RET_INVALID_RESPONSE;
        } else {
            ret = (json_object_get_int(code) + 1024 as libc::c_int) as PianoReturn_t;
            if ret as libc::c_uint
                == PIANO_RET_P_INVALID_PARTNER_LOGIN as libc::c_int as libc::c_uint
                && (*req).type_0 as libc::c_uint
                    == PIANO_REQUEST_LOGIN as libc::c_int as libc::c_uint
            {
                let mut reqData: *mut PianoRequestDataLogin_t = (*req).data
                    as *mut PianoRequestDataLogin_t;
                if (*reqData).step as libc::c_int == 1 as libc::c_int {
                    ret = PIANO_RET_INVALID_LOGIN;
                }
            }
        }
    } else {
        result = 0 as *mut json_object;
        json_object_object_get_ex(
            j,
            b"result\0" as *const u8 as *const libc::c_char,
            &mut result,
        );
        match (*req).type_0 as libc::c_uint {
            1 => {
                current_block = 12039483399334584727;
                match current_block {
                    14870924983410776565 => {}
                    4367030874028593650 => {
                        let mut reqData_6: *mut PianoRequestDataGetStationInfo_t = (*req)
                            .data as *mut PianoRequestDataGetStationInfo_t;
                        let mut info: *mut PianoStationInfo_t = 0
                            as *mut PianoStationInfo_t;
                        info = &mut (*reqData_6).info;
                        let mut music: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"music\0" as *const u8 as *const libc::c_char,
                            &mut music,
                        ) != 0
                        {
                            let mut songs_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs_0,
                            ) != 0
                            {
                                let mut i_6: libc::c_int = 0 as libc::c_int;
                                while (i_6 as libc::c_ulong)
                                    < json_object_array_length(songs_0)
                                {
                                    let mut s_4: *mut json_object = json_object_array_get_idx(
                                        songs_0,
                                        i_6 as size_t,
                                    );
                                    let mut seedSong: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                    seedSong = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    ) as *mut PianoSong_t;
                                    if seedSong.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedSong)
                                        .title = PianoJsonStrdup(
                                        s_4,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .artist = PianoJsonStrdup(
                                        s_4,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .seedId = PianoJsonStrdup(
                                        s_4,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .songSeeds = PianoListAppend(
                                        if ((*info).songSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).songSeeds).head
                                        },
                                        &mut (*seedSong).head,
                                    ) as *mut PianoSong_t;
                                    i_6 += 1;
                                    i_6;
                                }
                            }
                            let mut artists_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists_0,
                            ) != 0
                            {
                                let mut i_7: libc::c_int = 0 as libc::c_int;
                                while (i_7 as libc::c_ulong)
                                    < json_object_array_length(artists_0)
                                {
                                    let mut a_0: *mut json_object = json_object_array_get_idx(
                                        artists_0,
                                        i_7 as size_t,
                                    );
                                    let mut seedArtist: *mut PianoArtist_t = 0
                                        as *mut PianoArtist_t;
                                    seedArtist = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    ) as *mut PianoArtist_t;
                                    if seedArtist.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedArtist)
                                        .name = PianoJsonStrdup(
                                        a_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedArtist)
                                        .seedId = PianoJsonStrdup(
                                        a_0,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .artistSeeds = PianoListAppend(
                                        if ((*info).artistSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).artistSeeds).head
                                        },
                                        &mut (*seedArtist).head,
                                    ) as *mut PianoArtist_t;
                                    i_7 += 1;
                                    i_7;
                                }
                            }
                        }
                        let mut feedback: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"feedback\0" as *const u8 as *const libc::c_char,
                            &mut feedback,
                        ) != 0
                        {
                            static mut keys: [*const libc::c_char; 2] = [
                                b"thumbsUp\0" as *const u8 as *const libc::c_char,
                                b"thumbsDown\0" as *const u8 as *const libc::c_char,
                            ];
                            let mut i_8: size_t = 0 as libc::c_int as size_t;
                            while i_8
                                < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                    as libc::c_ulong)
                                    .wrapping_div(
                                        ::std::mem::size_of::<*const libc::c_char>()
                                            as libc::c_ulong,
                                    )
                            {
                                let mut val: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    feedback,
                                    keys[i_8 as usize],
                                    &mut val,
                                ) == 0)
                                {
                                    let mut i_9: libc::c_int = 0 as libc::c_int;
                                    while (i_9 as libc::c_ulong) < json_object_array_length(val)
                                    {
                                        let mut s_5: *mut json_object = json_object_array_get_idx(
                                            val,
                                            i_9 as size_t,
                                        );
                                        let mut feedbackSong: *mut PianoSong_t = 0
                                            as *mut PianoSong_t;
                                        feedbackSong = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        ) as *mut PianoSong_t;
                                        if feedbackSong.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*feedbackSong)
                                            .title = PianoJsonStrdup(
                                            s_5,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .artist = PianoJsonStrdup(
                                            s_5,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .feedbackId = PianoJsonStrdup(
                                            s_5,
                                            b"feedbackId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .rating = (if getBoolDefault(
                                            s_5,
                                            b"isPositive\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        ) as libc::c_int != 0
                                        {
                                            PIANO_RATE_LOVE as libc::c_int
                                        } else {
                                            PIANO_RATE_BAN as libc::c_int
                                        }) as PianoSongRating_t;
                                        let mut v_0: *mut json_object = 0 as *mut json_object;
                                        (*feedbackSong)
                                            .length = (if json_object_object_get_ex(
                                            s_5,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v_0,
                                        ) != 0
                                        {
                                            json_object_get_int(v_0)
                                        } else {
                                            0 as libc::c_int
                                        }) as libc::c_uint;
                                        (*info)
                                            .feedback = PianoListAppend(
                                            if ((*info).feedback).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*info).feedback).head
                                            },
                                            &mut (*feedbackSong).head,
                                        ) as *mut PianoSong_t;
                                        i_9 += 1;
                                        i_9;
                                    }
                                }
                                i_8 = i_8.wrapping_add(1);
                                i_8;
                            }
                        }
                    }
                    11202235766349324107 => {
                        let settings: *mut PianoSettings_t = (*req).data
                            as *mut PianoSettings_t;
                        (*settings)
                            .explicitContentFilter = getBoolDefault(
                            result,
                            b"isExplicitContentFilterEnabled\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int != 0,
                        );
                        (*settings)
                            .username = PianoJsonStrdup(
                            result,
                            b"username\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    145651165234646754 => {
                        let mut reqData_5: *mut PianoRequestDataExplain_t = (*req).data
                            as *mut PianoRequestDataExplain_t;
                        let strSize: size_t = 768 as libc::c_int as size_t;
                        let mut explanations: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"explanations\0" as *const u8 as *const libc::c_char,
                            &mut explanations,
                        ) != 0
                        {
                            (*reqData_5)
                                .retExplain = malloc(
                                strSize
                                    .wrapping_mul(
                                        ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                    ),
                            ) as *mut libc::c_char;
                            strncpy(
                                (*reqData_5).retExplain,
                                b"We're playing this track because it features \0"
                                    as *const u8 as *const libc::c_char,
                                strSize,
                            );
                            let mut i_5: libc::c_int = 0 as libc::c_int;
                            while (i_5 as libc::c_ulong)
                                < json_object_array_length(explanations)
                            {
                                let mut e: *mut json_object = json_object_array_get_idx(
                                    explanations,
                                    i_5 as size_t,
                                );
                                let mut f: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    e,
                                    b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                    &mut f,
                                ) == 0)
                                {
                                    let mut s_3: *const libc::c_char = json_object_get_string(
                                        f,
                                    );
                                    PianoStrpcat((*reqData_5).retExplain, s_3, strSize);
                                    if (i_5 as libc::c_ulong)
                                        < (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b", \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else if i_5 as libc::c_ulong
                                        == (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b" and \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b".\0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    }
                                }
                                i_5 += 1;
                                i_5;
                            }
                        }
                    }
                    9240481512215375588 => {
                        let mut station_0: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*station_0).isCreator = 1 as libc::c_int as libc::c_char;
                    }
                    5908482871227205451 => {
                        let mut categories: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"categories\0" as *const u8 as *const libc::c_char,
                            &mut categories,
                        ) != 0
                        {
                            let mut i_4: libc::c_int = 0 as libc::c_int;
                            while (i_4 as libc::c_ulong)
                                < json_object_array_length(categories)
                            {
                                let mut c: *mut json_object = json_object_array_get_idx(
                                    categories,
                                    i_4 as size_t,
                                );
                                let mut tmpGenreCategory: *mut PianoGenreCategory_t = 0
                                    as *mut PianoGenreCategory_t;
                                tmpGenreCategory = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoGenreCategory_t>()
                                        as libc::c_ulong,
                                ) as *mut PianoGenreCategory_t;
                                if tmpGenreCategory.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*tmpGenreCategory)
                                    .name = PianoJsonStrdup(
                                    c,
                                    b"categoryName\0" as *const u8 as *const libc::c_char,
                                );
                                let mut stations_0: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    c,
                                    b"stations\0" as *const u8 as *const libc::c_char,
                                    &mut stations_0,
                                ) != 0
                                {
                                    let mut k_0: libc::c_int = 0 as libc::c_int;
                                    while (k_0 as libc::c_ulong)
                                        < json_object_array_length(stations_0)
                                    {
                                        let mut s_2: *mut json_object = json_object_array_get_idx(
                                            stations_0,
                                            k_0 as size_t,
                                        );
                                        let mut tmpGenre: *mut PianoGenre_t = 0
                                            as *mut PianoGenre_t;
                                        tmpGenre = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                        ) as *mut PianoGenre_t;
                                        if tmpGenre.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*tmpGenre)
                                            .name = PianoJsonStrdup(
                                            s_2,
                                            b"stationName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenre)
                                            .musicId = PianoJsonStrdup(
                                            s_2,
                                            b"stationToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenreCategory)
                                            .genres = PianoListAppend(
                                            if ((*tmpGenreCategory).genres).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*tmpGenreCategory).genres).head
                                            },
                                            &mut (*tmpGenre).head,
                                        ) as *mut PianoGenre_t;
                                        k_0 += 1;
                                        k_0;
                                    }
                                }
                                (*ph)
                                    .genreStations = PianoListAppend(
                                    if ((*ph).genreStations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).genreStations).head
                                    },
                                    &mut (*tmpGenreCategory).head,
                                ) as *mut PianoGenreCategory_t;
                                i_4 += 1;
                                i_4;
                            }
                        }
                    }
                    5260680050201874961 => {
                        let song_1: *mut PianoSong_t = (*req).data as *mut PianoSong_t;
                        (*song_1).rating = PIANO_RATE_TIRED;
                    }
                    11235674318412060590 => {
                        let mut tmpStation_0: *mut PianoStation_t = 0
                            as *mut PianoStation_t;
                        tmpStation_0 = calloc(
                            1 as libc::c_int as libc::c_ulong,
                            ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                        ) as *mut PianoStation_t;
                        if tmpStation_0.is_null() {
                            return PIANO_RET_OUT_OF_MEMORY;
                        }
                        PianoJsonParseStation(result, tmpStation_0);
                        let mut search: *mut PianoStation_t = PianoFindStationById(
                            (*ph).stations,
                            (*tmpStation_0).id,
                        );
                        if !search.is_null() {
                            (*ph)
                                .stations = PianoListDelete(
                                if ((*ph).stations).is_null() {
                                    0 as *mut PianoListHead_t
                                } else {
                                    &mut (*(*ph).stations).head
                                },
                                &mut (*search).head,
                            ) as *mut PianoStation_t;
                            PianoDestroyStation(search);
                            free(search as *mut libc::c_void);
                        }
                        (*ph)
                            .stations = PianoListAppend(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*tmpStation_0).head,
                        ) as *mut PianoStation_t;
                    }
                    10109057886293123569 => {
                        let mut reqData_4: *mut PianoRequestDataSearch_t = (*req).data
                            as *mut PianoRequestDataSearch_t;
                        let mut searchResult: *mut PianoSearchResult_t = 0
                            as *mut PianoSearchResult_t;
                        searchResult = &mut (*reqData_4).searchResult;
                        memset(
                            searchResult as *mut libc::c_void,
                            0 as libc::c_int,
                            ::std::mem::size_of::<PianoSearchResult_t>() as libc::c_ulong,
                        );
                        let mut artists: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"artists\0" as *const u8 as *const libc::c_char,
                            &mut artists,
                        ) != 0
                        {
                            let mut i_2: libc::c_int = 0 as libc::c_int;
                            while (i_2 as libc::c_ulong)
                                < json_object_array_length(artists)
                            {
                                let mut a: *mut json_object = json_object_array_get_idx(
                                    artists,
                                    i_2 as size_t,
                                );
                                let mut artist: *mut PianoArtist_t = 0
                                    as *mut PianoArtist_t;
                                artist = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                ) as *mut PianoArtist_t;
                                if artist.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*artist)
                                    .name = PianoJsonStrdup(
                                    a,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*artist)
                                    .musicId = PianoJsonStrdup(
                                    a,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .artists = PianoListAppend(
                                    if ((*searchResult).artists).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).artists).head
                                    },
                                    &mut (*artist).head,
                                ) as *mut PianoArtist_t;
                                i_2 += 1;
                                i_2;
                            }
                        }
                        let mut songs: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"songs\0" as *const u8 as *const libc::c_char,
                            &mut songs,
                        ) != 0
                        {
                            let mut i_3: libc::c_int = 0 as libc::c_int;
                            while (i_3 as libc::c_ulong)
                                < json_object_array_length(songs)
                            {
                                let mut s_1: *mut json_object = json_object_array_get_idx(
                                    songs,
                                    i_3 as size_t,
                                );
                                let mut song_0: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song_0 = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song_0.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*song_0)
                                    .title = PianoJsonStrdup(
                                    s_1,
                                    b"songName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .artist = PianoJsonStrdup(
                                    s_1,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .musicId = PianoJsonStrdup(
                                    s_1,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .songs = PianoListAppend(
                                    if ((*searchResult).songs).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).songs).head
                                    },
                                    &mut (*song_0).head,
                                ) as *mut PianoSong_t;
                                i_3 += 1;
                                i_3;
                            }
                        }
                    }
                    4983594971376015098 => {
                        let mut station: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*ph)
                            .stations = PianoListDelete(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*station).head,
                        ) as *mut PianoStation_t;
                        PianoDestroyStation(station);
                        free(station as *mut libc::c_void);
                    }
                    17372050596571538954 => {
                        let mut reqData_3: *mut PianoRequestDataRenameStation_t = (*req)
                            .data as *mut PianoRequestDataRenameStation_t;
                        free((*(*reqData_3).station).name as *mut libc::c_void);
                        (*(*reqData_3).station).name = strdup((*reqData_3).newName);
                    }
                    7297078374430259003 => {
                        let mut reqData_2: *mut PianoRequestDataRateSong_t = (*req).data
                            as *mut PianoRequestDataRateSong_t;
                        (*(*reqData_2).song).rating = (*reqData_2).rating;
                    }
                    17075014677070940716 => {
                        let mut reqData_1: *mut PianoRequestDataGetPlaylist_t = (*req)
                            .data as *mut PianoRequestDataGetPlaylist_t;
                        let mut playlist: *mut PianoSong_t = 0 as *mut PianoSong_t;
                        let mut items: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"items\0" as *const u8 as *const libc::c_char,
                            &mut items,
                        ) == 0)
                        {
                            let mut i_1: libc::c_int = 0 as libc::c_int;
                            loop {
                                if !((i_1 as libc::c_ulong)
                                    < json_object_array_length(items))
                                {
                                    current_block = 4488496028633655612;
                                    break;
                                }
                                let mut s_0: *mut json_object = json_object_array_get_idx(
                                    items,
                                    i_1 as size_t,
                                );
                                let mut song: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                if json_object_object_get_ex(
                                    s_0,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                    0 as *mut *mut json_object,
                                ) == 0
                                {
                                    free(song as *mut libc::c_void);
                                } else {
                                    static mut qualityMap: [*const libc::c_char; 4] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"lowQuality\0" as *const u8 as *const libc::c_char,
                                        b"mediumQuality\0" as *const u8 as *const libc::c_char,
                                        b"highQuality\0" as *const u8 as *const libc::c_char,
                                    ];
                                    static mut formatMap: [*const libc::c_char; 3] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"aacplus\0" as *const u8 as *const libc::c_char,
                                        b"mp3\0" as *const u8 as *const libc::c_char,
                                    ];
                                    let mut umap: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        s_0,
                                        b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                        &mut umap,
                                    ) != 0
                                    {
                                        let mut jsonEncoding: *mut json_object = 0
                                            as *mut json_object;
                                        let mut qmap: *mut json_object = 0 as *mut json_object;
                                        if json_object_object_get_ex(
                                            umap,
                                            qualityMap[(*reqData_1).quality as usize],
                                            &mut qmap,
                                        ) != 0
                                            && json_object_object_get_ex(
                                                qmap,
                                                b"encoding\0" as *const u8 as *const libc::c_char,
                                                &mut jsonEncoding,
                                            ) != 0
                                        {
                                            let mut encoding: *const libc::c_char = json_object_get_string(
                                                jsonEncoding,
                                            );
                                            let mut k: size_t = 0 as libc::c_int as size_t;
                                            while k
                                                < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                    as libc::c_ulong)
                                                    .wrapping_div(
                                                        ::std::mem::size_of::<*const libc::c_char>()
                                                            as libc::c_ulong,
                                                    )
                                            {
                                                if strcmp(formatMap[k as usize], encoding)
                                                    == 0 as libc::c_int
                                                {
                                                    (*song).audioFormat = k as PianoAudioFormat_t;
                                                    break;
                                                } else {
                                                    k = k.wrapping_add(1);
                                                    k;
                                                }
                                            }
                                            (*song)
                                                .audioUrl = PianoJsonStrdup(
                                                qmap,
                                                b"audioUrl\0" as *const u8 as *const libc::c_char,
                                            );
                                        } else {
                                            ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                            free(song as *mut libc::c_void);
                                            PianoDestroyPlaylist(playlist);
                                            current_block = 9169893888141833765;
                                            break;
                                        }
                                    }
                                    let mut v: *mut json_object = 0 as *mut json_object;
                                    (*song)
                                        .artist = PianoJsonStrdup(
                                        s_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .album = PianoJsonStrdup(
                                        s_0,
                                        b"albumName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .title = PianoJsonStrdup(
                                        s_0,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .trackToken = PianoJsonStrdup(
                                        s_0,
                                        b"trackToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .stationId = PianoJsonStrdup(
                                        s_0,
                                        b"stationId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .coverArt = PianoJsonStrdup(
                                        s_0,
                                        b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .detailUrl = PianoJsonStrdup(
                                        s_0,
                                        b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .fileGain = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackGain\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_double(v)
                                    } else {
                                        0.0f64
                                    }) as libc::c_float;
                                    (*song)
                                        .length = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackLength\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    }) as libc::c_uint;
                                    match if json_object_object_get_ex(
                                        s_0,
                                        b"songRating\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    } {
                                        1 => {
                                            (*song).rating = PIANO_RATE_LOVE;
                                        }
                                        _ => {}
                                    }
                                    playlist = PianoListAppend(
                                        if playlist.is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*playlist).head
                                        },
                                        &mut (*song).head,
                                    ) as *mut PianoSong_t;
                                }
                                i_1 += 1;
                                i_1;
                            }
                            match current_block {
                                9169893888141833765 => {}
                                _ => {
                                    (*reqData_1).retPlaylist = playlist;
                                }
                            }
                        }
                    }
                    6450597802325118133 => {
                        let mut stations: *mut json_object = 0 as *mut json_object;
                        let mut mix: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"stations\0" as *const u8 as *const libc::c_char,
                            &mut stations,
                        ) == 0)
                        {
                            let mut i: libc::c_int = 0 as libc::c_int;
                            while (i as libc::c_ulong)
                                < json_object_array_length(stations)
                            {
                                let mut tmpStation: *mut PianoStation_t = 0
                                    as *mut PianoStation_t;
                                let mut s: *mut json_object = json_object_array_get_idx(
                                    stations,
                                    i as size_t,
                                );
                                tmpStation = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                ) as *mut PianoStation_t;
                                if tmpStation.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                PianoJsonParseStation(s, tmpStation);
                                if (*tmpStation).isQuickMix != 0 {
                                    json_object_object_get_ex(
                                        s,
                                        b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                        &mut mix,
                                    );
                                }
                                (*ph)
                                    .stations = PianoListAppend(
                                    if ((*ph).stations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).stations).head
                                    },
                                    &mut (*tmpStation).head,
                                ) as *mut PianoStation_t;
                                i += 1;
                                i;
                            }
                            if !mix.is_null() {
                                let mut curStation: *mut PianoStation_t = (*ph).stations;
                                while !curStation.is_null() {
                                    let mut i_0: libc::c_int = 0 as libc::c_int;
                                    while (i_0 as libc::c_ulong) < json_object_array_length(mix)
                                    {
                                        let mut id: *mut json_object = json_object_array_get_idx(
                                            mix,
                                            i_0 as size_t,
                                        );
                                        if strcmp(json_object_get_string(id), (*curStation).id)
                                            == 0 as libc::c_int
                                        {
                                            (*curStation)
                                                .useQuickMix = 1 as libc::c_int as libc::c_char;
                                        }
                                        i_0 += 1;
                                        i_0;
                                    }
                                    curStation = (*curStation).head.next as *mut libc::c_void
                                        as *mut PianoStation_t;
                                }
                            }
                        }
                    }
                    12039483399334584727 => {
                        let mut reqData_0: *mut PianoRequestDataLogin_t = (*req).data
                            as *mut PianoRequestDataLogin_t;
                        match (*reqData_0).step as libc::c_int {
                            0 => {
                                let mut jsonTimestamp: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    result,
                                    b"syncTime\0" as *const u8 as *const libc::c_char,
                                    &mut jsonTimestamp,
                                ) == 0
                                {
                                    ret = PIANO_RET_INVALID_RESPONSE;
                                } else {
                                    let cryptedTimestamp: *const libc::c_char = json_object_get_string(
                                        jsonTimestamp,
                                    );
                                    let realTimestamp: time_t = time(0 as *mut time_t);
                                    let mut decryptedTimestamp: *mut libc::c_char = 0
                                        as *mut libc::c_char;
                                    let mut decryptedSize: size_t = 0;
                                    ret = PIANO_RET_ERR;
                                    decryptedTimestamp = PianoDecryptString(
                                        (*ph).partner.in_0,
                                        cryptedTimestamp,
                                        &mut decryptedSize,
                                    );
                                    if !decryptedTimestamp.is_null()
                                        && decryptedSize > 4 as libc::c_int as libc::c_ulong
                                    {
                                        let timestamp: libc::c_ulong = strtoul(
                                            decryptedTimestamp.offset(4 as libc::c_int as isize),
                                            0 as *mut *mut libc::c_char,
                                            0 as libc::c_int,
                                        );
                                        (*ph)
                                            .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                            as libc::c_int;
                                        ret = PIANO_RET_CONTINUE_REQUEST;
                                    }
                                    free(decryptedTimestamp as *mut libc::c_void);
                                    (*ph)
                                        .partner
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    let mut partnerId: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        result,
                                        b"partnerId\0" as *const u8 as *const libc::c_char,
                                        &mut partnerId,
                                    ) == 0
                                    {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        (*ph)
                                            .partner
                                            .id = json_object_get_int(partnerId) as libc::c_uint;
                                        (*reqData_0).step = ((*reqData_0).step).wrapping_add(1);
                                        (*reqData_0).step;
                                    }
                                }
                            }
                            1 => {
                                if !((*ph).user.listenerId).is_null() {
                                    PianoDestroyUserInfo(&mut (*ph).user);
                                }
                                (*ph)
                                    .user
                                    .listenerId = PianoJsonStrdup(
                                    result,
                                    b"userId\0" as *const u8 as *const libc::c_char,
                                );
                                (*ph)
                                    .user
                                    .authToken = PianoJsonStrdup(
                                    result,
                                    b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                );
                            }
                            _ => {}
                        }
                    }
                    10223170376184624358 => {
                        let mut reqData_8: *mut PianoRequestDataSetStationMode_t = (*req)
                            .data as *mut PianoRequestDataSetStationMode_t;
                        let mut active_0: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode_0: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode_0,
                        ) != 0
                        {
                            active_0 = json_object_get_int(activeMode_0);
                        }
                        if active_0 as libc::c_uint != (*reqData_8).id {
                            return PIANO_RET_ERR;
                        }
                    }
                    _ => {
                        let mut reqData_7: *mut PianoRequestDataGetStationModes_t = (*req)
                            .data as *mut PianoRequestDataGetStationModes_t;
                        let mut active: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode,
                        ) != 0
                        {
                            active = json_object_get_int(activeMode);
                        }
                        let mut availableModes: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"availableModes\0" as *const u8 as *const libc::c_char,
                            &mut availableModes,
                        ) != 0
                        {
                            let mut i_10: libc::c_int = 0 as libc::c_int;
                            while (i_10 as libc::c_ulong)
                                < json_object_array_length(availableModes)
                            {
                                let mut val_0: *mut json_object = json_object_array_get_idx(
                                    availableModes,
                                    i_10 as size_t,
                                );
                                let mut mode: *mut PianoStationMode_t = 0
                                    as *mut PianoStationMode_t;
                                mode = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                ) as *mut PianoStationMode_t;
                                if mode.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                let mut modeId: *mut json_object = 0 as *mut json_object;
                                if json_object_object_get_ex(
                                    val_0,
                                    b"modeId\0" as *const u8 as *const libc::c_char,
                                    &mut modeId,
                                ) != 0
                                {
                                    (*mode).id = json_object_get_int(modeId);
                                    (*mode)
                                        .name = PianoJsonStrdup(
                                        val_0,
                                        b"modeName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .description = PianoJsonStrdup(
                                        val_0,
                                        b"modeDescription\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .isAlgorithmic = getBoolDefault(
                                        val_0,
                                        b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode)
                                        .isTakeover = getBoolDefault(
                                        val_0,
                                        b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode).active = active == (*mode).id;
                                }
                                (*reqData_7)
                                    .retModes = PianoListAppend(
                                    if ((*reqData_7).retModes).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*reqData_7).retModes).head
                                    },
                                    &mut (*mode).head,
                                ) as *mut PianoStationMode_t;
                                i_10 += 1;
                                i_10;
                            }
                        }
                    }
                }
            }
            2 => {
                current_block = 6450597802325118133;
                match current_block {
                    14870924983410776565 => {}
                    4367030874028593650 => {
                        let mut reqData_6: *mut PianoRequestDataGetStationInfo_t = (*req)
                            .data as *mut PianoRequestDataGetStationInfo_t;
                        let mut info: *mut PianoStationInfo_t = 0
                            as *mut PianoStationInfo_t;
                        info = &mut (*reqData_6).info;
                        let mut music: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"music\0" as *const u8 as *const libc::c_char,
                            &mut music,
                        ) != 0
                        {
                            let mut songs_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs_0,
                            ) != 0
                            {
                                let mut i_6: libc::c_int = 0 as libc::c_int;
                                while (i_6 as libc::c_ulong)
                                    < json_object_array_length(songs_0)
                                {
                                    let mut s_4: *mut json_object = json_object_array_get_idx(
                                        songs_0,
                                        i_6 as size_t,
                                    );
                                    let mut seedSong: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                    seedSong = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    ) as *mut PianoSong_t;
                                    if seedSong.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedSong)
                                        .title = PianoJsonStrdup(
                                        s_4,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .artist = PianoJsonStrdup(
                                        s_4,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .seedId = PianoJsonStrdup(
                                        s_4,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .songSeeds = PianoListAppend(
                                        if ((*info).songSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).songSeeds).head
                                        },
                                        &mut (*seedSong).head,
                                    ) as *mut PianoSong_t;
                                    i_6 += 1;
                                    i_6;
                                }
                            }
                            let mut artists_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists_0,
                            ) != 0
                            {
                                let mut i_7: libc::c_int = 0 as libc::c_int;
                                while (i_7 as libc::c_ulong)
                                    < json_object_array_length(artists_0)
                                {
                                    let mut a_0: *mut json_object = json_object_array_get_idx(
                                        artists_0,
                                        i_7 as size_t,
                                    );
                                    let mut seedArtist: *mut PianoArtist_t = 0
                                        as *mut PianoArtist_t;
                                    seedArtist = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    ) as *mut PianoArtist_t;
                                    if seedArtist.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedArtist)
                                        .name = PianoJsonStrdup(
                                        a_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedArtist)
                                        .seedId = PianoJsonStrdup(
                                        a_0,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .artistSeeds = PianoListAppend(
                                        if ((*info).artistSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).artistSeeds).head
                                        },
                                        &mut (*seedArtist).head,
                                    ) as *mut PianoArtist_t;
                                    i_7 += 1;
                                    i_7;
                                }
                            }
                        }
                        let mut feedback: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"feedback\0" as *const u8 as *const libc::c_char,
                            &mut feedback,
                        ) != 0
                        {
                            static mut keys: [*const libc::c_char; 2] = [
                                b"thumbsUp\0" as *const u8 as *const libc::c_char,
                                b"thumbsDown\0" as *const u8 as *const libc::c_char,
                            ];
                            let mut i_8: size_t = 0 as libc::c_int as size_t;
                            while i_8
                                < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                    as libc::c_ulong)
                                    .wrapping_div(
                                        ::std::mem::size_of::<*const libc::c_char>()
                                            as libc::c_ulong,
                                    )
                            {
                                let mut val: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    feedback,
                                    keys[i_8 as usize],
                                    &mut val,
                                ) == 0)
                                {
                                    let mut i_9: libc::c_int = 0 as libc::c_int;
                                    while (i_9 as libc::c_ulong) < json_object_array_length(val)
                                    {
                                        let mut s_5: *mut json_object = json_object_array_get_idx(
                                            val,
                                            i_9 as size_t,
                                        );
                                        let mut feedbackSong: *mut PianoSong_t = 0
                                            as *mut PianoSong_t;
                                        feedbackSong = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        ) as *mut PianoSong_t;
                                        if feedbackSong.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*feedbackSong)
                                            .title = PianoJsonStrdup(
                                            s_5,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .artist = PianoJsonStrdup(
                                            s_5,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .feedbackId = PianoJsonStrdup(
                                            s_5,
                                            b"feedbackId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .rating = (if getBoolDefault(
                                            s_5,
                                            b"isPositive\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        ) as libc::c_int != 0
                                        {
                                            PIANO_RATE_LOVE as libc::c_int
                                        } else {
                                            PIANO_RATE_BAN as libc::c_int
                                        }) as PianoSongRating_t;
                                        let mut v_0: *mut json_object = 0 as *mut json_object;
                                        (*feedbackSong)
                                            .length = (if json_object_object_get_ex(
                                            s_5,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v_0,
                                        ) != 0
                                        {
                                            json_object_get_int(v_0)
                                        } else {
                                            0 as libc::c_int
                                        }) as libc::c_uint;
                                        (*info)
                                            .feedback = PianoListAppend(
                                            if ((*info).feedback).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*info).feedback).head
                                            },
                                            &mut (*feedbackSong).head,
                                        ) as *mut PianoSong_t;
                                        i_9 += 1;
                                        i_9;
                                    }
                                }
                                i_8 = i_8.wrapping_add(1);
                                i_8;
                            }
                        }
                    }
                    11202235766349324107 => {
                        let settings: *mut PianoSettings_t = (*req).data
                            as *mut PianoSettings_t;
                        (*settings)
                            .explicitContentFilter = getBoolDefault(
                            result,
                            b"isExplicitContentFilterEnabled\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int != 0,
                        );
                        (*settings)
                            .username = PianoJsonStrdup(
                            result,
                            b"username\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    145651165234646754 => {
                        let mut reqData_5: *mut PianoRequestDataExplain_t = (*req).data
                            as *mut PianoRequestDataExplain_t;
                        let strSize: size_t = 768 as libc::c_int as size_t;
                        let mut explanations: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"explanations\0" as *const u8 as *const libc::c_char,
                            &mut explanations,
                        ) != 0
                        {
                            (*reqData_5)
                                .retExplain = malloc(
                                strSize
                                    .wrapping_mul(
                                        ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                    ),
                            ) as *mut libc::c_char;
                            strncpy(
                                (*reqData_5).retExplain,
                                b"We're playing this track because it features \0"
                                    as *const u8 as *const libc::c_char,
                                strSize,
                            );
                            let mut i_5: libc::c_int = 0 as libc::c_int;
                            while (i_5 as libc::c_ulong)
                                < json_object_array_length(explanations)
                            {
                                let mut e: *mut json_object = json_object_array_get_idx(
                                    explanations,
                                    i_5 as size_t,
                                );
                                let mut f: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    e,
                                    b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                    &mut f,
                                ) == 0)
                                {
                                    let mut s_3: *const libc::c_char = json_object_get_string(
                                        f,
                                    );
                                    PianoStrpcat((*reqData_5).retExplain, s_3, strSize);
                                    if (i_5 as libc::c_ulong)
                                        < (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b", \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else if i_5 as libc::c_ulong
                                        == (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b" and \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b".\0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    }
                                }
                                i_5 += 1;
                                i_5;
                            }
                        }
                    }
                    9240481512215375588 => {
                        let mut station_0: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*station_0).isCreator = 1 as libc::c_int as libc::c_char;
                    }
                    5908482871227205451 => {
                        let mut categories: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"categories\0" as *const u8 as *const libc::c_char,
                            &mut categories,
                        ) != 0
                        {
                            let mut i_4: libc::c_int = 0 as libc::c_int;
                            while (i_4 as libc::c_ulong)
                                < json_object_array_length(categories)
                            {
                                let mut c: *mut json_object = json_object_array_get_idx(
                                    categories,
                                    i_4 as size_t,
                                );
                                let mut tmpGenreCategory: *mut PianoGenreCategory_t = 0
                                    as *mut PianoGenreCategory_t;
                                tmpGenreCategory = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoGenreCategory_t>()
                                        as libc::c_ulong,
                                ) as *mut PianoGenreCategory_t;
                                if tmpGenreCategory.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*tmpGenreCategory)
                                    .name = PianoJsonStrdup(
                                    c,
                                    b"categoryName\0" as *const u8 as *const libc::c_char,
                                );
                                let mut stations_0: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    c,
                                    b"stations\0" as *const u8 as *const libc::c_char,
                                    &mut stations_0,
                                ) != 0
                                {
                                    let mut k_0: libc::c_int = 0 as libc::c_int;
                                    while (k_0 as libc::c_ulong)
                                        < json_object_array_length(stations_0)
                                    {
                                        let mut s_2: *mut json_object = json_object_array_get_idx(
                                            stations_0,
                                            k_0 as size_t,
                                        );
                                        let mut tmpGenre: *mut PianoGenre_t = 0
                                            as *mut PianoGenre_t;
                                        tmpGenre = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                        ) as *mut PianoGenre_t;
                                        if tmpGenre.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*tmpGenre)
                                            .name = PianoJsonStrdup(
                                            s_2,
                                            b"stationName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenre)
                                            .musicId = PianoJsonStrdup(
                                            s_2,
                                            b"stationToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenreCategory)
                                            .genres = PianoListAppend(
                                            if ((*tmpGenreCategory).genres).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*tmpGenreCategory).genres).head
                                            },
                                            &mut (*tmpGenre).head,
                                        ) as *mut PianoGenre_t;
                                        k_0 += 1;
                                        k_0;
                                    }
                                }
                                (*ph)
                                    .genreStations = PianoListAppend(
                                    if ((*ph).genreStations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).genreStations).head
                                    },
                                    &mut (*tmpGenreCategory).head,
                                ) as *mut PianoGenreCategory_t;
                                i_4 += 1;
                                i_4;
                            }
                        }
                    }
                    5260680050201874961 => {
                        let song_1: *mut PianoSong_t = (*req).data as *mut PianoSong_t;
                        (*song_1).rating = PIANO_RATE_TIRED;
                    }
                    11235674318412060590 => {
                        let mut tmpStation_0: *mut PianoStation_t = 0
                            as *mut PianoStation_t;
                        tmpStation_0 = calloc(
                            1 as libc::c_int as libc::c_ulong,
                            ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                        ) as *mut PianoStation_t;
                        if tmpStation_0.is_null() {
                            return PIANO_RET_OUT_OF_MEMORY;
                        }
                        PianoJsonParseStation(result, tmpStation_0);
                        let mut search: *mut PianoStation_t = PianoFindStationById(
                            (*ph).stations,
                            (*tmpStation_0).id,
                        );
                        if !search.is_null() {
                            (*ph)
                                .stations = PianoListDelete(
                                if ((*ph).stations).is_null() {
                                    0 as *mut PianoListHead_t
                                } else {
                                    &mut (*(*ph).stations).head
                                },
                                &mut (*search).head,
                            ) as *mut PianoStation_t;
                            PianoDestroyStation(search);
                            free(search as *mut libc::c_void);
                        }
                        (*ph)
                            .stations = PianoListAppend(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*tmpStation_0).head,
                        ) as *mut PianoStation_t;
                    }
                    10109057886293123569 => {
                        let mut reqData_4: *mut PianoRequestDataSearch_t = (*req).data
                            as *mut PianoRequestDataSearch_t;
                        let mut searchResult: *mut PianoSearchResult_t = 0
                            as *mut PianoSearchResult_t;
                        searchResult = &mut (*reqData_4).searchResult;
                        memset(
                            searchResult as *mut libc::c_void,
                            0 as libc::c_int,
                            ::std::mem::size_of::<PianoSearchResult_t>() as libc::c_ulong,
                        );
                        let mut artists: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"artists\0" as *const u8 as *const libc::c_char,
                            &mut artists,
                        ) != 0
                        {
                            let mut i_2: libc::c_int = 0 as libc::c_int;
                            while (i_2 as libc::c_ulong)
                                < json_object_array_length(artists)
                            {
                                let mut a: *mut json_object = json_object_array_get_idx(
                                    artists,
                                    i_2 as size_t,
                                );
                                let mut artist: *mut PianoArtist_t = 0
                                    as *mut PianoArtist_t;
                                artist = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                ) as *mut PianoArtist_t;
                                if artist.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*artist)
                                    .name = PianoJsonStrdup(
                                    a,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*artist)
                                    .musicId = PianoJsonStrdup(
                                    a,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .artists = PianoListAppend(
                                    if ((*searchResult).artists).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).artists).head
                                    },
                                    &mut (*artist).head,
                                ) as *mut PianoArtist_t;
                                i_2 += 1;
                                i_2;
                            }
                        }
                        let mut songs: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"songs\0" as *const u8 as *const libc::c_char,
                            &mut songs,
                        ) != 0
                        {
                            let mut i_3: libc::c_int = 0 as libc::c_int;
                            while (i_3 as libc::c_ulong)
                                < json_object_array_length(songs)
                            {
                                let mut s_1: *mut json_object = json_object_array_get_idx(
                                    songs,
                                    i_3 as size_t,
                                );
                                let mut song_0: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song_0 = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song_0.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*song_0)
                                    .title = PianoJsonStrdup(
                                    s_1,
                                    b"songName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .artist = PianoJsonStrdup(
                                    s_1,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .musicId = PianoJsonStrdup(
                                    s_1,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .songs = PianoListAppend(
                                    if ((*searchResult).songs).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).songs).head
                                    },
                                    &mut (*song_0).head,
                                ) as *mut PianoSong_t;
                                i_3 += 1;
                                i_3;
                            }
                        }
                    }
                    4983594971376015098 => {
                        let mut station: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*ph)
                            .stations = PianoListDelete(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*station).head,
                        ) as *mut PianoStation_t;
                        PianoDestroyStation(station);
                        free(station as *mut libc::c_void);
                    }
                    17372050596571538954 => {
                        let mut reqData_3: *mut PianoRequestDataRenameStation_t = (*req)
                            .data as *mut PianoRequestDataRenameStation_t;
                        free((*(*reqData_3).station).name as *mut libc::c_void);
                        (*(*reqData_3).station).name = strdup((*reqData_3).newName);
                    }
                    7297078374430259003 => {
                        let mut reqData_2: *mut PianoRequestDataRateSong_t = (*req).data
                            as *mut PianoRequestDataRateSong_t;
                        (*(*reqData_2).song).rating = (*reqData_2).rating;
                    }
                    17075014677070940716 => {
                        let mut reqData_1: *mut PianoRequestDataGetPlaylist_t = (*req)
                            .data as *mut PianoRequestDataGetPlaylist_t;
                        let mut playlist: *mut PianoSong_t = 0 as *mut PianoSong_t;
                        let mut items: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"items\0" as *const u8 as *const libc::c_char,
                            &mut items,
                        ) == 0)
                        {
                            let mut i_1: libc::c_int = 0 as libc::c_int;
                            loop {
                                if !((i_1 as libc::c_ulong)
                                    < json_object_array_length(items))
                                {
                                    current_block = 4488496028633655612;
                                    break;
                                }
                                let mut s_0: *mut json_object = json_object_array_get_idx(
                                    items,
                                    i_1 as size_t,
                                );
                                let mut song: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                if json_object_object_get_ex(
                                    s_0,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                    0 as *mut *mut json_object,
                                ) == 0
                                {
                                    free(song as *mut libc::c_void);
                                } else {
                                    static mut qualityMap: [*const libc::c_char; 4] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"lowQuality\0" as *const u8 as *const libc::c_char,
                                        b"mediumQuality\0" as *const u8 as *const libc::c_char,
                                        b"highQuality\0" as *const u8 as *const libc::c_char,
                                    ];
                                    static mut formatMap: [*const libc::c_char; 3] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"aacplus\0" as *const u8 as *const libc::c_char,
                                        b"mp3\0" as *const u8 as *const libc::c_char,
                                    ];
                                    let mut umap: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        s_0,
                                        b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                        &mut umap,
                                    ) != 0
                                    {
                                        let mut jsonEncoding: *mut json_object = 0
                                            as *mut json_object;
                                        let mut qmap: *mut json_object = 0 as *mut json_object;
                                        if json_object_object_get_ex(
                                            umap,
                                            qualityMap[(*reqData_1).quality as usize],
                                            &mut qmap,
                                        ) != 0
                                            && json_object_object_get_ex(
                                                qmap,
                                                b"encoding\0" as *const u8 as *const libc::c_char,
                                                &mut jsonEncoding,
                                            ) != 0
                                        {
                                            let mut encoding: *const libc::c_char = json_object_get_string(
                                                jsonEncoding,
                                            );
                                            let mut k: size_t = 0 as libc::c_int as size_t;
                                            while k
                                                < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                    as libc::c_ulong)
                                                    .wrapping_div(
                                                        ::std::mem::size_of::<*const libc::c_char>()
                                                            as libc::c_ulong,
                                                    )
                                            {
                                                if strcmp(formatMap[k as usize], encoding)
                                                    == 0 as libc::c_int
                                                {
                                                    (*song).audioFormat = k as PianoAudioFormat_t;
                                                    break;
                                                } else {
                                                    k = k.wrapping_add(1);
                                                    k;
                                                }
                                            }
                                            (*song)
                                                .audioUrl = PianoJsonStrdup(
                                                qmap,
                                                b"audioUrl\0" as *const u8 as *const libc::c_char,
                                            );
                                        } else {
                                            ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                            free(song as *mut libc::c_void);
                                            PianoDestroyPlaylist(playlist);
                                            current_block = 9169893888141833765;
                                            break;
                                        }
                                    }
                                    let mut v: *mut json_object = 0 as *mut json_object;
                                    (*song)
                                        .artist = PianoJsonStrdup(
                                        s_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .album = PianoJsonStrdup(
                                        s_0,
                                        b"albumName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .title = PianoJsonStrdup(
                                        s_0,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .trackToken = PianoJsonStrdup(
                                        s_0,
                                        b"trackToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .stationId = PianoJsonStrdup(
                                        s_0,
                                        b"stationId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .coverArt = PianoJsonStrdup(
                                        s_0,
                                        b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .detailUrl = PianoJsonStrdup(
                                        s_0,
                                        b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .fileGain = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackGain\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_double(v)
                                    } else {
                                        0.0f64
                                    }) as libc::c_float;
                                    (*song)
                                        .length = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackLength\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    }) as libc::c_uint;
                                    match if json_object_object_get_ex(
                                        s_0,
                                        b"songRating\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    } {
                                        1 => {
                                            (*song).rating = PIANO_RATE_LOVE;
                                        }
                                        _ => {}
                                    }
                                    playlist = PianoListAppend(
                                        if playlist.is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*playlist).head
                                        },
                                        &mut (*song).head,
                                    ) as *mut PianoSong_t;
                                }
                                i_1 += 1;
                                i_1;
                            }
                            match current_block {
                                9169893888141833765 => {}
                                _ => {
                                    (*reqData_1).retPlaylist = playlist;
                                }
                            }
                        }
                    }
                    6450597802325118133 => {
                        let mut stations: *mut json_object = 0 as *mut json_object;
                        let mut mix: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"stations\0" as *const u8 as *const libc::c_char,
                            &mut stations,
                        ) == 0)
                        {
                            let mut i: libc::c_int = 0 as libc::c_int;
                            while (i as libc::c_ulong)
                                < json_object_array_length(stations)
                            {
                                let mut tmpStation: *mut PianoStation_t = 0
                                    as *mut PianoStation_t;
                                let mut s: *mut json_object = json_object_array_get_idx(
                                    stations,
                                    i as size_t,
                                );
                                tmpStation = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                ) as *mut PianoStation_t;
                                if tmpStation.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                PianoJsonParseStation(s, tmpStation);
                                if (*tmpStation).isQuickMix != 0 {
                                    json_object_object_get_ex(
                                        s,
                                        b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                        &mut mix,
                                    );
                                }
                                (*ph)
                                    .stations = PianoListAppend(
                                    if ((*ph).stations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).stations).head
                                    },
                                    &mut (*tmpStation).head,
                                ) as *mut PianoStation_t;
                                i += 1;
                                i;
                            }
                            if !mix.is_null() {
                                let mut curStation: *mut PianoStation_t = (*ph).stations;
                                while !curStation.is_null() {
                                    let mut i_0: libc::c_int = 0 as libc::c_int;
                                    while (i_0 as libc::c_ulong) < json_object_array_length(mix)
                                    {
                                        let mut id: *mut json_object = json_object_array_get_idx(
                                            mix,
                                            i_0 as size_t,
                                        );
                                        if strcmp(json_object_get_string(id), (*curStation).id)
                                            == 0 as libc::c_int
                                        {
                                            (*curStation)
                                                .useQuickMix = 1 as libc::c_int as libc::c_char;
                                        }
                                        i_0 += 1;
                                        i_0;
                                    }
                                    curStation = (*curStation).head.next as *mut libc::c_void
                                        as *mut PianoStation_t;
                                }
                            }
                        }
                    }
                    12039483399334584727 => {
                        let mut reqData_0: *mut PianoRequestDataLogin_t = (*req).data
                            as *mut PianoRequestDataLogin_t;
                        match (*reqData_0).step as libc::c_int {
                            0 => {
                                let mut jsonTimestamp: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    result,
                                    b"syncTime\0" as *const u8 as *const libc::c_char,
                                    &mut jsonTimestamp,
                                ) == 0
                                {
                                    ret = PIANO_RET_INVALID_RESPONSE;
                                } else {
                                    let cryptedTimestamp: *const libc::c_char = json_object_get_string(
                                        jsonTimestamp,
                                    );
                                    let realTimestamp: time_t = time(0 as *mut time_t);
                                    let mut decryptedTimestamp: *mut libc::c_char = 0
                                        as *mut libc::c_char;
                                    let mut decryptedSize: size_t = 0;
                                    ret = PIANO_RET_ERR;
                                    decryptedTimestamp = PianoDecryptString(
                                        (*ph).partner.in_0,
                                        cryptedTimestamp,
                                        &mut decryptedSize,
                                    );
                                    if !decryptedTimestamp.is_null()
                                        && decryptedSize > 4 as libc::c_int as libc::c_ulong
                                    {
                                        let timestamp: libc::c_ulong = strtoul(
                                            decryptedTimestamp.offset(4 as libc::c_int as isize),
                                            0 as *mut *mut libc::c_char,
                                            0 as libc::c_int,
                                        );
                                        (*ph)
                                            .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                            as libc::c_int;
                                        ret = PIANO_RET_CONTINUE_REQUEST;
                                    }
                                    free(decryptedTimestamp as *mut libc::c_void);
                                    (*ph)
                                        .partner
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    let mut partnerId: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        result,
                                        b"partnerId\0" as *const u8 as *const libc::c_char,
                                        &mut partnerId,
                                    ) == 0
                                    {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        (*ph)
                                            .partner
                                            .id = json_object_get_int(partnerId) as libc::c_uint;
                                        (*reqData_0).step = ((*reqData_0).step).wrapping_add(1);
                                        (*reqData_0).step;
                                    }
                                }
                            }
                            1 => {
                                if !((*ph).user.listenerId).is_null() {
                                    PianoDestroyUserInfo(&mut (*ph).user);
                                }
                                (*ph)
                                    .user
                                    .listenerId = PianoJsonStrdup(
                                    result,
                                    b"userId\0" as *const u8 as *const libc::c_char,
                                );
                                (*ph)
                                    .user
                                    .authToken = PianoJsonStrdup(
                                    result,
                                    b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                );
                            }
                            _ => {}
                        }
                    }
                    10223170376184624358 => {
                        let mut reqData_8: *mut PianoRequestDataSetStationMode_t = (*req)
                            .data as *mut PianoRequestDataSetStationMode_t;
                        let mut active_0: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode_0: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode_0,
                        ) != 0
                        {
                            active_0 = json_object_get_int(activeMode_0);
                        }
                        if active_0 as libc::c_uint != (*reqData_8).id {
                            return PIANO_RET_ERR;
                        }
                    }
                    _ => {
                        let mut reqData_7: *mut PianoRequestDataGetStationModes_t = (*req)
                            .data as *mut PianoRequestDataGetStationModes_t;
                        let mut active: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode,
                        ) != 0
                        {
                            active = json_object_get_int(activeMode);
                        }
                        let mut availableModes: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"availableModes\0" as *const u8 as *const libc::c_char,
                            &mut availableModes,
                        ) != 0
                        {
                            let mut i_10: libc::c_int = 0 as libc::c_int;
                            while (i_10 as libc::c_ulong)
                                < json_object_array_length(availableModes)
                            {
                                let mut val_0: *mut json_object = json_object_array_get_idx(
                                    availableModes,
                                    i_10 as size_t,
                                );
                                let mut mode: *mut PianoStationMode_t = 0
                                    as *mut PianoStationMode_t;
                                mode = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                ) as *mut PianoStationMode_t;
                                if mode.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                let mut modeId: *mut json_object = 0 as *mut json_object;
                                if json_object_object_get_ex(
                                    val_0,
                                    b"modeId\0" as *const u8 as *const libc::c_char,
                                    &mut modeId,
                                ) != 0
                                {
                                    (*mode).id = json_object_get_int(modeId);
                                    (*mode)
                                        .name = PianoJsonStrdup(
                                        val_0,
                                        b"modeName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .description = PianoJsonStrdup(
                                        val_0,
                                        b"modeDescription\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .isAlgorithmic = getBoolDefault(
                                        val_0,
                                        b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode)
                                        .isTakeover = getBoolDefault(
                                        val_0,
                                        b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode).active = active == (*mode).id;
                                }
                                (*reqData_7)
                                    .retModes = PianoListAppend(
                                    if ((*reqData_7).retModes).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*reqData_7).retModes).head
                                    },
                                    &mut (*mode).head,
                                ) as *mut PianoStationMode_t;
                                i_10 += 1;
                                i_10;
                            }
                        }
                    }
                }
            }
            3 => {
                current_block = 17075014677070940716;
                match current_block {
                    14870924983410776565 => {}
                    4367030874028593650 => {
                        let mut reqData_6: *mut PianoRequestDataGetStationInfo_t = (*req)
                            .data as *mut PianoRequestDataGetStationInfo_t;
                        let mut info: *mut PianoStationInfo_t = 0
                            as *mut PianoStationInfo_t;
                        info = &mut (*reqData_6).info;
                        let mut music: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"music\0" as *const u8 as *const libc::c_char,
                            &mut music,
                        ) != 0
                        {
                            let mut songs_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs_0,
                            ) != 0
                            {
                                let mut i_6: libc::c_int = 0 as libc::c_int;
                                while (i_6 as libc::c_ulong)
                                    < json_object_array_length(songs_0)
                                {
                                    let mut s_4: *mut json_object = json_object_array_get_idx(
                                        songs_0,
                                        i_6 as size_t,
                                    );
                                    let mut seedSong: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                    seedSong = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    ) as *mut PianoSong_t;
                                    if seedSong.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedSong)
                                        .title = PianoJsonStrdup(
                                        s_4,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .artist = PianoJsonStrdup(
                                        s_4,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .seedId = PianoJsonStrdup(
                                        s_4,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .songSeeds = PianoListAppend(
                                        if ((*info).songSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).songSeeds).head
                                        },
                                        &mut (*seedSong).head,
                                    ) as *mut PianoSong_t;
                                    i_6 += 1;
                                    i_6;
                                }
                            }
                            let mut artists_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists_0,
                            ) != 0
                            {
                                let mut i_7: libc::c_int = 0 as libc::c_int;
                                while (i_7 as libc::c_ulong)
                                    < json_object_array_length(artists_0)
                                {
                                    let mut a_0: *mut json_object = json_object_array_get_idx(
                                        artists_0,
                                        i_7 as size_t,
                                    );
                                    let mut seedArtist: *mut PianoArtist_t = 0
                                        as *mut PianoArtist_t;
                                    seedArtist = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    ) as *mut PianoArtist_t;
                                    if seedArtist.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedArtist)
                                        .name = PianoJsonStrdup(
                                        a_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedArtist)
                                        .seedId = PianoJsonStrdup(
                                        a_0,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .artistSeeds = PianoListAppend(
                                        if ((*info).artistSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).artistSeeds).head
                                        },
                                        &mut (*seedArtist).head,
                                    ) as *mut PianoArtist_t;
                                    i_7 += 1;
                                    i_7;
                                }
                            }
                        }
                        let mut feedback: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"feedback\0" as *const u8 as *const libc::c_char,
                            &mut feedback,
                        ) != 0
                        {
                            static mut keys: [*const libc::c_char; 2] = [
                                b"thumbsUp\0" as *const u8 as *const libc::c_char,
                                b"thumbsDown\0" as *const u8 as *const libc::c_char,
                            ];
                            let mut i_8: size_t = 0 as libc::c_int as size_t;
                            while i_8
                                < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                    as libc::c_ulong)
                                    .wrapping_div(
                                        ::std::mem::size_of::<*const libc::c_char>()
                                            as libc::c_ulong,
                                    )
                            {
                                let mut val: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    feedback,
                                    keys[i_8 as usize],
                                    &mut val,
                                ) == 0)
                                {
                                    let mut i_9: libc::c_int = 0 as libc::c_int;
                                    while (i_9 as libc::c_ulong) < json_object_array_length(val)
                                    {
                                        let mut s_5: *mut json_object = json_object_array_get_idx(
                                            val,
                                            i_9 as size_t,
                                        );
                                        let mut feedbackSong: *mut PianoSong_t = 0
                                            as *mut PianoSong_t;
                                        feedbackSong = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        ) as *mut PianoSong_t;
                                        if feedbackSong.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*feedbackSong)
                                            .title = PianoJsonStrdup(
                                            s_5,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .artist = PianoJsonStrdup(
                                            s_5,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .feedbackId = PianoJsonStrdup(
                                            s_5,
                                            b"feedbackId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .rating = (if getBoolDefault(
                                            s_5,
                                            b"isPositive\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        ) as libc::c_int != 0
                                        {
                                            PIANO_RATE_LOVE as libc::c_int
                                        } else {
                                            PIANO_RATE_BAN as libc::c_int
                                        }) as PianoSongRating_t;
                                        let mut v_0: *mut json_object = 0 as *mut json_object;
                                        (*feedbackSong)
                                            .length = (if json_object_object_get_ex(
                                            s_5,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v_0,
                                        ) != 0
                                        {
                                            json_object_get_int(v_0)
                                        } else {
                                            0 as libc::c_int
                                        }) as libc::c_uint;
                                        (*info)
                                            .feedback = PianoListAppend(
                                            if ((*info).feedback).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*info).feedback).head
                                            },
                                            &mut (*feedbackSong).head,
                                        ) as *mut PianoSong_t;
                                        i_9 += 1;
                                        i_9;
                                    }
                                }
                                i_8 = i_8.wrapping_add(1);
                                i_8;
                            }
                        }
                    }
                    11202235766349324107 => {
                        let settings: *mut PianoSettings_t = (*req).data
                            as *mut PianoSettings_t;
                        (*settings)
                            .explicitContentFilter = getBoolDefault(
                            result,
                            b"isExplicitContentFilterEnabled\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int != 0,
                        );
                        (*settings)
                            .username = PianoJsonStrdup(
                            result,
                            b"username\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    145651165234646754 => {
                        let mut reqData_5: *mut PianoRequestDataExplain_t = (*req).data
                            as *mut PianoRequestDataExplain_t;
                        let strSize: size_t = 768 as libc::c_int as size_t;
                        let mut explanations: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"explanations\0" as *const u8 as *const libc::c_char,
                            &mut explanations,
                        ) != 0
                        {
                            (*reqData_5)
                                .retExplain = malloc(
                                strSize
                                    .wrapping_mul(
                                        ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                    ),
                            ) as *mut libc::c_char;
                            strncpy(
                                (*reqData_5).retExplain,
                                b"We're playing this track because it features \0"
                                    as *const u8 as *const libc::c_char,
                                strSize,
                            );
                            let mut i_5: libc::c_int = 0 as libc::c_int;
                            while (i_5 as libc::c_ulong)
                                < json_object_array_length(explanations)
                            {
                                let mut e: *mut json_object = json_object_array_get_idx(
                                    explanations,
                                    i_5 as size_t,
                                );
                                let mut f: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    e,
                                    b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                    &mut f,
                                ) == 0)
                                {
                                    let mut s_3: *const libc::c_char = json_object_get_string(
                                        f,
                                    );
                                    PianoStrpcat((*reqData_5).retExplain, s_3, strSize);
                                    if (i_5 as libc::c_ulong)
                                        < (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b", \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else if i_5 as libc::c_ulong
                                        == (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b" and \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b".\0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    }
                                }
                                i_5 += 1;
                                i_5;
                            }
                        }
                    }
                    9240481512215375588 => {
                        let mut station_0: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*station_0).isCreator = 1 as libc::c_int as libc::c_char;
                    }
                    5908482871227205451 => {
                        let mut categories: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"categories\0" as *const u8 as *const libc::c_char,
                            &mut categories,
                        ) != 0
                        {
                            let mut i_4: libc::c_int = 0 as libc::c_int;
                            while (i_4 as libc::c_ulong)
                                < json_object_array_length(categories)
                            {
                                let mut c: *mut json_object = json_object_array_get_idx(
                                    categories,
                                    i_4 as size_t,
                                );
                                let mut tmpGenreCategory: *mut PianoGenreCategory_t = 0
                                    as *mut PianoGenreCategory_t;
                                tmpGenreCategory = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoGenreCategory_t>()
                                        as libc::c_ulong,
                                ) as *mut PianoGenreCategory_t;
                                if tmpGenreCategory.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*tmpGenreCategory)
                                    .name = PianoJsonStrdup(
                                    c,
                                    b"categoryName\0" as *const u8 as *const libc::c_char,
                                );
                                let mut stations_0: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    c,
                                    b"stations\0" as *const u8 as *const libc::c_char,
                                    &mut stations_0,
                                ) != 0
                                {
                                    let mut k_0: libc::c_int = 0 as libc::c_int;
                                    while (k_0 as libc::c_ulong)
                                        < json_object_array_length(stations_0)
                                    {
                                        let mut s_2: *mut json_object = json_object_array_get_idx(
                                            stations_0,
                                            k_0 as size_t,
                                        );
                                        let mut tmpGenre: *mut PianoGenre_t = 0
                                            as *mut PianoGenre_t;
                                        tmpGenre = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                        ) as *mut PianoGenre_t;
                                        if tmpGenre.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*tmpGenre)
                                            .name = PianoJsonStrdup(
                                            s_2,
                                            b"stationName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenre)
                                            .musicId = PianoJsonStrdup(
                                            s_2,
                                            b"stationToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenreCategory)
                                            .genres = PianoListAppend(
                                            if ((*tmpGenreCategory).genres).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*tmpGenreCategory).genres).head
                                            },
                                            &mut (*tmpGenre).head,
                                        ) as *mut PianoGenre_t;
                                        k_0 += 1;
                                        k_0;
                                    }
                                }
                                (*ph)
                                    .genreStations = PianoListAppend(
                                    if ((*ph).genreStations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).genreStations).head
                                    },
                                    &mut (*tmpGenreCategory).head,
                                ) as *mut PianoGenreCategory_t;
                                i_4 += 1;
                                i_4;
                            }
                        }
                    }
                    5260680050201874961 => {
                        let song_1: *mut PianoSong_t = (*req).data as *mut PianoSong_t;
                        (*song_1).rating = PIANO_RATE_TIRED;
                    }
                    11235674318412060590 => {
                        let mut tmpStation_0: *mut PianoStation_t = 0
                            as *mut PianoStation_t;
                        tmpStation_0 = calloc(
                            1 as libc::c_int as libc::c_ulong,
                            ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                        ) as *mut PianoStation_t;
                        if tmpStation_0.is_null() {
                            return PIANO_RET_OUT_OF_MEMORY;
                        }
                        PianoJsonParseStation(result, tmpStation_0);
                        let mut search: *mut PianoStation_t = PianoFindStationById(
                            (*ph).stations,
                            (*tmpStation_0).id,
                        );
                        if !search.is_null() {
                            (*ph)
                                .stations = PianoListDelete(
                                if ((*ph).stations).is_null() {
                                    0 as *mut PianoListHead_t
                                } else {
                                    &mut (*(*ph).stations).head
                                },
                                &mut (*search).head,
                            ) as *mut PianoStation_t;
                            PianoDestroyStation(search);
                            free(search as *mut libc::c_void);
                        }
                        (*ph)
                            .stations = PianoListAppend(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*tmpStation_0).head,
                        ) as *mut PianoStation_t;
                    }
                    10109057886293123569 => {
                        let mut reqData_4: *mut PianoRequestDataSearch_t = (*req).data
                            as *mut PianoRequestDataSearch_t;
                        let mut searchResult: *mut PianoSearchResult_t = 0
                            as *mut PianoSearchResult_t;
                        searchResult = &mut (*reqData_4).searchResult;
                        memset(
                            searchResult as *mut libc::c_void,
                            0 as libc::c_int,
                            ::std::mem::size_of::<PianoSearchResult_t>() as libc::c_ulong,
                        );
                        let mut artists: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"artists\0" as *const u8 as *const libc::c_char,
                            &mut artists,
                        ) != 0
                        {
                            let mut i_2: libc::c_int = 0 as libc::c_int;
                            while (i_2 as libc::c_ulong)
                                < json_object_array_length(artists)
                            {
                                let mut a: *mut json_object = json_object_array_get_idx(
                                    artists,
                                    i_2 as size_t,
                                );
                                let mut artist: *mut PianoArtist_t = 0
                                    as *mut PianoArtist_t;
                                artist = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                ) as *mut PianoArtist_t;
                                if artist.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*artist)
                                    .name = PianoJsonStrdup(
                                    a,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*artist)
                                    .musicId = PianoJsonStrdup(
                                    a,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .artists = PianoListAppend(
                                    if ((*searchResult).artists).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).artists).head
                                    },
                                    &mut (*artist).head,
                                ) as *mut PianoArtist_t;
                                i_2 += 1;
                                i_2;
                            }
                        }
                        let mut songs: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"songs\0" as *const u8 as *const libc::c_char,
                            &mut songs,
                        ) != 0
                        {
                            let mut i_3: libc::c_int = 0 as libc::c_int;
                            while (i_3 as libc::c_ulong)
                                < json_object_array_length(songs)
                            {
                                let mut s_1: *mut json_object = json_object_array_get_idx(
                                    songs,
                                    i_3 as size_t,
                                );
                                let mut song_0: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song_0 = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song_0.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*song_0)
                                    .title = PianoJsonStrdup(
                                    s_1,
                                    b"songName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .artist = PianoJsonStrdup(
                                    s_1,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .musicId = PianoJsonStrdup(
                                    s_1,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .songs = PianoListAppend(
                                    if ((*searchResult).songs).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).songs).head
                                    },
                                    &mut (*song_0).head,
                                ) as *mut PianoSong_t;
                                i_3 += 1;
                                i_3;
                            }
                        }
                    }
                    4983594971376015098 => {
                        let mut station: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*ph)
                            .stations = PianoListDelete(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*station).head,
                        ) as *mut PianoStation_t;
                        PianoDestroyStation(station);
                        free(station as *mut libc::c_void);
                    }
                    17372050596571538954 => {
                        let mut reqData_3: *mut PianoRequestDataRenameStation_t = (*req)
                            .data as *mut PianoRequestDataRenameStation_t;
                        free((*(*reqData_3).station).name as *mut libc::c_void);
                        (*(*reqData_3).station).name = strdup((*reqData_3).newName);
                    }
                    7297078374430259003 => {
                        let mut reqData_2: *mut PianoRequestDataRateSong_t = (*req).data
                            as *mut PianoRequestDataRateSong_t;
                        (*(*reqData_2).song).rating = (*reqData_2).rating;
                    }
                    17075014677070940716 => {
                        let mut reqData_1: *mut PianoRequestDataGetPlaylist_t = (*req)
                            .data as *mut PianoRequestDataGetPlaylist_t;
                        let mut playlist: *mut PianoSong_t = 0 as *mut PianoSong_t;
                        let mut items: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"items\0" as *const u8 as *const libc::c_char,
                            &mut items,
                        ) == 0)
                        {
                            let mut i_1: libc::c_int = 0 as libc::c_int;
                            loop {
                                if !((i_1 as libc::c_ulong)
                                    < json_object_array_length(items))
                                {
                                    current_block = 4488496028633655612;
                                    break;
                                }
                                let mut s_0: *mut json_object = json_object_array_get_idx(
                                    items,
                                    i_1 as size_t,
                                );
                                let mut song: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                if json_object_object_get_ex(
                                    s_0,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                    0 as *mut *mut json_object,
                                ) == 0
                                {
                                    free(song as *mut libc::c_void);
                                } else {
                                    static mut qualityMap: [*const libc::c_char; 4] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"lowQuality\0" as *const u8 as *const libc::c_char,
                                        b"mediumQuality\0" as *const u8 as *const libc::c_char,
                                        b"highQuality\0" as *const u8 as *const libc::c_char,
                                    ];
                                    static mut formatMap: [*const libc::c_char; 3] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"aacplus\0" as *const u8 as *const libc::c_char,
                                        b"mp3\0" as *const u8 as *const libc::c_char,
                                    ];
                                    let mut umap: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        s_0,
                                        b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                        &mut umap,
                                    ) != 0
                                    {
                                        let mut jsonEncoding: *mut json_object = 0
                                            as *mut json_object;
                                        let mut qmap: *mut json_object = 0 as *mut json_object;
                                        if json_object_object_get_ex(
                                            umap,
                                            qualityMap[(*reqData_1).quality as usize],
                                            &mut qmap,
                                        ) != 0
                                            && json_object_object_get_ex(
                                                qmap,
                                                b"encoding\0" as *const u8 as *const libc::c_char,
                                                &mut jsonEncoding,
                                            ) != 0
                                        {
                                            let mut encoding: *const libc::c_char = json_object_get_string(
                                                jsonEncoding,
                                            );
                                            let mut k: size_t = 0 as libc::c_int as size_t;
                                            while k
                                                < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                    as libc::c_ulong)
                                                    .wrapping_div(
                                                        ::std::mem::size_of::<*const libc::c_char>()
                                                            as libc::c_ulong,
                                                    )
                                            {
                                                if strcmp(formatMap[k as usize], encoding)
                                                    == 0 as libc::c_int
                                                {
                                                    (*song).audioFormat = k as PianoAudioFormat_t;
                                                    break;
                                                } else {
                                                    k = k.wrapping_add(1);
                                                    k;
                                                }
                                            }
                                            (*song)
                                                .audioUrl = PianoJsonStrdup(
                                                qmap,
                                                b"audioUrl\0" as *const u8 as *const libc::c_char,
                                            );
                                        } else {
                                            ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                            free(song as *mut libc::c_void);
                                            PianoDestroyPlaylist(playlist);
                                            current_block = 9169893888141833765;
                                            break;
                                        }
                                    }
                                    let mut v: *mut json_object = 0 as *mut json_object;
                                    (*song)
                                        .artist = PianoJsonStrdup(
                                        s_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .album = PianoJsonStrdup(
                                        s_0,
                                        b"albumName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .title = PianoJsonStrdup(
                                        s_0,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .trackToken = PianoJsonStrdup(
                                        s_0,
                                        b"trackToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .stationId = PianoJsonStrdup(
                                        s_0,
                                        b"stationId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .coverArt = PianoJsonStrdup(
                                        s_0,
                                        b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .detailUrl = PianoJsonStrdup(
                                        s_0,
                                        b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .fileGain = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackGain\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_double(v)
                                    } else {
                                        0.0f64
                                    }) as libc::c_float;
                                    (*song)
                                        .length = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackLength\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    }) as libc::c_uint;
                                    match if json_object_object_get_ex(
                                        s_0,
                                        b"songRating\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    } {
                                        1 => {
                                            (*song).rating = PIANO_RATE_LOVE;
                                        }
                                        _ => {}
                                    }
                                    playlist = PianoListAppend(
                                        if playlist.is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*playlist).head
                                        },
                                        &mut (*song).head,
                                    ) as *mut PianoSong_t;
                                }
                                i_1 += 1;
                                i_1;
                            }
                            match current_block {
                                9169893888141833765 => {}
                                _ => {
                                    (*reqData_1).retPlaylist = playlist;
                                }
                            }
                        }
                    }
                    6450597802325118133 => {
                        let mut stations: *mut json_object = 0 as *mut json_object;
                        let mut mix: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"stations\0" as *const u8 as *const libc::c_char,
                            &mut stations,
                        ) == 0)
                        {
                            let mut i: libc::c_int = 0 as libc::c_int;
                            while (i as libc::c_ulong)
                                < json_object_array_length(stations)
                            {
                                let mut tmpStation: *mut PianoStation_t = 0
                                    as *mut PianoStation_t;
                                let mut s: *mut json_object = json_object_array_get_idx(
                                    stations,
                                    i as size_t,
                                );
                                tmpStation = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                ) as *mut PianoStation_t;
                                if tmpStation.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                PianoJsonParseStation(s, tmpStation);
                                if (*tmpStation).isQuickMix != 0 {
                                    json_object_object_get_ex(
                                        s,
                                        b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                        &mut mix,
                                    );
                                }
                                (*ph)
                                    .stations = PianoListAppend(
                                    if ((*ph).stations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).stations).head
                                    },
                                    &mut (*tmpStation).head,
                                ) as *mut PianoStation_t;
                                i += 1;
                                i;
                            }
                            if !mix.is_null() {
                                let mut curStation: *mut PianoStation_t = (*ph).stations;
                                while !curStation.is_null() {
                                    let mut i_0: libc::c_int = 0 as libc::c_int;
                                    while (i_0 as libc::c_ulong) < json_object_array_length(mix)
                                    {
                                        let mut id: *mut json_object = json_object_array_get_idx(
                                            mix,
                                            i_0 as size_t,
                                        );
                                        if strcmp(json_object_get_string(id), (*curStation).id)
                                            == 0 as libc::c_int
                                        {
                                            (*curStation)
                                                .useQuickMix = 1 as libc::c_int as libc::c_char;
                                        }
                                        i_0 += 1;
                                        i_0;
                                    }
                                    curStation = (*curStation).head.next as *mut libc::c_void
                                        as *mut PianoStation_t;
                                }
                            }
                        }
                    }
                    12039483399334584727 => {
                        let mut reqData_0: *mut PianoRequestDataLogin_t = (*req).data
                            as *mut PianoRequestDataLogin_t;
                        match (*reqData_0).step as libc::c_int {
                            0 => {
                                let mut jsonTimestamp: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    result,
                                    b"syncTime\0" as *const u8 as *const libc::c_char,
                                    &mut jsonTimestamp,
                                ) == 0
                                {
                                    ret = PIANO_RET_INVALID_RESPONSE;
                                } else {
                                    let cryptedTimestamp: *const libc::c_char = json_object_get_string(
                                        jsonTimestamp,
                                    );
                                    let realTimestamp: time_t = time(0 as *mut time_t);
                                    let mut decryptedTimestamp: *mut libc::c_char = 0
                                        as *mut libc::c_char;
                                    let mut decryptedSize: size_t = 0;
                                    ret = PIANO_RET_ERR;
                                    decryptedTimestamp = PianoDecryptString(
                                        (*ph).partner.in_0,
                                        cryptedTimestamp,
                                        &mut decryptedSize,
                                    );
                                    if !decryptedTimestamp.is_null()
                                        && decryptedSize > 4 as libc::c_int as libc::c_ulong
                                    {
                                        let timestamp: libc::c_ulong = strtoul(
                                            decryptedTimestamp.offset(4 as libc::c_int as isize),
                                            0 as *mut *mut libc::c_char,
                                            0 as libc::c_int,
                                        );
                                        (*ph)
                                            .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                            as libc::c_int;
                                        ret = PIANO_RET_CONTINUE_REQUEST;
                                    }
                                    free(decryptedTimestamp as *mut libc::c_void);
                                    (*ph)
                                        .partner
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    let mut partnerId: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        result,
                                        b"partnerId\0" as *const u8 as *const libc::c_char,
                                        &mut partnerId,
                                    ) == 0
                                    {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        (*ph)
                                            .partner
                                            .id = json_object_get_int(partnerId) as libc::c_uint;
                                        (*reqData_0).step = ((*reqData_0).step).wrapping_add(1);
                                        (*reqData_0).step;
                                    }
                                }
                            }
                            1 => {
                                if !((*ph).user.listenerId).is_null() {
                                    PianoDestroyUserInfo(&mut (*ph).user);
                                }
                                (*ph)
                                    .user
                                    .listenerId = PianoJsonStrdup(
                                    result,
                                    b"userId\0" as *const u8 as *const libc::c_char,
                                );
                                (*ph)
                                    .user
                                    .authToken = PianoJsonStrdup(
                                    result,
                                    b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                );
                            }
                            _ => {}
                        }
                    }
                    10223170376184624358 => {
                        let mut reqData_8: *mut PianoRequestDataSetStationMode_t = (*req)
                            .data as *mut PianoRequestDataSetStationMode_t;
                        let mut active_0: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode_0: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode_0,
                        ) != 0
                        {
                            active_0 = json_object_get_int(activeMode_0);
                        }
                        if active_0 as libc::c_uint != (*reqData_8).id {
                            return PIANO_RET_ERR;
                        }
                    }
                    _ => {
                        let mut reqData_7: *mut PianoRequestDataGetStationModes_t = (*req)
                            .data as *mut PianoRequestDataGetStationModes_t;
                        let mut active: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode,
                        ) != 0
                        {
                            active = json_object_get_int(activeMode);
                        }
                        let mut availableModes: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"availableModes\0" as *const u8 as *const libc::c_char,
                            &mut availableModes,
                        ) != 0
                        {
                            let mut i_10: libc::c_int = 0 as libc::c_int;
                            while (i_10 as libc::c_ulong)
                                < json_object_array_length(availableModes)
                            {
                                let mut val_0: *mut json_object = json_object_array_get_idx(
                                    availableModes,
                                    i_10 as size_t,
                                );
                                let mut mode: *mut PianoStationMode_t = 0
                                    as *mut PianoStationMode_t;
                                mode = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                ) as *mut PianoStationMode_t;
                                if mode.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                let mut modeId: *mut json_object = 0 as *mut json_object;
                                if json_object_object_get_ex(
                                    val_0,
                                    b"modeId\0" as *const u8 as *const libc::c_char,
                                    &mut modeId,
                                ) != 0
                                {
                                    (*mode).id = json_object_get_int(modeId);
                                    (*mode)
                                        .name = PianoJsonStrdup(
                                        val_0,
                                        b"modeName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .description = PianoJsonStrdup(
                                        val_0,
                                        b"modeDescription\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .isAlgorithmic = getBoolDefault(
                                        val_0,
                                        b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode)
                                        .isTakeover = getBoolDefault(
                                        val_0,
                                        b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode).active = active == (*mode).id;
                                }
                                (*reqData_7)
                                    .retModes = PianoListAppend(
                                    if ((*reqData_7).retModes).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*reqData_7).retModes).head
                                    },
                                    &mut (*mode).head,
                                ) as *mut PianoStationMode_t;
                                i_10 += 1;
                                i_10;
                            }
                        }
                    }
                }
            }
            4 => {
                current_block = 7297078374430259003;
                match current_block {
                    14870924983410776565 => {}
                    4367030874028593650 => {
                        let mut reqData_6: *mut PianoRequestDataGetStationInfo_t = (*req)
                            .data as *mut PianoRequestDataGetStationInfo_t;
                        let mut info: *mut PianoStationInfo_t = 0
                            as *mut PianoStationInfo_t;
                        info = &mut (*reqData_6).info;
                        let mut music: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"music\0" as *const u8 as *const libc::c_char,
                            &mut music,
                        ) != 0
                        {
                            let mut songs_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs_0,
                            ) != 0
                            {
                                let mut i_6: libc::c_int = 0 as libc::c_int;
                                while (i_6 as libc::c_ulong)
                                    < json_object_array_length(songs_0)
                                {
                                    let mut s_4: *mut json_object = json_object_array_get_idx(
                                        songs_0,
                                        i_6 as size_t,
                                    );
                                    let mut seedSong: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                    seedSong = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    ) as *mut PianoSong_t;
                                    if seedSong.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedSong)
                                        .title = PianoJsonStrdup(
                                        s_4,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .artist = PianoJsonStrdup(
                                        s_4,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .seedId = PianoJsonStrdup(
                                        s_4,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .songSeeds = PianoListAppend(
                                        if ((*info).songSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).songSeeds).head
                                        },
                                        &mut (*seedSong).head,
                                    ) as *mut PianoSong_t;
                                    i_6 += 1;
                                    i_6;
                                }
                            }
                            let mut artists_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists_0,
                            ) != 0
                            {
                                let mut i_7: libc::c_int = 0 as libc::c_int;
                                while (i_7 as libc::c_ulong)
                                    < json_object_array_length(artists_0)
                                {
                                    let mut a_0: *mut json_object = json_object_array_get_idx(
                                        artists_0,
                                        i_7 as size_t,
                                    );
                                    let mut seedArtist: *mut PianoArtist_t = 0
                                        as *mut PianoArtist_t;
                                    seedArtist = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    ) as *mut PianoArtist_t;
                                    if seedArtist.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedArtist)
                                        .name = PianoJsonStrdup(
                                        a_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedArtist)
                                        .seedId = PianoJsonStrdup(
                                        a_0,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .artistSeeds = PianoListAppend(
                                        if ((*info).artistSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).artistSeeds).head
                                        },
                                        &mut (*seedArtist).head,
                                    ) as *mut PianoArtist_t;
                                    i_7 += 1;
                                    i_7;
                                }
                            }
                        }
                        let mut feedback: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"feedback\0" as *const u8 as *const libc::c_char,
                            &mut feedback,
                        ) != 0
                        {
                            static mut keys: [*const libc::c_char; 2] = [
                                b"thumbsUp\0" as *const u8 as *const libc::c_char,
                                b"thumbsDown\0" as *const u8 as *const libc::c_char,
                            ];
                            let mut i_8: size_t = 0 as libc::c_int as size_t;
                            while i_8
                                < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                    as libc::c_ulong)
                                    .wrapping_div(
                                        ::std::mem::size_of::<*const libc::c_char>()
                                            as libc::c_ulong,
                                    )
                            {
                                let mut val: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    feedback,
                                    keys[i_8 as usize],
                                    &mut val,
                                ) == 0)
                                {
                                    let mut i_9: libc::c_int = 0 as libc::c_int;
                                    while (i_9 as libc::c_ulong) < json_object_array_length(val)
                                    {
                                        let mut s_5: *mut json_object = json_object_array_get_idx(
                                            val,
                                            i_9 as size_t,
                                        );
                                        let mut feedbackSong: *mut PianoSong_t = 0
                                            as *mut PianoSong_t;
                                        feedbackSong = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        ) as *mut PianoSong_t;
                                        if feedbackSong.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*feedbackSong)
                                            .title = PianoJsonStrdup(
                                            s_5,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .artist = PianoJsonStrdup(
                                            s_5,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .feedbackId = PianoJsonStrdup(
                                            s_5,
                                            b"feedbackId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .rating = (if getBoolDefault(
                                            s_5,
                                            b"isPositive\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        ) as libc::c_int != 0
                                        {
                                            PIANO_RATE_LOVE as libc::c_int
                                        } else {
                                            PIANO_RATE_BAN as libc::c_int
                                        }) as PianoSongRating_t;
                                        let mut v_0: *mut json_object = 0 as *mut json_object;
                                        (*feedbackSong)
                                            .length = (if json_object_object_get_ex(
                                            s_5,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v_0,
                                        ) != 0
                                        {
                                            json_object_get_int(v_0)
                                        } else {
                                            0 as libc::c_int
                                        }) as libc::c_uint;
                                        (*info)
                                            .feedback = PianoListAppend(
                                            if ((*info).feedback).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*info).feedback).head
                                            },
                                            &mut (*feedbackSong).head,
                                        ) as *mut PianoSong_t;
                                        i_9 += 1;
                                        i_9;
                                    }
                                }
                                i_8 = i_8.wrapping_add(1);
                                i_8;
                            }
                        }
                    }
                    11202235766349324107 => {
                        let settings: *mut PianoSettings_t = (*req).data
                            as *mut PianoSettings_t;
                        (*settings)
                            .explicitContentFilter = getBoolDefault(
                            result,
                            b"isExplicitContentFilterEnabled\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int != 0,
                        );
                        (*settings)
                            .username = PianoJsonStrdup(
                            result,
                            b"username\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    145651165234646754 => {
                        let mut reqData_5: *mut PianoRequestDataExplain_t = (*req).data
                            as *mut PianoRequestDataExplain_t;
                        let strSize: size_t = 768 as libc::c_int as size_t;
                        let mut explanations: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"explanations\0" as *const u8 as *const libc::c_char,
                            &mut explanations,
                        ) != 0
                        {
                            (*reqData_5)
                                .retExplain = malloc(
                                strSize
                                    .wrapping_mul(
                                        ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                    ),
                            ) as *mut libc::c_char;
                            strncpy(
                                (*reqData_5).retExplain,
                                b"We're playing this track because it features \0"
                                    as *const u8 as *const libc::c_char,
                                strSize,
                            );
                            let mut i_5: libc::c_int = 0 as libc::c_int;
                            while (i_5 as libc::c_ulong)
                                < json_object_array_length(explanations)
                            {
                                let mut e: *mut json_object = json_object_array_get_idx(
                                    explanations,
                                    i_5 as size_t,
                                );
                                let mut f: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    e,
                                    b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                    &mut f,
                                ) == 0)
                                {
                                    let mut s_3: *const libc::c_char = json_object_get_string(
                                        f,
                                    );
                                    PianoStrpcat((*reqData_5).retExplain, s_3, strSize);
                                    if (i_5 as libc::c_ulong)
                                        < (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b", \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else if i_5 as libc::c_ulong
                                        == (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b" and \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b".\0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    }
                                }
                                i_5 += 1;
                                i_5;
                            }
                        }
                    }
                    9240481512215375588 => {
                        let mut station_0: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*station_0).isCreator = 1 as libc::c_int as libc::c_char;
                    }
                    5908482871227205451 => {
                        let mut categories: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"categories\0" as *const u8 as *const libc::c_char,
                            &mut categories,
                        ) != 0
                        {
                            let mut i_4: libc::c_int = 0 as libc::c_int;
                            while (i_4 as libc::c_ulong)
                                < json_object_array_length(categories)
                            {
                                let mut c: *mut json_object = json_object_array_get_idx(
                                    categories,
                                    i_4 as size_t,
                                );
                                let mut tmpGenreCategory: *mut PianoGenreCategory_t = 0
                                    as *mut PianoGenreCategory_t;
                                tmpGenreCategory = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoGenreCategory_t>()
                                        as libc::c_ulong,
                                ) as *mut PianoGenreCategory_t;
                                if tmpGenreCategory.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*tmpGenreCategory)
                                    .name = PianoJsonStrdup(
                                    c,
                                    b"categoryName\0" as *const u8 as *const libc::c_char,
                                );
                                let mut stations_0: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    c,
                                    b"stations\0" as *const u8 as *const libc::c_char,
                                    &mut stations_0,
                                ) != 0
                                {
                                    let mut k_0: libc::c_int = 0 as libc::c_int;
                                    while (k_0 as libc::c_ulong)
                                        < json_object_array_length(stations_0)
                                    {
                                        let mut s_2: *mut json_object = json_object_array_get_idx(
                                            stations_0,
                                            k_0 as size_t,
                                        );
                                        let mut tmpGenre: *mut PianoGenre_t = 0
                                            as *mut PianoGenre_t;
                                        tmpGenre = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                        ) as *mut PianoGenre_t;
                                        if tmpGenre.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*tmpGenre)
                                            .name = PianoJsonStrdup(
                                            s_2,
                                            b"stationName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenre)
                                            .musicId = PianoJsonStrdup(
                                            s_2,
                                            b"stationToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenreCategory)
                                            .genres = PianoListAppend(
                                            if ((*tmpGenreCategory).genres).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*tmpGenreCategory).genres).head
                                            },
                                            &mut (*tmpGenre).head,
                                        ) as *mut PianoGenre_t;
                                        k_0 += 1;
                                        k_0;
                                    }
                                }
                                (*ph)
                                    .genreStations = PianoListAppend(
                                    if ((*ph).genreStations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).genreStations).head
                                    },
                                    &mut (*tmpGenreCategory).head,
                                ) as *mut PianoGenreCategory_t;
                                i_4 += 1;
                                i_4;
                            }
                        }
                    }
                    5260680050201874961 => {
                        let song_1: *mut PianoSong_t = (*req).data as *mut PianoSong_t;
                        (*song_1).rating = PIANO_RATE_TIRED;
                    }
                    11235674318412060590 => {
                        let mut tmpStation_0: *mut PianoStation_t = 0
                            as *mut PianoStation_t;
                        tmpStation_0 = calloc(
                            1 as libc::c_int as libc::c_ulong,
                            ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                        ) as *mut PianoStation_t;
                        if tmpStation_0.is_null() {
                            return PIANO_RET_OUT_OF_MEMORY;
                        }
                        PianoJsonParseStation(result, tmpStation_0);
                        let mut search: *mut PianoStation_t = PianoFindStationById(
                            (*ph).stations,
                            (*tmpStation_0).id,
                        );
                        if !search.is_null() {
                            (*ph)
                                .stations = PianoListDelete(
                                if ((*ph).stations).is_null() {
                                    0 as *mut PianoListHead_t
                                } else {
                                    &mut (*(*ph).stations).head
                                },
                                &mut (*search).head,
                            ) as *mut PianoStation_t;
                            PianoDestroyStation(search);
                            free(search as *mut libc::c_void);
                        }
                        (*ph)
                            .stations = PianoListAppend(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*tmpStation_0).head,
                        ) as *mut PianoStation_t;
                    }
                    10109057886293123569 => {
                        let mut reqData_4: *mut PianoRequestDataSearch_t = (*req).data
                            as *mut PianoRequestDataSearch_t;
                        let mut searchResult: *mut PianoSearchResult_t = 0
                            as *mut PianoSearchResult_t;
                        searchResult = &mut (*reqData_4).searchResult;
                        memset(
                            searchResult as *mut libc::c_void,
                            0 as libc::c_int,
                            ::std::mem::size_of::<PianoSearchResult_t>() as libc::c_ulong,
                        );
                        let mut artists: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"artists\0" as *const u8 as *const libc::c_char,
                            &mut artists,
                        ) != 0
                        {
                            let mut i_2: libc::c_int = 0 as libc::c_int;
                            while (i_2 as libc::c_ulong)
                                < json_object_array_length(artists)
                            {
                                let mut a: *mut json_object = json_object_array_get_idx(
                                    artists,
                                    i_2 as size_t,
                                );
                                let mut artist: *mut PianoArtist_t = 0
                                    as *mut PianoArtist_t;
                                artist = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                ) as *mut PianoArtist_t;
                                if artist.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*artist)
                                    .name = PianoJsonStrdup(
                                    a,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*artist)
                                    .musicId = PianoJsonStrdup(
                                    a,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .artists = PianoListAppend(
                                    if ((*searchResult).artists).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).artists).head
                                    },
                                    &mut (*artist).head,
                                ) as *mut PianoArtist_t;
                                i_2 += 1;
                                i_2;
                            }
                        }
                        let mut songs: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"songs\0" as *const u8 as *const libc::c_char,
                            &mut songs,
                        ) != 0
                        {
                            let mut i_3: libc::c_int = 0 as libc::c_int;
                            while (i_3 as libc::c_ulong)
                                < json_object_array_length(songs)
                            {
                                let mut s_1: *mut json_object = json_object_array_get_idx(
                                    songs,
                                    i_3 as size_t,
                                );
                                let mut song_0: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song_0 = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song_0.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*song_0)
                                    .title = PianoJsonStrdup(
                                    s_1,
                                    b"songName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .artist = PianoJsonStrdup(
                                    s_1,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .musicId = PianoJsonStrdup(
                                    s_1,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .songs = PianoListAppend(
                                    if ((*searchResult).songs).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).songs).head
                                    },
                                    &mut (*song_0).head,
                                ) as *mut PianoSong_t;
                                i_3 += 1;
                                i_3;
                            }
                        }
                    }
                    4983594971376015098 => {
                        let mut station: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*ph)
                            .stations = PianoListDelete(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*station).head,
                        ) as *mut PianoStation_t;
                        PianoDestroyStation(station);
                        free(station as *mut libc::c_void);
                    }
                    17372050596571538954 => {
                        let mut reqData_3: *mut PianoRequestDataRenameStation_t = (*req)
                            .data as *mut PianoRequestDataRenameStation_t;
                        free((*(*reqData_3).station).name as *mut libc::c_void);
                        (*(*reqData_3).station).name = strdup((*reqData_3).newName);
                    }
                    7297078374430259003 => {
                        let mut reqData_2: *mut PianoRequestDataRateSong_t = (*req).data
                            as *mut PianoRequestDataRateSong_t;
                        (*(*reqData_2).song).rating = (*reqData_2).rating;
                    }
                    17075014677070940716 => {
                        let mut reqData_1: *mut PianoRequestDataGetPlaylist_t = (*req)
                            .data as *mut PianoRequestDataGetPlaylist_t;
                        let mut playlist: *mut PianoSong_t = 0 as *mut PianoSong_t;
                        let mut items: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"items\0" as *const u8 as *const libc::c_char,
                            &mut items,
                        ) == 0)
                        {
                            let mut i_1: libc::c_int = 0 as libc::c_int;
                            loop {
                                if !((i_1 as libc::c_ulong)
                                    < json_object_array_length(items))
                                {
                                    current_block = 4488496028633655612;
                                    break;
                                }
                                let mut s_0: *mut json_object = json_object_array_get_idx(
                                    items,
                                    i_1 as size_t,
                                );
                                let mut song: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                if json_object_object_get_ex(
                                    s_0,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                    0 as *mut *mut json_object,
                                ) == 0
                                {
                                    free(song as *mut libc::c_void);
                                } else {
                                    static mut qualityMap: [*const libc::c_char; 4] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"lowQuality\0" as *const u8 as *const libc::c_char,
                                        b"mediumQuality\0" as *const u8 as *const libc::c_char,
                                        b"highQuality\0" as *const u8 as *const libc::c_char,
                                    ];
                                    static mut formatMap: [*const libc::c_char; 3] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"aacplus\0" as *const u8 as *const libc::c_char,
                                        b"mp3\0" as *const u8 as *const libc::c_char,
                                    ];
                                    let mut umap: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        s_0,
                                        b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                        &mut umap,
                                    ) != 0
                                    {
                                        let mut jsonEncoding: *mut json_object = 0
                                            as *mut json_object;
                                        let mut qmap: *mut json_object = 0 as *mut json_object;
                                        if json_object_object_get_ex(
                                            umap,
                                            qualityMap[(*reqData_1).quality as usize],
                                            &mut qmap,
                                        ) != 0
                                            && json_object_object_get_ex(
                                                qmap,
                                                b"encoding\0" as *const u8 as *const libc::c_char,
                                                &mut jsonEncoding,
                                            ) != 0
                                        {
                                            let mut encoding: *const libc::c_char = json_object_get_string(
                                                jsonEncoding,
                                            );
                                            let mut k: size_t = 0 as libc::c_int as size_t;
                                            while k
                                                < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                    as libc::c_ulong)
                                                    .wrapping_div(
                                                        ::std::mem::size_of::<*const libc::c_char>()
                                                            as libc::c_ulong,
                                                    )
                                            {
                                                if strcmp(formatMap[k as usize], encoding)
                                                    == 0 as libc::c_int
                                                {
                                                    (*song).audioFormat = k as PianoAudioFormat_t;
                                                    break;
                                                } else {
                                                    k = k.wrapping_add(1);
                                                    k;
                                                }
                                            }
                                            (*song)
                                                .audioUrl = PianoJsonStrdup(
                                                qmap,
                                                b"audioUrl\0" as *const u8 as *const libc::c_char,
                                            );
                                        } else {
                                            ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                            free(song as *mut libc::c_void);
                                            PianoDestroyPlaylist(playlist);
                                            current_block = 9169893888141833765;
                                            break;
                                        }
                                    }
                                    let mut v: *mut json_object = 0 as *mut json_object;
                                    (*song)
                                        .artist = PianoJsonStrdup(
                                        s_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .album = PianoJsonStrdup(
                                        s_0,
                                        b"albumName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .title = PianoJsonStrdup(
                                        s_0,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .trackToken = PianoJsonStrdup(
                                        s_0,
                                        b"trackToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .stationId = PianoJsonStrdup(
                                        s_0,
                                        b"stationId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .coverArt = PianoJsonStrdup(
                                        s_0,
                                        b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .detailUrl = PianoJsonStrdup(
                                        s_0,
                                        b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .fileGain = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackGain\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_double(v)
                                    } else {
                                        0.0f64
                                    }) as libc::c_float;
                                    (*song)
                                        .length = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackLength\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    }) as libc::c_uint;
                                    match if json_object_object_get_ex(
                                        s_0,
                                        b"songRating\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    } {
                                        1 => {
                                            (*song).rating = PIANO_RATE_LOVE;
                                        }
                                        _ => {}
                                    }
                                    playlist = PianoListAppend(
                                        if playlist.is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*playlist).head
                                        },
                                        &mut (*song).head,
                                    ) as *mut PianoSong_t;
                                }
                                i_1 += 1;
                                i_1;
                            }
                            match current_block {
                                9169893888141833765 => {}
                                _ => {
                                    (*reqData_1).retPlaylist = playlist;
                                }
                            }
                        }
                    }
                    6450597802325118133 => {
                        let mut stations: *mut json_object = 0 as *mut json_object;
                        let mut mix: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"stations\0" as *const u8 as *const libc::c_char,
                            &mut stations,
                        ) == 0)
                        {
                            let mut i: libc::c_int = 0 as libc::c_int;
                            while (i as libc::c_ulong)
                                < json_object_array_length(stations)
                            {
                                let mut tmpStation: *mut PianoStation_t = 0
                                    as *mut PianoStation_t;
                                let mut s: *mut json_object = json_object_array_get_idx(
                                    stations,
                                    i as size_t,
                                );
                                tmpStation = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                ) as *mut PianoStation_t;
                                if tmpStation.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                PianoJsonParseStation(s, tmpStation);
                                if (*tmpStation).isQuickMix != 0 {
                                    json_object_object_get_ex(
                                        s,
                                        b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                        &mut mix,
                                    );
                                }
                                (*ph)
                                    .stations = PianoListAppend(
                                    if ((*ph).stations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).stations).head
                                    },
                                    &mut (*tmpStation).head,
                                ) as *mut PianoStation_t;
                                i += 1;
                                i;
                            }
                            if !mix.is_null() {
                                let mut curStation: *mut PianoStation_t = (*ph).stations;
                                while !curStation.is_null() {
                                    let mut i_0: libc::c_int = 0 as libc::c_int;
                                    while (i_0 as libc::c_ulong) < json_object_array_length(mix)
                                    {
                                        let mut id: *mut json_object = json_object_array_get_idx(
                                            mix,
                                            i_0 as size_t,
                                        );
                                        if strcmp(json_object_get_string(id), (*curStation).id)
                                            == 0 as libc::c_int
                                        {
                                            (*curStation)
                                                .useQuickMix = 1 as libc::c_int as libc::c_char;
                                        }
                                        i_0 += 1;
                                        i_0;
                                    }
                                    curStation = (*curStation).head.next as *mut libc::c_void
                                        as *mut PianoStation_t;
                                }
                            }
                        }
                    }
                    12039483399334584727 => {
                        let mut reqData_0: *mut PianoRequestDataLogin_t = (*req).data
                            as *mut PianoRequestDataLogin_t;
                        match (*reqData_0).step as libc::c_int {
                            0 => {
                                let mut jsonTimestamp: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    result,
                                    b"syncTime\0" as *const u8 as *const libc::c_char,
                                    &mut jsonTimestamp,
                                ) == 0
                                {
                                    ret = PIANO_RET_INVALID_RESPONSE;
                                } else {
                                    let cryptedTimestamp: *const libc::c_char = json_object_get_string(
                                        jsonTimestamp,
                                    );
                                    let realTimestamp: time_t = time(0 as *mut time_t);
                                    let mut decryptedTimestamp: *mut libc::c_char = 0
                                        as *mut libc::c_char;
                                    let mut decryptedSize: size_t = 0;
                                    ret = PIANO_RET_ERR;
                                    decryptedTimestamp = PianoDecryptString(
                                        (*ph).partner.in_0,
                                        cryptedTimestamp,
                                        &mut decryptedSize,
                                    );
                                    if !decryptedTimestamp.is_null()
                                        && decryptedSize > 4 as libc::c_int as libc::c_ulong
                                    {
                                        let timestamp: libc::c_ulong = strtoul(
                                            decryptedTimestamp.offset(4 as libc::c_int as isize),
                                            0 as *mut *mut libc::c_char,
                                            0 as libc::c_int,
                                        );
                                        (*ph)
                                            .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                            as libc::c_int;
                                        ret = PIANO_RET_CONTINUE_REQUEST;
                                    }
                                    free(decryptedTimestamp as *mut libc::c_void);
                                    (*ph)
                                        .partner
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    let mut partnerId: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        result,
                                        b"partnerId\0" as *const u8 as *const libc::c_char,
                                        &mut partnerId,
                                    ) == 0
                                    {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        (*ph)
                                            .partner
                                            .id = json_object_get_int(partnerId) as libc::c_uint;
                                        (*reqData_0).step = ((*reqData_0).step).wrapping_add(1);
                                        (*reqData_0).step;
                                    }
                                }
                            }
                            1 => {
                                if !((*ph).user.listenerId).is_null() {
                                    PianoDestroyUserInfo(&mut (*ph).user);
                                }
                                (*ph)
                                    .user
                                    .listenerId = PianoJsonStrdup(
                                    result,
                                    b"userId\0" as *const u8 as *const libc::c_char,
                                );
                                (*ph)
                                    .user
                                    .authToken = PianoJsonStrdup(
                                    result,
                                    b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                );
                            }
                            _ => {}
                        }
                    }
                    10223170376184624358 => {
                        let mut reqData_8: *mut PianoRequestDataSetStationMode_t = (*req)
                            .data as *mut PianoRequestDataSetStationMode_t;
                        let mut active_0: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode_0: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode_0,
                        ) != 0
                        {
                            active_0 = json_object_get_int(activeMode_0);
                        }
                        if active_0 as libc::c_uint != (*reqData_8).id {
                            return PIANO_RET_ERR;
                        }
                    }
                    _ => {
                        let mut reqData_7: *mut PianoRequestDataGetStationModes_t = (*req)
                            .data as *mut PianoRequestDataGetStationModes_t;
                        let mut active: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode,
                        ) != 0
                        {
                            active = json_object_get_int(activeMode);
                        }
                        let mut availableModes: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"availableModes\0" as *const u8 as *const libc::c_char,
                            &mut availableModes,
                        ) != 0
                        {
                            let mut i_10: libc::c_int = 0 as libc::c_int;
                            while (i_10 as libc::c_ulong)
                                < json_object_array_length(availableModes)
                            {
                                let mut val_0: *mut json_object = json_object_array_get_idx(
                                    availableModes,
                                    i_10 as size_t,
                                );
                                let mut mode: *mut PianoStationMode_t = 0
                                    as *mut PianoStationMode_t;
                                mode = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                ) as *mut PianoStationMode_t;
                                if mode.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                let mut modeId: *mut json_object = 0 as *mut json_object;
                                if json_object_object_get_ex(
                                    val_0,
                                    b"modeId\0" as *const u8 as *const libc::c_char,
                                    &mut modeId,
                                ) != 0
                                {
                                    (*mode).id = json_object_get_int(modeId);
                                    (*mode)
                                        .name = PianoJsonStrdup(
                                        val_0,
                                        b"modeName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .description = PianoJsonStrdup(
                                        val_0,
                                        b"modeDescription\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .isAlgorithmic = getBoolDefault(
                                        val_0,
                                        b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode)
                                        .isTakeover = getBoolDefault(
                                        val_0,
                                        b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode).active = active == (*mode).id;
                                }
                                (*reqData_7)
                                    .retModes = PianoListAppend(
                                    if ((*reqData_7).retModes).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*reqData_7).retModes).head
                                    },
                                    &mut (*mode).head,
                                ) as *mut PianoStationMode_t;
                                i_10 += 1;
                                i_10;
                            }
                        }
                    }
                }
            }
            5 => {
                current_block = 14870924983410776565;
                match current_block {
                    14870924983410776565 => {}
                    4367030874028593650 => {
                        let mut reqData_6: *mut PianoRequestDataGetStationInfo_t = (*req)
                            .data as *mut PianoRequestDataGetStationInfo_t;
                        let mut info: *mut PianoStationInfo_t = 0
                            as *mut PianoStationInfo_t;
                        info = &mut (*reqData_6).info;
                        let mut music: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"music\0" as *const u8 as *const libc::c_char,
                            &mut music,
                        ) != 0
                        {
                            let mut songs_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs_0,
                            ) != 0
                            {
                                let mut i_6: libc::c_int = 0 as libc::c_int;
                                while (i_6 as libc::c_ulong)
                                    < json_object_array_length(songs_0)
                                {
                                    let mut s_4: *mut json_object = json_object_array_get_idx(
                                        songs_0,
                                        i_6 as size_t,
                                    );
                                    let mut seedSong: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                    seedSong = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    ) as *mut PianoSong_t;
                                    if seedSong.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedSong)
                                        .title = PianoJsonStrdup(
                                        s_4,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .artist = PianoJsonStrdup(
                                        s_4,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .seedId = PianoJsonStrdup(
                                        s_4,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .songSeeds = PianoListAppend(
                                        if ((*info).songSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).songSeeds).head
                                        },
                                        &mut (*seedSong).head,
                                    ) as *mut PianoSong_t;
                                    i_6 += 1;
                                    i_6;
                                }
                            }
                            let mut artists_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists_0,
                            ) != 0
                            {
                                let mut i_7: libc::c_int = 0 as libc::c_int;
                                while (i_7 as libc::c_ulong)
                                    < json_object_array_length(artists_0)
                                {
                                    let mut a_0: *mut json_object = json_object_array_get_idx(
                                        artists_0,
                                        i_7 as size_t,
                                    );
                                    let mut seedArtist: *mut PianoArtist_t = 0
                                        as *mut PianoArtist_t;
                                    seedArtist = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    ) as *mut PianoArtist_t;
                                    if seedArtist.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedArtist)
                                        .name = PianoJsonStrdup(
                                        a_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedArtist)
                                        .seedId = PianoJsonStrdup(
                                        a_0,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .artistSeeds = PianoListAppend(
                                        if ((*info).artistSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).artistSeeds).head
                                        },
                                        &mut (*seedArtist).head,
                                    ) as *mut PianoArtist_t;
                                    i_7 += 1;
                                    i_7;
                                }
                            }
                        }
                        let mut feedback: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"feedback\0" as *const u8 as *const libc::c_char,
                            &mut feedback,
                        ) != 0
                        {
                            static mut keys: [*const libc::c_char; 2] = [
                                b"thumbsUp\0" as *const u8 as *const libc::c_char,
                                b"thumbsDown\0" as *const u8 as *const libc::c_char,
                            ];
                            let mut i_8: size_t = 0 as libc::c_int as size_t;
                            while i_8
                                < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                    as libc::c_ulong)
                                    .wrapping_div(
                                        ::std::mem::size_of::<*const libc::c_char>()
                                            as libc::c_ulong,
                                    )
                            {
                                let mut val: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    feedback,
                                    keys[i_8 as usize],
                                    &mut val,
                                ) == 0)
                                {
                                    let mut i_9: libc::c_int = 0 as libc::c_int;
                                    while (i_9 as libc::c_ulong) < json_object_array_length(val)
                                    {
                                        let mut s_5: *mut json_object = json_object_array_get_idx(
                                            val,
                                            i_9 as size_t,
                                        );
                                        let mut feedbackSong: *mut PianoSong_t = 0
                                            as *mut PianoSong_t;
                                        feedbackSong = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        ) as *mut PianoSong_t;
                                        if feedbackSong.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*feedbackSong)
                                            .title = PianoJsonStrdup(
                                            s_5,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .artist = PianoJsonStrdup(
                                            s_5,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .feedbackId = PianoJsonStrdup(
                                            s_5,
                                            b"feedbackId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .rating = (if getBoolDefault(
                                            s_5,
                                            b"isPositive\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        ) as libc::c_int != 0
                                        {
                                            PIANO_RATE_LOVE as libc::c_int
                                        } else {
                                            PIANO_RATE_BAN as libc::c_int
                                        }) as PianoSongRating_t;
                                        let mut v_0: *mut json_object = 0 as *mut json_object;
                                        (*feedbackSong)
                                            .length = (if json_object_object_get_ex(
                                            s_5,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v_0,
                                        ) != 0
                                        {
                                            json_object_get_int(v_0)
                                        } else {
                                            0 as libc::c_int
                                        }) as libc::c_uint;
                                        (*info)
                                            .feedback = PianoListAppend(
                                            if ((*info).feedback).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*info).feedback).head
                                            },
                                            &mut (*feedbackSong).head,
                                        ) as *mut PianoSong_t;
                                        i_9 += 1;
                                        i_9;
                                    }
                                }
                                i_8 = i_8.wrapping_add(1);
                                i_8;
                            }
                        }
                    }
                    11202235766349324107 => {
                        let settings: *mut PianoSettings_t = (*req).data
                            as *mut PianoSettings_t;
                        (*settings)
                            .explicitContentFilter = getBoolDefault(
                            result,
                            b"isExplicitContentFilterEnabled\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int != 0,
                        );
                        (*settings)
                            .username = PianoJsonStrdup(
                            result,
                            b"username\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    145651165234646754 => {
                        let mut reqData_5: *mut PianoRequestDataExplain_t = (*req).data
                            as *mut PianoRequestDataExplain_t;
                        let strSize: size_t = 768 as libc::c_int as size_t;
                        let mut explanations: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"explanations\0" as *const u8 as *const libc::c_char,
                            &mut explanations,
                        ) != 0
                        {
                            (*reqData_5)
                                .retExplain = malloc(
                                strSize
                                    .wrapping_mul(
                                        ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                    ),
                            ) as *mut libc::c_char;
                            strncpy(
                                (*reqData_5).retExplain,
                                b"We're playing this track because it features \0"
                                    as *const u8 as *const libc::c_char,
                                strSize,
                            );
                            let mut i_5: libc::c_int = 0 as libc::c_int;
                            while (i_5 as libc::c_ulong)
                                < json_object_array_length(explanations)
                            {
                                let mut e: *mut json_object = json_object_array_get_idx(
                                    explanations,
                                    i_5 as size_t,
                                );
                                let mut f: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    e,
                                    b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                    &mut f,
                                ) == 0)
                                {
                                    let mut s_3: *const libc::c_char = json_object_get_string(
                                        f,
                                    );
                                    PianoStrpcat((*reqData_5).retExplain, s_3, strSize);
                                    if (i_5 as libc::c_ulong)
                                        < (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b", \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else if i_5 as libc::c_ulong
                                        == (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b" and \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b".\0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    }
                                }
                                i_5 += 1;
                                i_5;
                            }
                        }
                    }
                    9240481512215375588 => {
                        let mut station_0: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*station_0).isCreator = 1 as libc::c_int as libc::c_char;
                    }
                    5908482871227205451 => {
                        let mut categories: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"categories\0" as *const u8 as *const libc::c_char,
                            &mut categories,
                        ) != 0
                        {
                            let mut i_4: libc::c_int = 0 as libc::c_int;
                            while (i_4 as libc::c_ulong)
                                < json_object_array_length(categories)
                            {
                                let mut c: *mut json_object = json_object_array_get_idx(
                                    categories,
                                    i_4 as size_t,
                                );
                                let mut tmpGenreCategory: *mut PianoGenreCategory_t = 0
                                    as *mut PianoGenreCategory_t;
                                tmpGenreCategory = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoGenreCategory_t>()
                                        as libc::c_ulong,
                                ) as *mut PianoGenreCategory_t;
                                if tmpGenreCategory.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*tmpGenreCategory)
                                    .name = PianoJsonStrdup(
                                    c,
                                    b"categoryName\0" as *const u8 as *const libc::c_char,
                                );
                                let mut stations_0: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    c,
                                    b"stations\0" as *const u8 as *const libc::c_char,
                                    &mut stations_0,
                                ) != 0
                                {
                                    let mut k_0: libc::c_int = 0 as libc::c_int;
                                    while (k_0 as libc::c_ulong)
                                        < json_object_array_length(stations_0)
                                    {
                                        let mut s_2: *mut json_object = json_object_array_get_idx(
                                            stations_0,
                                            k_0 as size_t,
                                        );
                                        let mut tmpGenre: *mut PianoGenre_t = 0
                                            as *mut PianoGenre_t;
                                        tmpGenre = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                        ) as *mut PianoGenre_t;
                                        if tmpGenre.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*tmpGenre)
                                            .name = PianoJsonStrdup(
                                            s_2,
                                            b"stationName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenre)
                                            .musicId = PianoJsonStrdup(
                                            s_2,
                                            b"stationToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenreCategory)
                                            .genres = PianoListAppend(
                                            if ((*tmpGenreCategory).genres).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*tmpGenreCategory).genres).head
                                            },
                                            &mut (*tmpGenre).head,
                                        ) as *mut PianoGenre_t;
                                        k_0 += 1;
                                        k_0;
                                    }
                                }
                                (*ph)
                                    .genreStations = PianoListAppend(
                                    if ((*ph).genreStations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).genreStations).head
                                    },
                                    &mut (*tmpGenreCategory).head,
                                ) as *mut PianoGenreCategory_t;
                                i_4 += 1;
                                i_4;
                            }
                        }
                    }
                    5260680050201874961 => {
                        let song_1: *mut PianoSong_t = (*req).data as *mut PianoSong_t;
                        (*song_1).rating = PIANO_RATE_TIRED;
                    }
                    11235674318412060590 => {
                        let mut tmpStation_0: *mut PianoStation_t = 0
                            as *mut PianoStation_t;
                        tmpStation_0 = calloc(
                            1 as libc::c_int as libc::c_ulong,
                            ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                        ) as *mut PianoStation_t;
                        if tmpStation_0.is_null() {
                            return PIANO_RET_OUT_OF_MEMORY;
                        }
                        PianoJsonParseStation(result, tmpStation_0);
                        let mut search: *mut PianoStation_t = PianoFindStationById(
                            (*ph).stations,
                            (*tmpStation_0).id,
                        );
                        if !search.is_null() {
                            (*ph)
                                .stations = PianoListDelete(
                                if ((*ph).stations).is_null() {
                                    0 as *mut PianoListHead_t
                                } else {
                                    &mut (*(*ph).stations).head
                                },
                                &mut (*search).head,
                            ) as *mut PianoStation_t;
                            PianoDestroyStation(search);
                            free(search as *mut libc::c_void);
                        }
                        (*ph)
                            .stations = PianoListAppend(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*tmpStation_0).head,
                        ) as *mut PianoStation_t;
                    }
                    10109057886293123569 => {
                        let mut reqData_4: *mut PianoRequestDataSearch_t = (*req).data
                            as *mut PianoRequestDataSearch_t;
                        let mut searchResult: *mut PianoSearchResult_t = 0
                            as *mut PianoSearchResult_t;
                        searchResult = &mut (*reqData_4).searchResult;
                        memset(
                            searchResult as *mut libc::c_void,
                            0 as libc::c_int,
                            ::std::mem::size_of::<PianoSearchResult_t>() as libc::c_ulong,
                        );
                        let mut artists: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"artists\0" as *const u8 as *const libc::c_char,
                            &mut artists,
                        ) != 0
                        {
                            let mut i_2: libc::c_int = 0 as libc::c_int;
                            while (i_2 as libc::c_ulong)
                                < json_object_array_length(artists)
                            {
                                let mut a: *mut json_object = json_object_array_get_idx(
                                    artists,
                                    i_2 as size_t,
                                );
                                let mut artist: *mut PianoArtist_t = 0
                                    as *mut PianoArtist_t;
                                artist = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                ) as *mut PianoArtist_t;
                                if artist.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*artist)
                                    .name = PianoJsonStrdup(
                                    a,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*artist)
                                    .musicId = PianoJsonStrdup(
                                    a,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .artists = PianoListAppend(
                                    if ((*searchResult).artists).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).artists).head
                                    },
                                    &mut (*artist).head,
                                ) as *mut PianoArtist_t;
                                i_2 += 1;
                                i_2;
                            }
                        }
                        let mut songs: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"songs\0" as *const u8 as *const libc::c_char,
                            &mut songs,
                        ) != 0
                        {
                            let mut i_3: libc::c_int = 0 as libc::c_int;
                            while (i_3 as libc::c_ulong)
                                < json_object_array_length(songs)
                            {
                                let mut s_1: *mut json_object = json_object_array_get_idx(
                                    songs,
                                    i_3 as size_t,
                                );
                                let mut song_0: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song_0 = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song_0.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*song_0)
                                    .title = PianoJsonStrdup(
                                    s_1,
                                    b"songName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .artist = PianoJsonStrdup(
                                    s_1,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .musicId = PianoJsonStrdup(
                                    s_1,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .songs = PianoListAppend(
                                    if ((*searchResult).songs).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).songs).head
                                    },
                                    &mut (*song_0).head,
                                ) as *mut PianoSong_t;
                                i_3 += 1;
                                i_3;
                            }
                        }
                    }
                    4983594971376015098 => {
                        let mut station: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*ph)
                            .stations = PianoListDelete(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*station).head,
                        ) as *mut PianoStation_t;
                        PianoDestroyStation(station);
                        free(station as *mut libc::c_void);
                    }
                    17372050596571538954 => {
                        let mut reqData_3: *mut PianoRequestDataRenameStation_t = (*req)
                            .data as *mut PianoRequestDataRenameStation_t;
                        free((*(*reqData_3).station).name as *mut libc::c_void);
                        (*(*reqData_3).station).name = strdup((*reqData_3).newName);
                    }
                    7297078374430259003 => {
                        let mut reqData_2: *mut PianoRequestDataRateSong_t = (*req).data
                            as *mut PianoRequestDataRateSong_t;
                        (*(*reqData_2).song).rating = (*reqData_2).rating;
                    }
                    17075014677070940716 => {
                        let mut reqData_1: *mut PianoRequestDataGetPlaylist_t = (*req)
                            .data as *mut PianoRequestDataGetPlaylist_t;
                        let mut playlist: *mut PianoSong_t = 0 as *mut PianoSong_t;
                        let mut items: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"items\0" as *const u8 as *const libc::c_char,
                            &mut items,
                        ) == 0)
                        {
                            let mut i_1: libc::c_int = 0 as libc::c_int;
                            loop {
                                if !((i_1 as libc::c_ulong)
                                    < json_object_array_length(items))
                                {
                                    current_block = 4488496028633655612;
                                    break;
                                }
                                let mut s_0: *mut json_object = json_object_array_get_idx(
                                    items,
                                    i_1 as size_t,
                                );
                                let mut song: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                if json_object_object_get_ex(
                                    s_0,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                    0 as *mut *mut json_object,
                                ) == 0
                                {
                                    free(song as *mut libc::c_void);
                                } else {
                                    static mut qualityMap: [*const libc::c_char; 4] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"lowQuality\0" as *const u8 as *const libc::c_char,
                                        b"mediumQuality\0" as *const u8 as *const libc::c_char,
                                        b"highQuality\0" as *const u8 as *const libc::c_char,
                                    ];
                                    static mut formatMap: [*const libc::c_char; 3] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"aacplus\0" as *const u8 as *const libc::c_char,
                                        b"mp3\0" as *const u8 as *const libc::c_char,
                                    ];
                                    let mut umap: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        s_0,
                                        b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                        &mut umap,
                                    ) != 0
                                    {
                                        let mut jsonEncoding: *mut json_object = 0
                                            as *mut json_object;
                                        let mut qmap: *mut json_object = 0 as *mut json_object;
                                        if json_object_object_get_ex(
                                            umap,
                                            qualityMap[(*reqData_1).quality as usize],
                                            &mut qmap,
                                        ) != 0
                                            && json_object_object_get_ex(
                                                qmap,
                                                b"encoding\0" as *const u8 as *const libc::c_char,
                                                &mut jsonEncoding,
                                            ) != 0
                                        {
                                            let mut encoding: *const libc::c_char = json_object_get_string(
                                                jsonEncoding,
                                            );
                                            let mut k: size_t = 0 as libc::c_int as size_t;
                                            while k
                                                < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                    as libc::c_ulong)
                                                    .wrapping_div(
                                                        ::std::mem::size_of::<*const libc::c_char>()
                                                            as libc::c_ulong,
                                                    )
                                            {
                                                if strcmp(formatMap[k as usize], encoding)
                                                    == 0 as libc::c_int
                                                {
                                                    (*song).audioFormat = k as PianoAudioFormat_t;
                                                    break;
                                                } else {
                                                    k = k.wrapping_add(1);
                                                    k;
                                                }
                                            }
                                            (*song)
                                                .audioUrl = PianoJsonStrdup(
                                                qmap,
                                                b"audioUrl\0" as *const u8 as *const libc::c_char,
                                            );
                                        } else {
                                            ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                            free(song as *mut libc::c_void);
                                            PianoDestroyPlaylist(playlist);
                                            current_block = 9169893888141833765;
                                            break;
                                        }
                                    }
                                    let mut v: *mut json_object = 0 as *mut json_object;
                                    (*song)
                                        .artist = PianoJsonStrdup(
                                        s_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .album = PianoJsonStrdup(
                                        s_0,
                                        b"albumName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .title = PianoJsonStrdup(
                                        s_0,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .trackToken = PianoJsonStrdup(
                                        s_0,
                                        b"trackToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .stationId = PianoJsonStrdup(
                                        s_0,
                                        b"stationId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .coverArt = PianoJsonStrdup(
                                        s_0,
                                        b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .detailUrl = PianoJsonStrdup(
                                        s_0,
                                        b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .fileGain = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackGain\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_double(v)
                                    } else {
                                        0.0f64
                                    }) as libc::c_float;
                                    (*song)
                                        .length = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackLength\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    }) as libc::c_uint;
                                    match if json_object_object_get_ex(
                                        s_0,
                                        b"songRating\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    } {
                                        1 => {
                                            (*song).rating = PIANO_RATE_LOVE;
                                        }
                                        _ => {}
                                    }
                                    playlist = PianoListAppend(
                                        if playlist.is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*playlist).head
                                        },
                                        &mut (*song).head,
                                    ) as *mut PianoSong_t;
                                }
                                i_1 += 1;
                                i_1;
                            }
                            match current_block {
                                9169893888141833765 => {}
                                _ => {
                                    (*reqData_1).retPlaylist = playlist;
                                }
                            }
                        }
                    }
                    6450597802325118133 => {
                        let mut stations: *mut json_object = 0 as *mut json_object;
                        let mut mix: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"stations\0" as *const u8 as *const libc::c_char,
                            &mut stations,
                        ) == 0)
                        {
                            let mut i: libc::c_int = 0 as libc::c_int;
                            while (i as libc::c_ulong)
                                < json_object_array_length(stations)
                            {
                                let mut tmpStation: *mut PianoStation_t = 0
                                    as *mut PianoStation_t;
                                let mut s: *mut json_object = json_object_array_get_idx(
                                    stations,
                                    i as size_t,
                                );
                                tmpStation = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                ) as *mut PianoStation_t;
                                if tmpStation.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                PianoJsonParseStation(s, tmpStation);
                                if (*tmpStation).isQuickMix != 0 {
                                    json_object_object_get_ex(
                                        s,
                                        b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                        &mut mix,
                                    );
                                }
                                (*ph)
                                    .stations = PianoListAppend(
                                    if ((*ph).stations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).stations).head
                                    },
                                    &mut (*tmpStation).head,
                                ) as *mut PianoStation_t;
                                i += 1;
                                i;
                            }
                            if !mix.is_null() {
                                let mut curStation: *mut PianoStation_t = (*ph).stations;
                                while !curStation.is_null() {
                                    let mut i_0: libc::c_int = 0 as libc::c_int;
                                    while (i_0 as libc::c_ulong) < json_object_array_length(mix)
                                    {
                                        let mut id: *mut json_object = json_object_array_get_idx(
                                            mix,
                                            i_0 as size_t,
                                        );
                                        if strcmp(json_object_get_string(id), (*curStation).id)
                                            == 0 as libc::c_int
                                        {
                                            (*curStation)
                                                .useQuickMix = 1 as libc::c_int as libc::c_char;
                                        }
                                        i_0 += 1;
                                        i_0;
                                    }
                                    curStation = (*curStation).head.next as *mut libc::c_void
                                        as *mut PianoStation_t;
                                }
                            }
                        }
                    }
                    12039483399334584727 => {
                        let mut reqData_0: *mut PianoRequestDataLogin_t = (*req).data
                            as *mut PianoRequestDataLogin_t;
                        match (*reqData_0).step as libc::c_int {
                            0 => {
                                let mut jsonTimestamp: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    result,
                                    b"syncTime\0" as *const u8 as *const libc::c_char,
                                    &mut jsonTimestamp,
                                ) == 0
                                {
                                    ret = PIANO_RET_INVALID_RESPONSE;
                                } else {
                                    let cryptedTimestamp: *const libc::c_char = json_object_get_string(
                                        jsonTimestamp,
                                    );
                                    let realTimestamp: time_t = time(0 as *mut time_t);
                                    let mut decryptedTimestamp: *mut libc::c_char = 0
                                        as *mut libc::c_char;
                                    let mut decryptedSize: size_t = 0;
                                    ret = PIANO_RET_ERR;
                                    decryptedTimestamp = PianoDecryptString(
                                        (*ph).partner.in_0,
                                        cryptedTimestamp,
                                        &mut decryptedSize,
                                    );
                                    if !decryptedTimestamp.is_null()
                                        && decryptedSize > 4 as libc::c_int as libc::c_ulong
                                    {
                                        let timestamp: libc::c_ulong = strtoul(
                                            decryptedTimestamp.offset(4 as libc::c_int as isize),
                                            0 as *mut *mut libc::c_char,
                                            0 as libc::c_int,
                                        );
                                        (*ph)
                                            .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                            as libc::c_int;
                                        ret = PIANO_RET_CONTINUE_REQUEST;
                                    }
                                    free(decryptedTimestamp as *mut libc::c_void);
                                    (*ph)
                                        .partner
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    let mut partnerId: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        result,
                                        b"partnerId\0" as *const u8 as *const libc::c_char,
                                        &mut partnerId,
                                    ) == 0
                                    {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        (*ph)
                                            .partner
                                            .id = json_object_get_int(partnerId) as libc::c_uint;
                                        (*reqData_0).step = ((*reqData_0).step).wrapping_add(1);
                                        (*reqData_0).step;
                                    }
                                }
                            }
                            1 => {
                                if !((*ph).user.listenerId).is_null() {
                                    PianoDestroyUserInfo(&mut (*ph).user);
                                }
                                (*ph)
                                    .user
                                    .listenerId = PianoJsonStrdup(
                                    result,
                                    b"userId\0" as *const u8 as *const libc::c_char,
                                );
                                (*ph)
                                    .user
                                    .authToken = PianoJsonStrdup(
                                    result,
                                    b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                );
                            }
                            _ => {}
                        }
                    }
                    10223170376184624358 => {
                        let mut reqData_8: *mut PianoRequestDataSetStationMode_t = (*req)
                            .data as *mut PianoRequestDataSetStationMode_t;
                        let mut active_0: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode_0: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode_0,
                        ) != 0
                        {
                            active_0 = json_object_get_int(activeMode_0);
                        }
                        if active_0 as libc::c_uint != (*reqData_8).id {
                            return PIANO_RET_ERR;
                        }
                    }
                    _ => {
                        let mut reqData_7: *mut PianoRequestDataGetStationModes_t = (*req)
                            .data as *mut PianoRequestDataGetStationModes_t;
                        let mut active: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode,
                        ) != 0
                        {
                            active = json_object_get_int(activeMode);
                        }
                        let mut availableModes: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"availableModes\0" as *const u8 as *const libc::c_char,
                            &mut availableModes,
                        ) != 0
                        {
                            let mut i_10: libc::c_int = 0 as libc::c_int;
                            while (i_10 as libc::c_ulong)
                                < json_object_array_length(availableModes)
                            {
                                let mut val_0: *mut json_object = json_object_array_get_idx(
                                    availableModes,
                                    i_10 as size_t,
                                );
                                let mut mode: *mut PianoStationMode_t = 0
                                    as *mut PianoStationMode_t;
                                mode = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                ) as *mut PianoStationMode_t;
                                if mode.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                let mut modeId: *mut json_object = 0 as *mut json_object;
                                if json_object_object_get_ex(
                                    val_0,
                                    b"modeId\0" as *const u8 as *const libc::c_char,
                                    &mut modeId,
                                ) != 0
                                {
                                    (*mode).id = json_object_get_int(modeId);
                                    (*mode)
                                        .name = PianoJsonStrdup(
                                        val_0,
                                        b"modeName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .description = PianoJsonStrdup(
                                        val_0,
                                        b"modeDescription\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .isAlgorithmic = getBoolDefault(
                                        val_0,
                                        b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode)
                                        .isTakeover = getBoolDefault(
                                        val_0,
                                        b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode).active = active == (*mode).id;
                                }
                                (*reqData_7)
                                    .retModes = PianoListAppend(
                                    if ((*reqData_7).retModes).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*reqData_7).retModes).head
                                    },
                                    &mut (*mode).head,
                                ) as *mut PianoStationMode_t;
                                i_10 += 1;
                                i_10;
                            }
                        }
                    }
                }
            }
            7 => {
                current_block = 17372050596571538954;
                match current_block {
                    14870924983410776565 => {}
                    4367030874028593650 => {
                        let mut reqData_6: *mut PianoRequestDataGetStationInfo_t = (*req)
                            .data as *mut PianoRequestDataGetStationInfo_t;
                        let mut info: *mut PianoStationInfo_t = 0
                            as *mut PianoStationInfo_t;
                        info = &mut (*reqData_6).info;
                        let mut music: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"music\0" as *const u8 as *const libc::c_char,
                            &mut music,
                        ) != 0
                        {
                            let mut songs_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs_0,
                            ) != 0
                            {
                                let mut i_6: libc::c_int = 0 as libc::c_int;
                                while (i_6 as libc::c_ulong)
                                    < json_object_array_length(songs_0)
                                {
                                    let mut s_4: *mut json_object = json_object_array_get_idx(
                                        songs_0,
                                        i_6 as size_t,
                                    );
                                    let mut seedSong: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                    seedSong = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    ) as *mut PianoSong_t;
                                    if seedSong.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedSong)
                                        .title = PianoJsonStrdup(
                                        s_4,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .artist = PianoJsonStrdup(
                                        s_4,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .seedId = PianoJsonStrdup(
                                        s_4,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .songSeeds = PianoListAppend(
                                        if ((*info).songSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).songSeeds).head
                                        },
                                        &mut (*seedSong).head,
                                    ) as *mut PianoSong_t;
                                    i_6 += 1;
                                    i_6;
                                }
                            }
                            let mut artists_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists_0,
                            ) != 0
                            {
                                let mut i_7: libc::c_int = 0 as libc::c_int;
                                while (i_7 as libc::c_ulong)
                                    < json_object_array_length(artists_0)
                                {
                                    let mut a_0: *mut json_object = json_object_array_get_idx(
                                        artists_0,
                                        i_7 as size_t,
                                    );
                                    let mut seedArtist: *mut PianoArtist_t = 0
                                        as *mut PianoArtist_t;
                                    seedArtist = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    ) as *mut PianoArtist_t;
                                    if seedArtist.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedArtist)
                                        .name = PianoJsonStrdup(
                                        a_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedArtist)
                                        .seedId = PianoJsonStrdup(
                                        a_0,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .artistSeeds = PianoListAppend(
                                        if ((*info).artistSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).artistSeeds).head
                                        },
                                        &mut (*seedArtist).head,
                                    ) as *mut PianoArtist_t;
                                    i_7 += 1;
                                    i_7;
                                }
                            }
                        }
                        let mut feedback: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"feedback\0" as *const u8 as *const libc::c_char,
                            &mut feedback,
                        ) != 0
                        {
                            static mut keys: [*const libc::c_char; 2] = [
                                b"thumbsUp\0" as *const u8 as *const libc::c_char,
                                b"thumbsDown\0" as *const u8 as *const libc::c_char,
                            ];
                            let mut i_8: size_t = 0 as libc::c_int as size_t;
                            while i_8
                                < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                    as libc::c_ulong)
                                    .wrapping_div(
                                        ::std::mem::size_of::<*const libc::c_char>()
                                            as libc::c_ulong,
                                    )
                            {
                                let mut val: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    feedback,
                                    keys[i_8 as usize],
                                    &mut val,
                                ) == 0)
                                {
                                    let mut i_9: libc::c_int = 0 as libc::c_int;
                                    while (i_9 as libc::c_ulong) < json_object_array_length(val)
                                    {
                                        let mut s_5: *mut json_object = json_object_array_get_idx(
                                            val,
                                            i_9 as size_t,
                                        );
                                        let mut feedbackSong: *mut PianoSong_t = 0
                                            as *mut PianoSong_t;
                                        feedbackSong = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        ) as *mut PianoSong_t;
                                        if feedbackSong.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*feedbackSong)
                                            .title = PianoJsonStrdup(
                                            s_5,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .artist = PianoJsonStrdup(
                                            s_5,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .feedbackId = PianoJsonStrdup(
                                            s_5,
                                            b"feedbackId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .rating = (if getBoolDefault(
                                            s_5,
                                            b"isPositive\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        ) as libc::c_int != 0
                                        {
                                            PIANO_RATE_LOVE as libc::c_int
                                        } else {
                                            PIANO_RATE_BAN as libc::c_int
                                        }) as PianoSongRating_t;
                                        let mut v_0: *mut json_object = 0 as *mut json_object;
                                        (*feedbackSong)
                                            .length = (if json_object_object_get_ex(
                                            s_5,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v_0,
                                        ) != 0
                                        {
                                            json_object_get_int(v_0)
                                        } else {
                                            0 as libc::c_int
                                        }) as libc::c_uint;
                                        (*info)
                                            .feedback = PianoListAppend(
                                            if ((*info).feedback).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*info).feedback).head
                                            },
                                            &mut (*feedbackSong).head,
                                        ) as *mut PianoSong_t;
                                        i_9 += 1;
                                        i_9;
                                    }
                                }
                                i_8 = i_8.wrapping_add(1);
                                i_8;
                            }
                        }
                    }
                    11202235766349324107 => {
                        let settings: *mut PianoSettings_t = (*req).data
                            as *mut PianoSettings_t;
                        (*settings)
                            .explicitContentFilter = getBoolDefault(
                            result,
                            b"isExplicitContentFilterEnabled\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int != 0,
                        );
                        (*settings)
                            .username = PianoJsonStrdup(
                            result,
                            b"username\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    145651165234646754 => {
                        let mut reqData_5: *mut PianoRequestDataExplain_t = (*req).data
                            as *mut PianoRequestDataExplain_t;
                        let strSize: size_t = 768 as libc::c_int as size_t;
                        let mut explanations: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"explanations\0" as *const u8 as *const libc::c_char,
                            &mut explanations,
                        ) != 0
                        {
                            (*reqData_5)
                                .retExplain = malloc(
                                strSize
                                    .wrapping_mul(
                                        ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                    ),
                            ) as *mut libc::c_char;
                            strncpy(
                                (*reqData_5).retExplain,
                                b"We're playing this track because it features \0"
                                    as *const u8 as *const libc::c_char,
                                strSize,
                            );
                            let mut i_5: libc::c_int = 0 as libc::c_int;
                            while (i_5 as libc::c_ulong)
                                < json_object_array_length(explanations)
                            {
                                let mut e: *mut json_object = json_object_array_get_idx(
                                    explanations,
                                    i_5 as size_t,
                                );
                                let mut f: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    e,
                                    b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                    &mut f,
                                ) == 0)
                                {
                                    let mut s_3: *const libc::c_char = json_object_get_string(
                                        f,
                                    );
                                    PianoStrpcat((*reqData_5).retExplain, s_3, strSize);
                                    if (i_5 as libc::c_ulong)
                                        < (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b", \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else if i_5 as libc::c_ulong
                                        == (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b" and \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b".\0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    }
                                }
                                i_5 += 1;
                                i_5;
                            }
                        }
                    }
                    9240481512215375588 => {
                        let mut station_0: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*station_0).isCreator = 1 as libc::c_int as libc::c_char;
                    }
                    5908482871227205451 => {
                        let mut categories: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"categories\0" as *const u8 as *const libc::c_char,
                            &mut categories,
                        ) != 0
                        {
                            let mut i_4: libc::c_int = 0 as libc::c_int;
                            while (i_4 as libc::c_ulong)
                                < json_object_array_length(categories)
                            {
                                let mut c: *mut json_object = json_object_array_get_idx(
                                    categories,
                                    i_4 as size_t,
                                );
                                let mut tmpGenreCategory: *mut PianoGenreCategory_t = 0
                                    as *mut PianoGenreCategory_t;
                                tmpGenreCategory = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoGenreCategory_t>()
                                        as libc::c_ulong,
                                ) as *mut PianoGenreCategory_t;
                                if tmpGenreCategory.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*tmpGenreCategory)
                                    .name = PianoJsonStrdup(
                                    c,
                                    b"categoryName\0" as *const u8 as *const libc::c_char,
                                );
                                let mut stations_0: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    c,
                                    b"stations\0" as *const u8 as *const libc::c_char,
                                    &mut stations_0,
                                ) != 0
                                {
                                    let mut k_0: libc::c_int = 0 as libc::c_int;
                                    while (k_0 as libc::c_ulong)
                                        < json_object_array_length(stations_0)
                                    {
                                        let mut s_2: *mut json_object = json_object_array_get_idx(
                                            stations_0,
                                            k_0 as size_t,
                                        );
                                        let mut tmpGenre: *mut PianoGenre_t = 0
                                            as *mut PianoGenre_t;
                                        tmpGenre = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                        ) as *mut PianoGenre_t;
                                        if tmpGenre.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*tmpGenre)
                                            .name = PianoJsonStrdup(
                                            s_2,
                                            b"stationName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenre)
                                            .musicId = PianoJsonStrdup(
                                            s_2,
                                            b"stationToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenreCategory)
                                            .genres = PianoListAppend(
                                            if ((*tmpGenreCategory).genres).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*tmpGenreCategory).genres).head
                                            },
                                            &mut (*tmpGenre).head,
                                        ) as *mut PianoGenre_t;
                                        k_0 += 1;
                                        k_0;
                                    }
                                }
                                (*ph)
                                    .genreStations = PianoListAppend(
                                    if ((*ph).genreStations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).genreStations).head
                                    },
                                    &mut (*tmpGenreCategory).head,
                                ) as *mut PianoGenreCategory_t;
                                i_4 += 1;
                                i_4;
                            }
                        }
                    }
                    5260680050201874961 => {
                        let song_1: *mut PianoSong_t = (*req).data as *mut PianoSong_t;
                        (*song_1).rating = PIANO_RATE_TIRED;
                    }
                    11235674318412060590 => {
                        let mut tmpStation_0: *mut PianoStation_t = 0
                            as *mut PianoStation_t;
                        tmpStation_0 = calloc(
                            1 as libc::c_int as libc::c_ulong,
                            ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                        ) as *mut PianoStation_t;
                        if tmpStation_0.is_null() {
                            return PIANO_RET_OUT_OF_MEMORY;
                        }
                        PianoJsonParseStation(result, tmpStation_0);
                        let mut search: *mut PianoStation_t = PianoFindStationById(
                            (*ph).stations,
                            (*tmpStation_0).id,
                        );
                        if !search.is_null() {
                            (*ph)
                                .stations = PianoListDelete(
                                if ((*ph).stations).is_null() {
                                    0 as *mut PianoListHead_t
                                } else {
                                    &mut (*(*ph).stations).head
                                },
                                &mut (*search).head,
                            ) as *mut PianoStation_t;
                            PianoDestroyStation(search);
                            free(search as *mut libc::c_void);
                        }
                        (*ph)
                            .stations = PianoListAppend(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*tmpStation_0).head,
                        ) as *mut PianoStation_t;
                    }
                    10109057886293123569 => {
                        let mut reqData_4: *mut PianoRequestDataSearch_t = (*req).data
                            as *mut PianoRequestDataSearch_t;
                        let mut searchResult: *mut PianoSearchResult_t = 0
                            as *mut PianoSearchResult_t;
                        searchResult = &mut (*reqData_4).searchResult;
                        memset(
                            searchResult as *mut libc::c_void,
                            0 as libc::c_int,
                            ::std::mem::size_of::<PianoSearchResult_t>() as libc::c_ulong,
                        );
                        let mut artists: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"artists\0" as *const u8 as *const libc::c_char,
                            &mut artists,
                        ) != 0
                        {
                            let mut i_2: libc::c_int = 0 as libc::c_int;
                            while (i_2 as libc::c_ulong)
                                < json_object_array_length(artists)
                            {
                                let mut a: *mut json_object = json_object_array_get_idx(
                                    artists,
                                    i_2 as size_t,
                                );
                                let mut artist: *mut PianoArtist_t = 0
                                    as *mut PianoArtist_t;
                                artist = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                ) as *mut PianoArtist_t;
                                if artist.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*artist)
                                    .name = PianoJsonStrdup(
                                    a,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*artist)
                                    .musicId = PianoJsonStrdup(
                                    a,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .artists = PianoListAppend(
                                    if ((*searchResult).artists).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).artists).head
                                    },
                                    &mut (*artist).head,
                                ) as *mut PianoArtist_t;
                                i_2 += 1;
                                i_2;
                            }
                        }
                        let mut songs: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"songs\0" as *const u8 as *const libc::c_char,
                            &mut songs,
                        ) != 0
                        {
                            let mut i_3: libc::c_int = 0 as libc::c_int;
                            while (i_3 as libc::c_ulong)
                                < json_object_array_length(songs)
                            {
                                let mut s_1: *mut json_object = json_object_array_get_idx(
                                    songs,
                                    i_3 as size_t,
                                );
                                let mut song_0: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song_0 = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song_0.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*song_0)
                                    .title = PianoJsonStrdup(
                                    s_1,
                                    b"songName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .artist = PianoJsonStrdup(
                                    s_1,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .musicId = PianoJsonStrdup(
                                    s_1,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .songs = PianoListAppend(
                                    if ((*searchResult).songs).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).songs).head
                                    },
                                    &mut (*song_0).head,
                                ) as *mut PianoSong_t;
                                i_3 += 1;
                                i_3;
                            }
                        }
                    }
                    4983594971376015098 => {
                        let mut station: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*ph)
                            .stations = PianoListDelete(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*station).head,
                        ) as *mut PianoStation_t;
                        PianoDestroyStation(station);
                        free(station as *mut libc::c_void);
                    }
                    17372050596571538954 => {
                        let mut reqData_3: *mut PianoRequestDataRenameStation_t = (*req)
                            .data as *mut PianoRequestDataRenameStation_t;
                        free((*(*reqData_3).station).name as *mut libc::c_void);
                        (*(*reqData_3).station).name = strdup((*reqData_3).newName);
                    }
                    7297078374430259003 => {
                        let mut reqData_2: *mut PianoRequestDataRateSong_t = (*req).data
                            as *mut PianoRequestDataRateSong_t;
                        (*(*reqData_2).song).rating = (*reqData_2).rating;
                    }
                    17075014677070940716 => {
                        let mut reqData_1: *mut PianoRequestDataGetPlaylist_t = (*req)
                            .data as *mut PianoRequestDataGetPlaylist_t;
                        let mut playlist: *mut PianoSong_t = 0 as *mut PianoSong_t;
                        let mut items: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"items\0" as *const u8 as *const libc::c_char,
                            &mut items,
                        ) == 0)
                        {
                            let mut i_1: libc::c_int = 0 as libc::c_int;
                            loop {
                                if !((i_1 as libc::c_ulong)
                                    < json_object_array_length(items))
                                {
                                    current_block = 4488496028633655612;
                                    break;
                                }
                                let mut s_0: *mut json_object = json_object_array_get_idx(
                                    items,
                                    i_1 as size_t,
                                );
                                let mut song: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                if json_object_object_get_ex(
                                    s_0,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                    0 as *mut *mut json_object,
                                ) == 0
                                {
                                    free(song as *mut libc::c_void);
                                } else {
                                    static mut qualityMap: [*const libc::c_char; 4] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"lowQuality\0" as *const u8 as *const libc::c_char,
                                        b"mediumQuality\0" as *const u8 as *const libc::c_char,
                                        b"highQuality\0" as *const u8 as *const libc::c_char,
                                    ];
                                    static mut formatMap: [*const libc::c_char; 3] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"aacplus\0" as *const u8 as *const libc::c_char,
                                        b"mp3\0" as *const u8 as *const libc::c_char,
                                    ];
                                    let mut umap: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        s_0,
                                        b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                        &mut umap,
                                    ) != 0
                                    {
                                        let mut jsonEncoding: *mut json_object = 0
                                            as *mut json_object;
                                        let mut qmap: *mut json_object = 0 as *mut json_object;
                                        if json_object_object_get_ex(
                                            umap,
                                            qualityMap[(*reqData_1).quality as usize],
                                            &mut qmap,
                                        ) != 0
                                            && json_object_object_get_ex(
                                                qmap,
                                                b"encoding\0" as *const u8 as *const libc::c_char,
                                                &mut jsonEncoding,
                                            ) != 0
                                        {
                                            let mut encoding: *const libc::c_char = json_object_get_string(
                                                jsonEncoding,
                                            );
                                            let mut k: size_t = 0 as libc::c_int as size_t;
                                            while k
                                                < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                    as libc::c_ulong)
                                                    .wrapping_div(
                                                        ::std::mem::size_of::<*const libc::c_char>()
                                                            as libc::c_ulong,
                                                    )
                                            {
                                                if strcmp(formatMap[k as usize], encoding)
                                                    == 0 as libc::c_int
                                                {
                                                    (*song).audioFormat = k as PianoAudioFormat_t;
                                                    break;
                                                } else {
                                                    k = k.wrapping_add(1);
                                                    k;
                                                }
                                            }
                                            (*song)
                                                .audioUrl = PianoJsonStrdup(
                                                qmap,
                                                b"audioUrl\0" as *const u8 as *const libc::c_char,
                                            );
                                        } else {
                                            ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                            free(song as *mut libc::c_void);
                                            PianoDestroyPlaylist(playlist);
                                            current_block = 9169893888141833765;
                                            break;
                                        }
                                    }
                                    let mut v: *mut json_object = 0 as *mut json_object;
                                    (*song)
                                        .artist = PianoJsonStrdup(
                                        s_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .album = PianoJsonStrdup(
                                        s_0,
                                        b"albumName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .title = PianoJsonStrdup(
                                        s_0,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .trackToken = PianoJsonStrdup(
                                        s_0,
                                        b"trackToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .stationId = PianoJsonStrdup(
                                        s_0,
                                        b"stationId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .coverArt = PianoJsonStrdup(
                                        s_0,
                                        b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .detailUrl = PianoJsonStrdup(
                                        s_0,
                                        b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .fileGain = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackGain\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_double(v)
                                    } else {
                                        0.0f64
                                    }) as libc::c_float;
                                    (*song)
                                        .length = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackLength\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    }) as libc::c_uint;
                                    match if json_object_object_get_ex(
                                        s_0,
                                        b"songRating\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    } {
                                        1 => {
                                            (*song).rating = PIANO_RATE_LOVE;
                                        }
                                        _ => {}
                                    }
                                    playlist = PianoListAppend(
                                        if playlist.is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*playlist).head
                                        },
                                        &mut (*song).head,
                                    ) as *mut PianoSong_t;
                                }
                                i_1 += 1;
                                i_1;
                            }
                            match current_block {
                                9169893888141833765 => {}
                                _ => {
                                    (*reqData_1).retPlaylist = playlist;
                                }
                            }
                        }
                    }
                    6450597802325118133 => {
                        let mut stations: *mut json_object = 0 as *mut json_object;
                        let mut mix: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"stations\0" as *const u8 as *const libc::c_char,
                            &mut stations,
                        ) == 0)
                        {
                            let mut i: libc::c_int = 0 as libc::c_int;
                            while (i as libc::c_ulong)
                                < json_object_array_length(stations)
                            {
                                let mut tmpStation: *mut PianoStation_t = 0
                                    as *mut PianoStation_t;
                                let mut s: *mut json_object = json_object_array_get_idx(
                                    stations,
                                    i as size_t,
                                );
                                tmpStation = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                ) as *mut PianoStation_t;
                                if tmpStation.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                PianoJsonParseStation(s, tmpStation);
                                if (*tmpStation).isQuickMix != 0 {
                                    json_object_object_get_ex(
                                        s,
                                        b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                        &mut mix,
                                    );
                                }
                                (*ph)
                                    .stations = PianoListAppend(
                                    if ((*ph).stations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).stations).head
                                    },
                                    &mut (*tmpStation).head,
                                ) as *mut PianoStation_t;
                                i += 1;
                                i;
                            }
                            if !mix.is_null() {
                                let mut curStation: *mut PianoStation_t = (*ph).stations;
                                while !curStation.is_null() {
                                    let mut i_0: libc::c_int = 0 as libc::c_int;
                                    while (i_0 as libc::c_ulong) < json_object_array_length(mix)
                                    {
                                        let mut id: *mut json_object = json_object_array_get_idx(
                                            mix,
                                            i_0 as size_t,
                                        );
                                        if strcmp(json_object_get_string(id), (*curStation).id)
                                            == 0 as libc::c_int
                                        {
                                            (*curStation)
                                                .useQuickMix = 1 as libc::c_int as libc::c_char;
                                        }
                                        i_0 += 1;
                                        i_0;
                                    }
                                    curStation = (*curStation).head.next as *mut libc::c_void
                                        as *mut PianoStation_t;
                                }
                            }
                        }
                    }
                    12039483399334584727 => {
                        let mut reqData_0: *mut PianoRequestDataLogin_t = (*req).data
                            as *mut PianoRequestDataLogin_t;
                        match (*reqData_0).step as libc::c_int {
                            0 => {
                                let mut jsonTimestamp: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    result,
                                    b"syncTime\0" as *const u8 as *const libc::c_char,
                                    &mut jsonTimestamp,
                                ) == 0
                                {
                                    ret = PIANO_RET_INVALID_RESPONSE;
                                } else {
                                    let cryptedTimestamp: *const libc::c_char = json_object_get_string(
                                        jsonTimestamp,
                                    );
                                    let realTimestamp: time_t = time(0 as *mut time_t);
                                    let mut decryptedTimestamp: *mut libc::c_char = 0
                                        as *mut libc::c_char;
                                    let mut decryptedSize: size_t = 0;
                                    ret = PIANO_RET_ERR;
                                    decryptedTimestamp = PianoDecryptString(
                                        (*ph).partner.in_0,
                                        cryptedTimestamp,
                                        &mut decryptedSize,
                                    );
                                    if !decryptedTimestamp.is_null()
                                        && decryptedSize > 4 as libc::c_int as libc::c_ulong
                                    {
                                        let timestamp: libc::c_ulong = strtoul(
                                            decryptedTimestamp.offset(4 as libc::c_int as isize),
                                            0 as *mut *mut libc::c_char,
                                            0 as libc::c_int,
                                        );
                                        (*ph)
                                            .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                            as libc::c_int;
                                        ret = PIANO_RET_CONTINUE_REQUEST;
                                    }
                                    free(decryptedTimestamp as *mut libc::c_void);
                                    (*ph)
                                        .partner
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    let mut partnerId: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        result,
                                        b"partnerId\0" as *const u8 as *const libc::c_char,
                                        &mut partnerId,
                                    ) == 0
                                    {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        (*ph)
                                            .partner
                                            .id = json_object_get_int(partnerId) as libc::c_uint;
                                        (*reqData_0).step = ((*reqData_0).step).wrapping_add(1);
                                        (*reqData_0).step;
                                    }
                                }
                            }
                            1 => {
                                if !((*ph).user.listenerId).is_null() {
                                    PianoDestroyUserInfo(&mut (*ph).user);
                                }
                                (*ph)
                                    .user
                                    .listenerId = PianoJsonStrdup(
                                    result,
                                    b"userId\0" as *const u8 as *const libc::c_char,
                                );
                                (*ph)
                                    .user
                                    .authToken = PianoJsonStrdup(
                                    result,
                                    b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                );
                            }
                            _ => {}
                        }
                    }
                    10223170376184624358 => {
                        let mut reqData_8: *mut PianoRequestDataSetStationMode_t = (*req)
                            .data as *mut PianoRequestDataSetStationMode_t;
                        let mut active_0: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode_0: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode_0,
                        ) != 0
                        {
                            active_0 = json_object_get_int(activeMode_0);
                        }
                        if active_0 as libc::c_uint != (*reqData_8).id {
                            return PIANO_RET_ERR;
                        }
                    }
                    _ => {
                        let mut reqData_7: *mut PianoRequestDataGetStationModes_t = (*req)
                            .data as *mut PianoRequestDataGetStationModes_t;
                        let mut active: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode,
                        ) != 0
                        {
                            active = json_object_get_int(activeMode);
                        }
                        let mut availableModes: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"availableModes\0" as *const u8 as *const libc::c_char,
                            &mut availableModes,
                        ) != 0
                        {
                            let mut i_10: libc::c_int = 0 as libc::c_int;
                            while (i_10 as libc::c_ulong)
                                < json_object_array_length(availableModes)
                            {
                                let mut val_0: *mut json_object = json_object_array_get_idx(
                                    availableModes,
                                    i_10 as size_t,
                                );
                                let mut mode: *mut PianoStationMode_t = 0
                                    as *mut PianoStationMode_t;
                                mode = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                ) as *mut PianoStationMode_t;
                                if mode.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                let mut modeId: *mut json_object = 0 as *mut json_object;
                                if json_object_object_get_ex(
                                    val_0,
                                    b"modeId\0" as *const u8 as *const libc::c_char,
                                    &mut modeId,
                                ) != 0
                                {
                                    (*mode).id = json_object_get_int(modeId);
                                    (*mode)
                                        .name = PianoJsonStrdup(
                                        val_0,
                                        b"modeName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .description = PianoJsonStrdup(
                                        val_0,
                                        b"modeDescription\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .isAlgorithmic = getBoolDefault(
                                        val_0,
                                        b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode)
                                        .isTakeover = getBoolDefault(
                                        val_0,
                                        b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode).active = active == (*mode).id;
                                }
                                (*reqData_7)
                                    .retModes = PianoListAppend(
                                    if ((*reqData_7).retModes).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*reqData_7).retModes).head
                                    },
                                    &mut (*mode).head,
                                ) as *mut PianoStationMode_t;
                                i_10 += 1;
                                i_10;
                            }
                        }
                    }
                }
            }
            8 => {
                current_block = 4983594971376015098;
                match current_block {
                    14870924983410776565 => {}
                    4367030874028593650 => {
                        let mut reqData_6: *mut PianoRequestDataGetStationInfo_t = (*req)
                            .data as *mut PianoRequestDataGetStationInfo_t;
                        let mut info: *mut PianoStationInfo_t = 0
                            as *mut PianoStationInfo_t;
                        info = &mut (*reqData_6).info;
                        let mut music: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"music\0" as *const u8 as *const libc::c_char,
                            &mut music,
                        ) != 0
                        {
                            let mut songs_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs_0,
                            ) != 0
                            {
                                let mut i_6: libc::c_int = 0 as libc::c_int;
                                while (i_6 as libc::c_ulong)
                                    < json_object_array_length(songs_0)
                                {
                                    let mut s_4: *mut json_object = json_object_array_get_idx(
                                        songs_0,
                                        i_6 as size_t,
                                    );
                                    let mut seedSong: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                    seedSong = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    ) as *mut PianoSong_t;
                                    if seedSong.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedSong)
                                        .title = PianoJsonStrdup(
                                        s_4,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .artist = PianoJsonStrdup(
                                        s_4,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .seedId = PianoJsonStrdup(
                                        s_4,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .songSeeds = PianoListAppend(
                                        if ((*info).songSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).songSeeds).head
                                        },
                                        &mut (*seedSong).head,
                                    ) as *mut PianoSong_t;
                                    i_6 += 1;
                                    i_6;
                                }
                            }
                            let mut artists_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists_0,
                            ) != 0
                            {
                                let mut i_7: libc::c_int = 0 as libc::c_int;
                                while (i_7 as libc::c_ulong)
                                    < json_object_array_length(artists_0)
                                {
                                    let mut a_0: *mut json_object = json_object_array_get_idx(
                                        artists_0,
                                        i_7 as size_t,
                                    );
                                    let mut seedArtist: *mut PianoArtist_t = 0
                                        as *mut PianoArtist_t;
                                    seedArtist = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    ) as *mut PianoArtist_t;
                                    if seedArtist.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedArtist)
                                        .name = PianoJsonStrdup(
                                        a_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedArtist)
                                        .seedId = PianoJsonStrdup(
                                        a_0,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .artistSeeds = PianoListAppend(
                                        if ((*info).artistSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).artistSeeds).head
                                        },
                                        &mut (*seedArtist).head,
                                    ) as *mut PianoArtist_t;
                                    i_7 += 1;
                                    i_7;
                                }
                            }
                        }
                        let mut feedback: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"feedback\0" as *const u8 as *const libc::c_char,
                            &mut feedback,
                        ) != 0
                        {
                            static mut keys: [*const libc::c_char; 2] = [
                                b"thumbsUp\0" as *const u8 as *const libc::c_char,
                                b"thumbsDown\0" as *const u8 as *const libc::c_char,
                            ];
                            let mut i_8: size_t = 0 as libc::c_int as size_t;
                            while i_8
                                < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                    as libc::c_ulong)
                                    .wrapping_div(
                                        ::std::mem::size_of::<*const libc::c_char>()
                                            as libc::c_ulong,
                                    )
                            {
                                let mut val: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    feedback,
                                    keys[i_8 as usize],
                                    &mut val,
                                ) == 0)
                                {
                                    let mut i_9: libc::c_int = 0 as libc::c_int;
                                    while (i_9 as libc::c_ulong) < json_object_array_length(val)
                                    {
                                        let mut s_5: *mut json_object = json_object_array_get_idx(
                                            val,
                                            i_9 as size_t,
                                        );
                                        let mut feedbackSong: *mut PianoSong_t = 0
                                            as *mut PianoSong_t;
                                        feedbackSong = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        ) as *mut PianoSong_t;
                                        if feedbackSong.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*feedbackSong)
                                            .title = PianoJsonStrdup(
                                            s_5,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .artist = PianoJsonStrdup(
                                            s_5,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .feedbackId = PianoJsonStrdup(
                                            s_5,
                                            b"feedbackId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .rating = (if getBoolDefault(
                                            s_5,
                                            b"isPositive\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        ) as libc::c_int != 0
                                        {
                                            PIANO_RATE_LOVE as libc::c_int
                                        } else {
                                            PIANO_RATE_BAN as libc::c_int
                                        }) as PianoSongRating_t;
                                        let mut v_0: *mut json_object = 0 as *mut json_object;
                                        (*feedbackSong)
                                            .length = (if json_object_object_get_ex(
                                            s_5,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v_0,
                                        ) != 0
                                        {
                                            json_object_get_int(v_0)
                                        } else {
                                            0 as libc::c_int
                                        }) as libc::c_uint;
                                        (*info)
                                            .feedback = PianoListAppend(
                                            if ((*info).feedback).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*info).feedback).head
                                            },
                                            &mut (*feedbackSong).head,
                                        ) as *mut PianoSong_t;
                                        i_9 += 1;
                                        i_9;
                                    }
                                }
                                i_8 = i_8.wrapping_add(1);
                                i_8;
                            }
                        }
                    }
                    11202235766349324107 => {
                        let settings: *mut PianoSettings_t = (*req).data
                            as *mut PianoSettings_t;
                        (*settings)
                            .explicitContentFilter = getBoolDefault(
                            result,
                            b"isExplicitContentFilterEnabled\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int != 0,
                        );
                        (*settings)
                            .username = PianoJsonStrdup(
                            result,
                            b"username\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    145651165234646754 => {
                        let mut reqData_5: *mut PianoRequestDataExplain_t = (*req).data
                            as *mut PianoRequestDataExplain_t;
                        let strSize: size_t = 768 as libc::c_int as size_t;
                        let mut explanations: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"explanations\0" as *const u8 as *const libc::c_char,
                            &mut explanations,
                        ) != 0
                        {
                            (*reqData_5)
                                .retExplain = malloc(
                                strSize
                                    .wrapping_mul(
                                        ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                    ),
                            ) as *mut libc::c_char;
                            strncpy(
                                (*reqData_5).retExplain,
                                b"We're playing this track because it features \0"
                                    as *const u8 as *const libc::c_char,
                                strSize,
                            );
                            let mut i_5: libc::c_int = 0 as libc::c_int;
                            while (i_5 as libc::c_ulong)
                                < json_object_array_length(explanations)
                            {
                                let mut e: *mut json_object = json_object_array_get_idx(
                                    explanations,
                                    i_5 as size_t,
                                );
                                let mut f: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    e,
                                    b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                    &mut f,
                                ) == 0)
                                {
                                    let mut s_3: *const libc::c_char = json_object_get_string(
                                        f,
                                    );
                                    PianoStrpcat((*reqData_5).retExplain, s_3, strSize);
                                    if (i_5 as libc::c_ulong)
                                        < (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b", \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else if i_5 as libc::c_ulong
                                        == (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b" and \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b".\0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    }
                                }
                                i_5 += 1;
                                i_5;
                            }
                        }
                    }
                    9240481512215375588 => {
                        let mut station_0: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*station_0).isCreator = 1 as libc::c_int as libc::c_char;
                    }
                    5908482871227205451 => {
                        let mut categories: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"categories\0" as *const u8 as *const libc::c_char,
                            &mut categories,
                        ) != 0
                        {
                            let mut i_4: libc::c_int = 0 as libc::c_int;
                            while (i_4 as libc::c_ulong)
                                < json_object_array_length(categories)
                            {
                                let mut c: *mut json_object = json_object_array_get_idx(
                                    categories,
                                    i_4 as size_t,
                                );
                                let mut tmpGenreCategory: *mut PianoGenreCategory_t = 0
                                    as *mut PianoGenreCategory_t;
                                tmpGenreCategory = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoGenreCategory_t>()
                                        as libc::c_ulong,
                                ) as *mut PianoGenreCategory_t;
                                if tmpGenreCategory.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*tmpGenreCategory)
                                    .name = PianoJsonStrdup(
                                    c,
                                    b"categoryName\0" as *const u8 as *const libc::c_char,
                                );
                                let mut stations_0: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    c,
                                    b"stations\0" as *const u8 as *const libc::c_char,
                                    &mut stations_0,
                                ) != 0
                                {
                                    let mut k_0: libc::c_int = 0 as libc::c_int;
                                    while (k_0 as libc::c_ulong)
                                        < json_object_array_length(stations_0)
                                    {
                                        let mut s_2: *mut json_object = json_object_array_get_idx(
                                            stations_0,
                                            k_0 as size_t,
                                        );
                                        let mut tmpGenre: *mut PianoGenre_t = 0
                                            as *mut PianoGenre_t;
                                        tmpGenre = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                        ) as *mut PianoGenre_t;
                                        if tmpGenre.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*tmpGenre)
                                            .name = PianoJsonStrdup(
                                            s_2,
                                            b"stationName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenre)
                                            .musicId = PianoJsonStrdup(
                                            s_2,
                                            b"stationToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenreCategory)
                                            .genres = PianoListAppend(
                                            if ((*tmpGenreCategory).genres).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*tmpGenreCategory).genres).head
                                            },
                                            &mut (*tmpGenre).head,
                                        ) as *mut PianoGenre_t;
                                        k_0 += 1;
                                        k_0;
                                    }
                                }
                                (*ph)
                                    .genreStations = PianoListAppend(
                                    if ((*ph).genreStations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).genreStations).head
                                    },
                                    &mut (*tmpGenreCategory).head,
                                ) as *mut PianoGenreCategory_t;
                                i_4 += 1;
                                i_4;
                            }
                        }
                    }
                    5260680050201874961 => {
                        let song_1: *mut PianoSong_t = (*req).data as *mut PianoSong_t;
                        (*song_1).rating = PIANO_RATE_TIRED;
                    }
                    11235674318412060590 => {
                        let mut tmpStation_0: *mut PianoStation_t = 0
                            as *mut PianoStation_t;
                        tmpStation_0 = calloc(
                            1 as libc::c_int as libc::c_ulong,
                            ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                        ) as *mut PianoStation_t;
                        if tmpStation_0.is_null() {
                            return PIANO_RET_OUT_OF_MEMORY;
                        }
                        PianoJsonParseStation(result, tmpStation_0);
                        let mut search: *mut PianoStation_t = PianoFindStationById(
                            (*ph).stations,
                            (*tmpStation_0).id,
                        );
                        if !search.is_null() {
                            (*ph)
                                .stations = PianoListDelete(
                                if ((*ph).stations).is_null() {
                                    0 as *mut PianoListHead_t
                                } else {
                                    &mut (*(*ph).stations).head
                                },
                                &mut (*search).head,
                            ) as *mut PianoStation_t;
                            PianoDestroyStation(search);
                            free(search as *mut libc::c_void);
                        }
                        (*ph)
                            .stations = PianoListAppend(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*tmpStation_0).head,
                        ) as *mut PianoStation_t;
                    }
                    10109057886293123569 => {
                        let mut reqData_4: *mut PianoRequestDataSearch_t = (*req).data
                            as *mut PianoRequestDataSearch_t;
                        let mut searchResult: *mut PianoSearchResult_t = 0
                            as *mut PianoSearchResult_t;
                        searchResult = &mut (*reqData_4).searchResult;
                        memset(
                            searchResult as *mut libc::c_void,
                            0 as libc::c_int,
                            ::std::mem::size_of::<PianoSearchResult_t>() as libc::c_ulong,
                        );
                        let mut artists: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"artists\0" as *const u8 as *const libc::c_char,
                            &mut artists,
                        ) != 0
                        {
                            let mut i_2: libc::c_int = 0 as libc::c_int;
                            while (i_2 as libc::c_ulong)
                                < json_object_array_length(artists)
                            {
                                let mut a: *mut json_object = json_object_array_get_idx(
                                    artists,
                                    i_2 as size_t,
                                );
                                let mut artist: *mut PianoArtist_t = 0
                                    as *mut PianoArtist_t;
                                artist = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                ) as *mut PianoArtist_t;
                                if artist.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*artist)
                                    .name = PianoJsonStrdup(
                                    a,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*artist)
                                    .musicId = PianoJsonStrdup(
                                    a,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .artists = PianoListAppend(
                                    if ((*searchResult).artists).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).artists).head
                                    },
                                    &mut (*artist).head,
                                ) as *mut PianoArtist_t;
                                i_2 += 1;
                                i_2;
                            }
                        }
                        let mut songs: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"songs\0" as *const u8 as *const libc::c_char,
                            &mut songs,
                        ) != 0
                        {
                            let mut i_3: libc::c_int = 0 as libc::c_int;
                            while (i_3 as libc::c_ulong)
                                < json_object_array_length(songs)
                            {
                                let mut s_1: *mut json_object = json_object_array_get_idx(
                                    songs,
                                    i_3 as size_t,
                                );
                                let mut song_0: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song_0 = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song_0.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*song_0)
                                    .title = PianoJsonStrdup(
                                    s_1,
                                    b"songName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .artist = PianoJsonStrdup(
                                    s_1,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .musicId = PianoJsonStrdup(
                                    s_1,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .songs = PianoListAppend(
                                    if ((*searchResult).songs).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).songs).head
                                    },
                                    &mut (*song_0).head,
                                ) as *mut PianoSong_t;
                                i_3 += 1;
                                i_3;
                            }
                        }
                    }
                    4983594971376015098 => {
                        let mut station: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*ph)
                            .stations = PianoListDelete(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*station).head,
                        ) as *mut PianoStation_t;
                        PianoDestroyStation(station);
                        free(station as *mut libc::c_void);
                    }
                    17372050596571538954 => {
                        let mut reqData_3: *mut PianoRequestDataRenameStation_t = (*req)
                            .data as *mut PianoRequestDataRenameStation_t;
                        free((*(*reqData_3).station).name as *mut libc::c_void);
                        (*(*reqData_3).station).name = strdup((*reqData_3).newName);
                    }
                    7297078374430259003 => {
                        let mut reqData_2: *mut PianoRequestDataRateSong_t = (*req).data
                            as *mut PianoRequestDataRateSong_t;
                        (*(*reqData_2).song).rating = (*reqData_2).rating;
                    }
                    17075014677070940716 => {
                        let mut reqData_1: *mut PianoRequestDataGetPlaylist_t = (*req)
                            .data as *mut PianoRequestDataGetPlaylist_t;
                        let mut playlist: *mut PianoSong_t = 0 as *mut PianoSong_t;
                        let mut items: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"items\0" as *const u8 as *const libc::c_char,
                            &mut items,
                        ) == 0)
                        {
                            let mut i_1: libc::c_int = 0 as libc::c_int;
                            loop {
                                if !((i_1 as libc::c_ulong)
                                    < json_object_array_length(items))
                                {
                                    current_block = 4488496028633655612;
                                    break;
                                }
                                let mut s_0: *mut json_object = json_object_array_get_idx(
                                    items,
                                    i_1 as size_t,
                                );
                                let mut song: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                if json_object_object_get_ex(
                                    s_0,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                    0 as *mut *mut json_object,
                                ) == 0
                                {
                                    free(song as *mut libc::c_void);
                                } else {
                                    static mut qualityMap: [*const libc::c_char; 4] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"lowQuality\0" as *const u8 as *const libc::c_char,
                                        b"mediumQuality\0" as *const u8 as *const libc::c_char,
                                        b"highQuality\0" as *const u8 as *const libc::c_char,
                                    ];
                                    static mut formatMap: [*const libc::c_char; 3] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"aacplus\0" as *const u8 as *const libc::c_char,
                                        b"mp3\0" as *const u8 as *const libc::c_char,
                                    ];
                                    let mut umap: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        s_0,
                                        b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                        &mut umap,
                                    ) != 0
                                    {
                                        let mut jsonEncoding: *mut json_object = 0
                                            as *mut json_object;
                                        let mut qmap: *mut json_object = 0 as *mut json_object;
                                        if json_object_object_get_ex(
                                            umap,
                                            qualityMap[(*reqData_1).quality as usize],
                                            &mut qmap,
                                        ) != 0
                                            && json_object_object_get_ex(
                                                qmap,
                                                b"encoding\0" as *const u8 as *const libc::c_char,
                                                &mut jsonEncoding,
                                            ) != 0
                                        {
                                            let mut encoding: *const libc::c_char = json_object_get_string(
                                                jsonEncoding,
                                            );
                                            let mut k: size_t = 0 as libc::c_int as size_t;
                                            while k
                                                < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                    as libc::c_ulong)
                                                    .wrapping_div(
                                                        ::std::mem::size_of::<*const libc::c_char>()
                                                            as libc::c_ulong,
                                                    )
                                            {
                                                if strcmp(formatMap[k as usize], encoding)
                                                    == 0 as libc::c_int
                                                {
                                                    (*song).audioFormat = k as PianoAudioFormat_t;
                                                    break;
                                                } else {
                                                    k = k.wrapping_add(1);
                                                    k;
                                                }
                                            }
                                            (*song)
                                                .audioUrl = PianoJsonStrdup(
                                                qmap,
                                                b"audioUrl\0" as *const u8 as *const libc::c_char,
                                            );
                                        } else {
                                            ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                            free(song as *mut libc::c_void);
                                            PianoDestroyPlaylist(playlist);
                                            current_block = 9169893888141833765;
                                            break;
                                        }
                                    }
                                    let mut v: *mut json_object = 0 as *mut json_object;
                                    (*song)
                                        .artist = PianoJsonStrdup(
                                        s_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .album = PianoJsonStrdup(
                                        s_0,
                                        b"albumName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .title = PianoJsonStrdup(
                                        s_0,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .trackToken = PianoJsonStrdup(
                                        s_0,
                                        b"trackToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .stationId = PianoJsonStrdup(
                                        s_0,
                                        b"stationId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .coverArt = PianoJsonStrdup(
                                        s_0,
                                        b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .detailUrl = PianoJsonStrdup(
                                        s_0,
                                        b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .fileGain = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackGain\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_double(v)
                                    } else {
                                        0.0f64
                                    }) as libc::c_float;
                                    (*song)
                                        .length = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackLength\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    }) as libc::c_uint;
                                    match if json_object_object_get_ex(
                                        s_0,
                                        b"songRating\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    } {
                                        1 => {
                                            (*song).rating = PIANO_RATE_LOVE;
                                        }
                                        _ => {}
                                    }
                                    playlist = PianoListAppend(
                                        if playlist.is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*playlist).head
                                        },
                                        &mut (*song).head,
                                    ) as *mut PianoSong_t;
                                }
                                i_1 += 1;
                                i_1;
                            }
                            match current_block {
                                9169893888141833765 => {}
                                _ => {
                                    (*reqData_1).retPlaylist = playlist;
                                }
                            }
                        }
                    }
                    6450597802325118133 => {
                        let mut stations: *mut json_object = 0 as *mut json_object;
                        let mut mix: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"stations\0" as *const u8 as *const libc::c_char,
                            &mut stations,
                        ) == 0)
                        {
                            let mut i: libc::c_int = 0 as libc::c_int;
                            while (i as libc::c_ulong)
                                < json_object_array_length(stations)
                            {
                                let mut tmpStation: *mut PianoStation_t = 0
                                    as *mut PianoStation_t;
                                let mut s: *mut json_object = json_object_array_get_idx(
                                    stations,
                                    i as size_t,
                                );
                                tmpStation = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                ) as *mut PianoStation_t;
                                if tmpStation.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                PianoJsonParseStation(s, tmpStation);
                                if (*tmpStation).isQuickMix != 0 {
                                    json_object_object_get_ex(
                                        s,
                                        b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                        &mut mix,
                                    );
                                }
                                (*ph)
                                    .stations = PianoListAppend(
                                    if ((*ph).stations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).stations).head
                                    },
                                    &mut (*tmpStation).head,
                                ) as *mut PianoStation_t;
                                i += 1;
                                i;
                            }
                            if !mix.is_null() {
                                let mut curStation: *mut PianoStation_t = (*ph).stations;
                                while !curStation.is_null() {
                                    let mut i_0: libc::c_int = 0 as libc::c_int;
                                    while (i_0 as libc::c_ulong) < json_object_array_length(mix)
                                    {
                                        let mut id: *mut json_object = json_object_array_get_idx(
                                            mix,
                                            i_0 as size_t,
                                        );
                                        if strcmp(json_object_get_string(id), (*curStation).id)
                                            == 0 as libc::c_int
                                        {
                                            (*curStation)
                                                .useQuickMix = 1 as libc::c_int as libc::c_char;
                                        }
                                        i_0 += 1;
                                        i_0;
                                    }
                                    curStation = (*curStation).head.next as *mut libc::c_void
                                        as *mut PianoStation_t;
                                }
                            }
                        }
                    }
                    12039483399334584727 => {
                        let mut reqData_0: *mut PianoRequestDataLogin_t = (*req).data
                            as *mut PianoRequestDataLogin_t;
                        match (*reqData_0).step as libc::c_int {
                            0 => {
                                let mut jsonTimestamp: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    result,
                                    b"syncTime\0" as *const u8 as *const libc::c_char,
                                    &mut jsonTimestamp,
                                ) == 0
                                {
                                    ret = PIANO_RET_INVALID_RESPONSE;
                                } else {
                                    let cryptedTimestamp: *const libc::c_char = json_object_get_string(
                                        jsonTimestamp,
                                    );
                                    let realTimestamp: time_t = time(0 as *mut time_t);
                                    let mut decryptedTimestamp: *mut libc::c_char = 0
                                        as *mut libc::c_char;
                                    let mut decryptedSize: size_t = 0;
                                    ret = PIANO_RET_ERR;
                                    decryptedTimestamp = PianoDecryptString(
                                        (*ph).partner.in_0,
                                        cryptedTimestamp,
                                        &mut decryptedSize,
                                    );
                                    if !decryptedTimestamp.is_null()
                                        && decryptedSize > 4 as libc::c_int as libc::c_ulong
                                    {
                                        let timestamp: libc::c_ulong = strtoul(
                                            decryptedTimestamp.offset(4 as libc::c_int as isize),
                                            0 as *mut *mut libc::c_char,
                                            0 as libc::c_int,
                                        );
                                        (*ph)
                                            .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                            as libc::c_int;
                                        ret = PIANO_RET_CONTINUE_REQUEST;
                                    }
                                    free(decryptedTimestamp as *mut libc::c_void);
                                    (*ph)
                                        .partner
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    let mut partnerId: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        result,
                                        b"partnerId\0" as *const u8 as *const libc::c_char,
                                        &mut partnerId,
                                    ) == 0
                                    {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        (*ph)
                                            .partner
                                            .id = json_object_get_int(partnerId) as libc::c_uint;
                                        (*reqData_0).step = ((*reqData_0).step).wrapping_add(1);
                                        (*reqData_0).step;
                                    }
                                }
                            }
                            1 => {
                                if !((*ph).user.listenerId).is_null() {
                                    PianoDestroyUserInfo(&mut (*ph).user);
                                }
                                (*ph)
                                    .user
                                    .listenerId = PianoJsonStrdup(
                                    result,
                                    b"userId\0" as *const u8 as *const libc::c_char,
                                );
                                (*ph)
                                    .user
                                    .authToken = PianoJsonStrdup(
                                    result,
                                    b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                );
                            }
                            _ => {}
                        }
                    }
                    10223170376184624358 => {
                        let mut reqData_8: *mut PianoRequestDataSetStationMode_t = (*req)
                            .data as *mut PianoRequestDataSetStationMode_t;
                        let mut active_0: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode_0: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode_0,
                        ) != 0
                        {
                            active_0 = json_object_get_int(activeMode_0);
                        }
                        if active_0 as libc::c_uint != (*reqData_8).id {
                            return PIANO_RET_ERR;
                        }
                    }
                    _ => {
                        let mut reqData_7: *mut PianoRequestDataGetStationModes_t = (*req)
                            .data as *mut PianoRequestDataGetStationModes_t;
                        let mut active: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode,
                        ) != 0
                        {
                            active = json_object_get_int(activeMode);
                        }
                        let mut availableModes: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"availableModes\0" as *const u8 as *const libc::c_char,
                            &mut availableModes,
                        ) != 0
                        {
                            let mut i_10: libc::c_int = 0 as libc::c_int;
                            while (i_10 as libc::c_ulong)
                                < json_object_array_length(availableModes)
                            {
                                let mut val_0: *mut json_object = json_object_array_get_idx(
                                    availableModes,
                                    i_10 as size_t,
                                );
                                let mut mode: *mut PianoStationMode_t = 0
                                    as *mut PianoStationMode_t;
                                mode = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                ) as *mut PianoStationMode_t;
                                if mode.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                let mut modeId: *mut json_object = 0 as *mut json_object;
                                if json_object_object_get_ex(
                                    val_0,
                                    b"modeId\0" as *const u8 as *const libc::c_char,
                                    &mut modeId,
                                ) != 0
                                {
                                    (*mode).id = json_object_get_int(modeId);
                                    (*mode)
                                        .name = PianoJsonStrdup(
                                        val_0,
                                        b"modeName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .description = PianoJsonStrdup(
                                        val_0,
                                        b"modeDescription\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .isAlgorithmic = getBoolDefault(
                                        val_0,
                                        b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode)
                                        .isTakeover = getBoolDefault(
                                        val_0,
                                        b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode).active = active == (*mode).id;
                                }
                                (*reqData_7)
                                    .retModes = PianoListAppend(
                                    if ((*reqData_7).retModes).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*reqData_7).retModes).head
                                    },
                                    &mut (*mode).head,
                                ) as *mut PianoStationMode_t;
                                i_10 += 1;
                                i_10;
                            }
                        }
                    }
                }
            }
            9 => {
                current_block = 10109057886293123569;
                match current_block {
                    14870924983410776565 => {}
                    4367030874028593650 => {
                        let mut reqData_6: *mut PianoRequestDataGetStationInfo_t = (*req)
                            .data as *mut PianoRequestDataGetStationInfo_t;
                        let mut info: *mut PianoStationInfo_t = 0
                            as *mut PianoStationInfo_t;
                        info = &mut (*reqData_6).info;
                        let mut music: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"music\0" as *const u8 as *const libc::c_char,
                            &mut music,
                        ) != 0
                        {
                            let mut songs_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs_0,
                            ) != 0
                            {
                                let mut i_6: libc::c_int = 0 as libc::c_int;
                                while (i_6 as libc::c_ulong)
                                    < json_object_array_length(songs_0)
                                {
                                    let mut s_4: *mut json_object = json_object_array_get_idx(
                                        songs_0,
                                        i_6 as size_t,
                                    );
                                    let mut seedSong: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                    seedSong = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    ) as *mut PianoSong_t;
                                    if seedSong.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedSong)
                                        .title = PianoJsonStrdup(
                                        s_4,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .artist = PianoJsonStrdup(
                                        s_4,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .seedId = PianoJsonStrdup(
                                        s_4,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .songSeeds = PianoListAppend(
                                        if ((*info).songSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).songSeeds).head
                                        },
                                        &mut (*seedSong).head,
                                    ) as *mut PianoSong_t;
                                    i_6 += 1;
                                    i_6;
                                }
                            }
                            let mut artists_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists_0,
                            ) != 0
                            {
                                let mut i_7: libc::c_int = 0 as libc::c_int;
                                while (i_7 as libc::c_ulong)
                                    < json_object_array_length(artists_0)
                                {
                                    let mut a_0: *mut json_object = json_object_array_get_idx(
                                        artists_0,
                                        i_7 as size_t,
                                    );
                                    let mut seedArtist: *mut PianoArtist_t = 0
                                        as *mut PianoArtist_t;
                                    seedArtist = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    ) as *mut PianoArtist_t;
                                    if seedArtist.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedArtist)
                                        .name = PianoJsonStrdup(
                                        a_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedArtist)
                                        .seedId = PianoJsonStrdup(
                                        a_0,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .artistSeeds = PianoListAppend(
                                        if ((*info).artistSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).artistSeeds).head
                                        },
                                        &mut (*seedArtist).head,
                                    ) as *mut PianoArtist_t;
                                    i_7 += 1;
                                    i_7;
                                }
                            }
                        }
                        let mut feedback: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"feedback\0" as *const u8 as *const libc::c_char,
                            &mut feedback,
                        ) != 0
                        {
                            static mut keys: [*const libc::c_char; 2] = [
                                b"thumbsUp\0" as *const u8 as *const libc::c_char,
                                b"thumbsDown\0" as *const u8 as *const libc::c_char,
                            ];
                            let mut i_8: size_t = 0 as libc::c_int as size_t;
                            while i_8
                                < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                    as libc::c_ulong)
                                    .wrapping_div(
                                        ::std::mem::size_of::<*const libc::c_char>()
                                            as libc::c_ulong,
                                    )
                            {
                                let mut val: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    feedback,
                                    keys[i_8 as usize],
                                    &mut val,
                                ) == 0)
                                {
                                    let mut i_9: libc::c_int = 0 as libc::c_int;
                                    while (i_9 as libc::c_ulong) < json_object_array_length(val)
                                    {
                                        let mut s_5: *mut json_object = json_object_array_get_idx(
                                            val,
                                            i_9 as size_t,
                                        );
                                        let mut feedbackSong: *mut PianoSong_t = 0
                                            as *mut PianoSong_t;
                                        feedbackSong = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        ) as *mut PianoSong_t;
                                        if feedbackSong.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*feedbackSong)
                                            .title = PianoJsonStrdup(
                                            s_5,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .artist = PianoJsonStrdup(
                                            s_5,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .feedbackId = PianoJsonStrdup(
                                            s_5,
                                            b"feedbackId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .rating = (if getBoolDefault(
                                            s_5,
                                            b"isPositive\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        ) as libc::c_int != 0
                                        {
                                            PIANO_RATE_LOVE as libc::c_int
                                        } else {
                                            PIANO_RATE_BAN as libc::c_int
                                        }) as PianoSongRating_t;
                                        let mut v_0: *mut json_object = 0 as *mut json_object;
                                        (*feedbackSong)
                                            .length = (if json_object_object_get_ex(
                                            s_5,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v_0,
                                        ) != 0
                                        {
                                            json_object_get_int(v_0)
                                        } else {
                                            0 as libc::c_int
                                        }) as libc::c_uint;
                                        (*info)
                                            .feedback = PianoListAppend(
                                            if ((*info).feedback).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*info).feedback).head
                                            },
                                            &mut (*feedbackSong).head,
                                        ) as *mut PianoSong_t;
                                        i_9 += 1;
                                        i_9;
                                    }
                                }
                                i_8 = i_8.wrapping_add(1);
                                i_8;
                            }
                        }
                    }
                    11202235766349324107 => {
                        let settings: *mut PianoSettings_t = (*req).data
                            as *mut PianoSettings_t;
                        (*settings)
                            .explicitContentFilter = getBoolDefault(
                            result,
                            b"isExplicitContentFilterEnabled\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int != 0,
                        );
                        (*settings)
                            .username = PianoJsonStrdup(
                            result,
                            b"username\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    145651165234646754 => {
                        let mut reqData_5: *mut PianoRequestDataExplain_t = (*req).data
                            as *mut PianoRequestDataExplain_t;
                        let strSize: size_t = 768 as libc::c_int as size_t;
                        let mut explanations: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"explanations\0" as *const u8 as *const libc::c_char,
                            &mut explanations,
                        ) != 0
                        {
                            (*reqData_5)
                                .retExplain = malloc(
                                strSize
                                    .wrapping_mul(
                                        ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                    ),
                            ) as *mut libc::c_char;
                            strncpy(
                                (*reqData_5).retExplain,
                                b"We're playing this track because it features \0"
                                    as *const u8 as *const libc::c_char,
                                strSize,
                            );
                            let mut i_5: libc::c_int = 0 as libc::c_int;
                            while (i_5 as libc::c_ulong)
                                < json_object_array_length(explanations)
                            {
                                let mut e: *mut json_object = json_object_array_get_idx(
                                    explanations,
                                    i_5 as size_t,
                                );
                                let mut f: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    e,
                                    b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                    &mut f,
                                ) == 0)
                                {
                                    let mut s_3: *const libc::c_char = json_object_get_string(
                                        f,
                                    );
                                    PianoStrpcat((*reqData_5).retExplain, s_3, strSize);
                                    if (i_5 as libc::c_ulong)
                                        < (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b", \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else if i_5 as libc::c_ulong
                                        == (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b" and \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b".\0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    }
                                }
                                i_5 += 1;
                                i_5;
                            }
                        }
                    }
                    9240481512215375588 => {
                        let mut station_0: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*station_0).isCreator = 1 as libc::c_int as libc::c_char;
                    }
                    5908482871227205451 => {
                        let mut categories: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"categories\0" as *const u8 as *const libc::c_char,
                            &mut categories,
                        ) != 0
                        {
                            let mut i_4: libc::c_int = 0 as libc::c_int;
                            while (i_4 as libc::c_ulong)
                                < json_object_array_length(categories)
                            {
                                let mut c: *mut json_object = json_object_array_get_idx(
                                    categories,
                                    i_4 as size_t,
                                );
                                let mut tmpGenreCategory: *mut PianoGenreCategory_t = 0
                                    as *mut PianoGenreCategory_t;
                                tmpGenreCategory = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoGenreCategory_t>()
                                        as libc::c_ulong,
                                ) as *mut PianoGenreCategory_t;
                                if tmpGenreCategory.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*tmpGenreCategory)
                                    .name = PianoJsonStrdup(
                                    c,
                                    b"categoryName\0" as *const u8 as *const libc::c_char,
                                );
                                let mut stations_0: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    c,
                                    b"stations\0" as *const u8 as *const libc::c_char,
                                    &mut stations_0,
                                ) != 0
                                {
                                    let mut k_0: libc::c_int = 0 as libc::c_int;
                                    while (k_0 as libc::c_ulong)
                                        < json_object_array_length(stations_0)
                                    {
                                        let mut s_2: *mut json_object = json_object_array_get_idx(
                                            stations_0,
                                            k_0 as size_t,
                                        );
                                        let mut tmpGenre: *mut PianoGenre_t = 0
                                            as *mut PianoGenre_t;
                                        tmpGenre = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                        ) as *mut PianoGenre_t;
                                        if tmpGenre.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*tmpGenre)
                                            .name = PianoJsonStrdup(
                                            s_2,
                                            b"stationName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenre)
                                            .musicId = PianoJsonStrdup(
                                            s_2,
                                            b"stationToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenreCategory)
                                            .genres = PianoListAppend(
                                            if ((*tmpGenreCategory).genres).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*tmpGenreCategory).genres).head
                                            },
                                            &mut (*tmpGenre).head,
                                        ) as *mut PianoGenre_t;
                                        k_0 += 1;
                                        k_0;
                                    }
                                }
                                (*ph)
                                    .genreStations = PianoListAppend(
                                    if ((*ph).genreStations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).genreStations).head
                                    },
                                    &mut (*tmpGenreCategory).head,
                                ) as *mut PianoGenreCategory_t;
                                i_4 += 1;
                                i_4;
                            }
                        }
                    }
                    5260680050201874961 => {
                        let song_1: *mut PianoSong_t = (*req).data as *mut PianoSong_t;
                        (*song_1).rating = PIANO_RATE_TIRED;
                    }
                    11235674318412060590 => {
                        let mut tmpStation_0: *mut PianoStation_t = 0
                            as *mut PianoStation_t;
                        tmpStation_0 = calloc(
                            1 as libc::c_int as libc::c_ulong,
                            ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                        ) as *mut PianoStation_t;
                        if tmpStation_0.is_null() {
                            return PIANO_RET_OUT_OF_MEMORY;
                        }
                        PianoJsonParseStation(result, tmpStation_0);
                        let mut search: *mut PianoStation_t = PianoFindStationById(
                            (*ph).stations,
                            (*tmpStation_0).id,
                        );
                        if !search.is_null() {
                            (*ph)
                                .stations = PianoListDelete(
                                if ((*ph).stations).is_null() {
                                    0 as *mut PianoListHead_t
                                } else {
                                    &mut (*(*ph).stations).head
                                },
                                &mut (*search).head,
                            ) as *mut PianoStation_t;
                            PianoDestroyStation(search);
                            free(search as *mut libc::c_void);
                        }
                        (*ph)
                            .stations = PianoListAppend(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*tmpStation_0).head,
                        ) as *mut PianoStation_t;
                    }
                    10109057886293123569 => {
                        let mut reqData_4: *mut PianoRequestDataSearch_t = (*req).data
                            as *mut PianoRequestDataSearch_t;
                        let mut searchResult: *mut PianoSearchResult_t = 0
                            as *mut PianoSearchResult_t;
                        searchResult = &mut (*reqData_4).searchResult;
                        memset(
                            searchResult as *mut libc::c_void,
                            0 as libc::c_int,
                            ::std::mem::size_of::<PianoSearchResult_t>() as libc::c_ulong,
                        );
                        let mut artists: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"artists\0" as *const u8 as *const libc::c_char,
                            &mut artists,
                        ) != 0
                        {
                            let mut i_2: libc::c_int = 0 as libc::c_int;
                            while (i_2 as libc::c_ulong)
                                < json_object_array_length(artists)
                            {
                                let mut a: *mut json_object = json_object_array_get_idx(
                                    artists,
                                    i_2 as size_t,
                                );
                                let mut artist: *mut PianoArtist_t = 0
                                    as *mut PianoArtist_t;
                                artist = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                ) as *mut PianoArtist_t;
                                if artist.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*artist)
                                    .name = PianoJsonStrdup(
                                    a,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*artist)
                                    .musicId = PianoJsonStrdup(
                                    a,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .artists = PianoListAppend(
                                    if ((*searchResult).artists).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).artists).head
                                    },
                                    &mut (*artist).head,
                                ) as *mut PianoArtist_t;
                                i_2 += 1;
                                i_2;
                            }
                        }
                        let mut songs: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"songs\0" as *const u8 as *const libc::c_char,
                            &mut songs,
                        ) != 0
                        {
                            let mut i_3: libc::c_int = 0 as libc::c_int;
                            while (i_3 as libc::c_ulong)
                                < json_object_array_length(songs)
                            {
                                let mut s_1: *mut json_object = json_object_array_get_idx(
                                    songs,
                                    i_3 as size_t,
                                );
                                let mut song_0: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song_0 = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song_0.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*song_0)
                                    .title = PianoJsonStrdup(
                                    s_1,
                                    b"songName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .artist = PianoJsonStrdup(
                                    s_1,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .musicId = PianoJsonStrdup(
                                    s_1,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .songs = PianoListAppend(
                                    if ((*searchResult).songs).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).songs).head
                                    },
                                    &mut (*song_0).head,
                                ) as *mut PianoSong_t;
                                i_3 += 1;
                                i_3;
                            }
                        }
                    }
                    4983594971376015098 => {
                        let mut station: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*ph)
                            .stations = PianoListDelete(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*station).head,
                        ) as *mut PianoStation_t;
                        PianoDestroyStation(station);
                        free(station as *mut libc::c_void);
                    }
                    17372050596571538954 => {
                        let mut reqData_3: *mut PianoRequestDataRenameStation_t = (*req)
                            .data as *mut PianoRequestDataRenameStation_t;
                        free((*(*reqData_3).station).name as *mut libc::c_void);
                        (*(*reqData_3).station).name = strdup((*reqData_3).newName);
                    }
                    7297078374430259003 => {
                        let mut reqData_2: *mut PianoRequestDataRateSong_t = (*req).data
                            as *mut PianoRequestDataRateSong_t;
                        (*(*reqData_2).song).rating = (*reqData_2).rating;
                    }
                    17075014677070940716 => {
                        let mut reqData_1: *mut PianoRequestDataGetPlaylist_t = (*req)
                            .data as *mut PianoRequestDataGetPlaylist_t;
                        let mut playlist: *mut PianoSong_t = 0 as *mut PianoSong_t;
                        let mut items: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"items\0" as *const u8 as *const libc::c_char,
                            &mut items,
                        ) == 0)
                        {
                            let mut i_1: libc::c_int = 0 as libc::c_int;
                            loop {
                                if !((i_1 as libc::c_ulong)
                                    < json_object_array_length(items))
                                {
                                    current_block = 4488496028633655612;
                                    break;
                                }
                                let mut s_0: *mut json_object = json_object_array_get_idx(
                                    items,
                                    i_1 as size_t,
                                );
                                let mut song: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                if json_object_object_get_ex(
                                    s_0,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                    0 as *mut *mut json_object,
                                ) == 0
                                {
                                    free(song as *mut libc::c_void);
                                } else {
                                    static mut qualityMap: [*const libc::c_char; 4] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"lowQuality\0" as *const u8 as *const libc::c_char,
                                        b"mediumQuality\0" as *const u8 as *const libc::c_char,
                                        b"highQuality\0" as *const u8 as *const libc::c_char,
                                    ];
                                    static mut formatMap: [*const libc::c_char; 3] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"aacplus\0" as *const u8 as *const libc::c_char,
                                        b"mp3\0" as *const u8 as *const libc::c_char,
                                    ];
                                    let mut umap: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        s_0,
                                        b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                        &mut umap,
                                    ) != 0
                                    {
                                        let mut jsonEncoding: *mut json_object = 0
                                            as *mut json_object;
                                        let mut qmap: *mut json_object = 0 as *mut json_object;
                                        if json_object_object_get_ex(
                                            umap,
                                            qualityMap[(*reqData_1).quality as usize],
                                            &mut qmap,
                                        ) != 0
                                            && json_object_object_get_ex(
                                                qmap,
                                                b"encoding\0" as *const u8 as *const libc::c_char,
                                                &mut jsonEncoding,
                                            ) != 0
                                        {
                                            let mut encoding: *const libc::c_char = json_object_get_string(
                                                jsonEncoding,
                                            );
                                            let mut k: size_t = 0 as libc::c_int as size_t;
                                            while k
                                                < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                    as libc::c_ulong)
                                                    .wrapping_div(
                                                        ::std::mem::size_of::<*const libc::c_char>()
                                                            as libc::c_ulong,
                                                    )
                                            {
                                                if strcmp(formatMap[k as usize], encoding)
                                                    == 0 as libc::c_int
                                                {
                                                    (*song).audioFormat = k as PianoAudioFormat_t;
                                                    break;
                                                } else {
                                                    k = k.wrapping_add(1);
                                                    k;
                                                }
                                            }
                                            (*song)
                                                .audioUrl = PianoJsonStrdup(
                                                qmap,
                                                b"audioUrl\0" as *const u8 as *const libc::c_char,
                                            );
                                        } else {
                                            ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                            free(song as *mut libc::c_void);
                                            PianoDestroyPlaylist(playlist);
                                            current_block = 9169893888141833765;
                                            break;
                                        }
                                    }
                                    let mut v: *mut json_object = 0 as *mut json_object;
                                    (*song)
                                        .artist = PianoJsonStrdup(
                                        s_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .album = PianoJsonStrdup(
                                        s_0,
                                        b"albumName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .title = PianoJsonStrdup(
                                        s_0,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .trackToken = PianoJsonStrdup(
                                        s_0,
                                        b"trackToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .stationId = PianoJsonStrdup(
                                        s_0,
                                        b"stationId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .coverArt = PianoJsonStrdup(
                                        s_0,
                                        b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .detailUrl = PianoJsonStrdup(
                                        s_0,
                                        b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .fileGain = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackGain\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_double(v)
                                    } else {
                                        0.0f64
                                    }) as libc::c_float;
                                    (*song)
                                        .length = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackLength\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    }) as libc::c_uint;
                                    match if json_object_object_get_ex(
                                        s_0,
                                        b"songRating\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    } {
                                        1 => {
                                            (*song).rating = PIANO_RATE_LOVE;
                                        }
                                        _ => {}
                                    }
                                    playlist = PianoListAppend(
                                        if playlist.is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*playlist).head
                                        },
                                        &mut (*song).head,
                                    ) as *mut PianoSong_t;
                                }
                                i_1 += 1;
                                i_1;
                            }
                            match current_block {
                                9169893888141833765 => {}
                                _ => {
                                    (*reqData_1).retPlaylist = playlist;
                                }
                            }
                        }
                    }
                    6450597802325118133 => {
                        let mut stations: *mut json_object = 0 as *mut json_object;
                        let mut mix: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"stations\0" as *const u8 as *const libc::c_char,
                            &mut stations,
                        ) == 0)
                        {
                            let mut i: libc::c_int = 0 as libc::c_int;
                            while (i as libc::c_ulong)
                                < json_object_array_length(stations)
                            {
                                let mut tmpStation: *mut PianoStation_t = 0
                                    as *mut PianoStation_t;
                                let mut s: *mut json_object = json_object_array_get_idx(
                                    stations,
                                    i as size_t,
                                );
                                tmpStation = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                ) as *mut PianoStation_t;
                                if tmpStation.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                PianoJsonParseStation(s, tmpStation);
                                if (*tmpStation).isQuickMix != 0 {
                                    json_object_object_get_ex(
                                        s,
                                        b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                        &mut mix,
                                    );
                                }
                                (*ph)
                                    .stations = PianoListAppend(
                                    if ((*ph).stations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).stations).head
                                    },
                                    &mut (*tmpStation).head,
                                ) as *mut PianoStation_t;
                                i += 1;
                                i;
                            }
                            if !mix.is_null() {
                                let mut curStation: *mut PianoStation_t = (*ph).stations;
                                while !curStation.is_null() {
                                    let mut i_0: libc::c_int = 0 as libc::c_int;
                                    while (i_0 as libc::c_ulong) < json_object_array_length(mix)
                                    {
                                        let mut id: *mut json_object = json_object_array_get_idx(
                                            mix,
                                            i_0 as size_t,
                                        );
                                        if strcmp(json_object_get_string(id), (*curStation).id)
                                            == 0 as libc::c_int
                                        {
                                            (*curStation)
                                                .useQuickMix = 1 as libc::c_int as libc::c_char;
                                        }
                                        i_0 += 1;
                                        i_0;
                                    }
                                    curStation = (*curStation).head.next as *mut libc::c_void
                                        as *mut PianoStation_t;
                                }
                            }
                        }
                    }
                    12039483399334584727 => {
                        let mut reqData_0: *mut PianoRequestDataLogin_t = (*req).data
                            as *mut PianoRequestDataLogin_t;
                        match (*reqData_0).step as libc::c_int {
                            0 => {
                                let mut jsonTimestamp: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    result,
                                    b"syncTime\0" as *const u8 as *const libc::c_char,
                                    &mut jsonTimestamp,
                                ) == 0
                                {
                                    ret = PIANO_RET_INVALID_RESPONSE;
                                } else {
                                    let cryptedTimestamp: *const libc::c_char = json_object_get_string(
                                        jsonTimestamp,
                                    );
                                    let realTimestamp: time_t = time(0 as *mut time_t);
                                    let mut decryptedTimestamp: *mut libc::c_char = 0
                                        as *mut libc::c_char;
                                    let mut decryptedSize: size_t = 0;
                                    ret = PIANO_RET_ERR;
                                    decryptedTimestamp = PianoDecryptString(
                                        (*ph).partner.in_0,
                                        cryptedTimestamp,
                                        &mut decryptedSize,
                                    );
                                    if !decryptedTimestamp.is_null()
                                        && decryptedSize > 4 as libc::c_int as libc::c_ulong
                                    {
                                        let timestamp: libc::c_ulong = strtoul(
                                            decryptedTimestamp.offset(4 as libc::c_int as isize),
                                            0 as *mut *mut libc::c_char,
                                            0 as libc::c_int,
                                        );
                                        (*ph)
                                            .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                            as libc::c_int;
                                        ret = PIANO_RET_CONTINUE_REQUEST;
                                    }
                                    free(decryptedTimestamp as *mut libc::c_void);
                                    (*ph)
                                        .partner
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    let mut partnerId: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        result,
                                        b"partnerId\0" as *const u8 as *const libc::c_char,
                                        &mut partnerId,
                                    ) == 0
                                    {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        (*ph)
                                            .partner
                                            .id = json_object_get_int(partnerId) as libc::c_uint;
                                        (*reqData_0).step = ((*reqData_0).step).wrapping_add(1);
                                        (*reqData_0).step;
                                    }
                                }
                            }
                            1 => {
                                if !((*ph).user.listenerId).is_null() {
                                    PianoDestroyUserInfo(&mut (*ph).user);
                                }
                                (*ph)
                                    .user
                                    .listenerId = PianoJsonStrdup(
                                    result,
                                    b"userId\0" as *const u8 as *const libc::c_char,
                                );
                                (*ph)
                                    .user
                                    .authToken = PianoJsonStrdup(
                                    result,
                                    b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                );
                            }
                            _ => {}
                        }
                    }
                    10223170376184624358 => {
                        let mut reqData_8: *mut PianoRequestDataSetStationMode_t = (*req)
                            .data as *mut PianoRequestDataSetStationMode_t;
                        let mut active_0: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode_0: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode_0,
                        ) != 0
                        {
                            active_0 = json_object_get_int(activeMode_0);
                        }
                        if active_0 as libc::c_uint != (*reqData_8).id {
                            return PIANO_RET_ERR;
                        }
                    }
                    _ => {
                        let mut reqData_7: *mut PianoRequestDataGetStationModes_t = (*req)
                            .data as *mut PianoRequestDataGetStationModes_t;
                        let mut active: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode,
                        ) != 0
                        {
                            active = json_object_get_int(activeMode);
                        }
                        let mut availableModes: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"availableModes\0" as *const u8 as *const libc::c_char,
                            &mut availableModes,
                        ) != 0
                        {
                            let mut i_10: libc::c_int = 0 as libc::c_int;
                            while (i_10 as libc::c_ulong)
                                < json_object_array_length(availableModes)
                            {
                                let mut val_0: *mut json_object = json_object_array_get_idx(
                                    availableModes,
                                    i_10 as size_t,
                                );
                                let mut mode: *mut PianoStationMode_t = 0
                                    as *mut PianoStationMode_t;
                                mode = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                ) as *mut PianoStationMode_t;
                                if mode.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                let mut modeId: *mut json_object = 0 as *mut json_object;
                                if json_object_object_get_ex(
                                    val_0,
                                    b"modeId\0" as *const u8 as *const libc::c_char,
                                    &mut modeId,
                                ) != 0
                                {
                                    (*mode).id = json_object_get_int(modeId);
                                    (*mode)
                                        .name = PianoJsonStrdup(
                                        val_0,
                                        b"modeName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .description = PianoJsonStrdup(
                                        val_0,
                                        b"modeDescription\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .isAlgorithmic = getBoolDefault(
                                        val_0,
                                        b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode)
                                        .isTakeover = getBoolDefault(
                                        val_0,
                                        b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode).active = active == (*mode).id;
                                }
                                (*reqData_7)
                                    .retModes = PianoListAppend(
                                    if ((*reqData_7).retModes).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*reqData_7).retModes).head
                                    },
                                    &mut (*mode).head,
                                ) as *mut PianoStationMode_t;
                                i_10 += 1;
                                i_10;
                            }
                        }
                    }
                }
            }
            10 => {
                current_block = 11235674318412060590;
                match current_block {
                    14870924983410776565 => {}
                    4367030874028593650 => {
                        let mut reqData_6: *mut PianoRequestDataGetStationInfo_t = (*req)
                            .data as *mut PianoRequestDataGetStationInfo_t;
                        let mut info: *mut PianoStationInfo_t = 0
                            as *mut PianoStationInfo_t;
                        info = &mut (*reqData_6).info;
                        let mut music: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"music\0" as *const u8 as *const libc::c_char,
                            &mut music,
                        ) != 0
                        {
                            let mut songs_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs_0,
                            ) != 0
                            {
                                let mut i_6: libc::c_int = 0 as libc::c_int;
                                while (i_6 as libc::c_ulong)
                                    < json_object_array_length(songs_0)
                                {
                                    let mut s_4: *mut json_object = json_object_array_get_idx(
                                        songs_0,
                                        i_6 as size_t,
                                    );
                                    let mut seedSong: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                    seedSong = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    ) as *mut PianoSong_t;
                                    if seedSong.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedSong)
                                        .title = PianoJsonStrdup(
                                        s_4,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .artist = PianoJsonStrdup(
                                        s_4,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .seedId = PianoJsonStrdup(
                                        s_4,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .songSeeds = PianoListAppend(
                                        if ((*info).songSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).songSeeds).head
                                        },
                                        &mut (*seedSong).head,
                                    ) as *mut PianoSong_t;
                                    i_6 += 1;
                                    i_6;
                                }
                            }
                            let mut artists_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists_0,
                            ) != 0
                            {
                                let mut i_7: libc::c_int = 0 as libc::c_int;
                                while (i_7 as libc::c_ulong)
                                    < json_object_array_length(artists_0)
                                {
                                    let mut a_0: *mut json_object = json_object_array_get_idx(
                                        artists_0,
                                        i_7 as size_t,
                                    );
                                    let mut seedArtist: *mut PianoArtist_t = 0
                                        as *mut PianoArtist_t;
                                    seedArtist = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    ) as *mut PianoArtist_t;
                                    if seedArtist.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedArtist)
                                        .name = PianoJsonStrdup(
                                        a_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedArtist)
                                        .seedId = PianoJsonStrdup(
                                        a_0,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .artistSeeds = PianoListAppend(
                                        if ((*info).artistSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).artistSeeds).head
                                        },
                                        &mut (*seedArtist).head,
                                    ) as *mut PianoArtist_t;
                                    i_7 += 1;
                                    i_7;
                                }
                            }
                        }
                        let mut feedback: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"feedback\0" as *const u8 as *const libc::c_char,
                            &mut feedback,
                        ) != 0
                        {
                            static mut keys: [*const libc::c_char; 2] = [
                                b"thumbsUp\0" as *const u8 as *const libc::c_char,
                                b"thumbsDown\0" as *const u8 as *const libc::c_char,
                            ];
                            let mut i_8: size_t = 0 as libc::c_int as size_t;
                            while i_8
                                < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                    as libc::c_ulong)
                                    .wrapping_div(
                                        ::std::mem::size_of::<*const libc::c_char>()
                                            as libc::c_ulong,
                                    )
                            {
                                let mut val: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    feedback,
                                    keys[i_8 as usize],
                                    &mut val,
                                ) == 0)
                                {
                                    let mut i_9: libc::c_int = 0 as libc::c_int;
                                    while (i_9 as libc::c_ulong) < json_object_array_length(val)
                                    {
                                        let mut s_5: *mut json_object = json_object_array_get_idx(
                                            val,
                                            i_9 as size_t,
                                        );
                                        let mut feedbackSong: *mut PianoSong_t = 0
                                            as *mut PianoSong_t;
                                        feedbackSong = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        ) as *mut PianoSong_t;
                                        if feedbackSong.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*feedbackSong)
                                            .title = PianoJsonStrdup(
                                            s_5,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .artist = PianoJsonStrdup(
                                            s_5,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .feedbackId = PianoJsonStrdup(
                                            s_5,
                                            b"feedbackId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .rating = (if getBoolDefault(
                                            s_5,
                                            b"isPositive\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        ) as libc::c_int != 0
                                        {
                                            PIANO_RATE_LOVE as libc::c_int
                                        } else {
                                            PIANO_RATE_BAN as libc::c_int
                                        }) as PianoSongRating_t;
                                        let mut v_0: *mut json_object = 0 as *mut json_object;
                                        (*feedbackSong)
                                            .length = (if json_object_object_get_ex(
                                            s_5,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v_0,
                                        ) != 0
                                        {
                                            json_object_get_int(v_0)
                                        } else {
                                            0 as libc::c_int
                                        }) as libc::c_uint;
                                        (*info)
                                            .feedback = PianoListAppend(
                                            if ((*info).feedback).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*info).feedback).head
                                            },
                                            &mut (*feedbackSong).head,
                                        ) as *mut PianoSong_t;
                                        i_9 += 1;
                                        i_9;
                                    }
                                }
                                i_8 = i_8.wrapping_add(1);
                                i_8;
                            }
                        }
                    }
                    11202235766349324107 => {
                        let settings: *mut PianoSettings_t = (*req).data
                            as *mut PianoSettings_t;
                        (*settings)
                            .explicitContentFilter = getBoolDefault(
                            result,
                            b"isExplicitContentFilterEnabled\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int != 0,
                        );
                        (*settings)
                            .username = PianoJsonStrdup(
                            result,
                            b"username\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    145651165234646754 => {
                        let mut reqData_5: *mut PianoRequestDataExplain_t = (*req).data
                            as *mut PianoRequestDataExplain_t;
                        let strSize: size_t = 768 as libc::c_int as size_t;
                        let mut explanations: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"explanations\0" as *const u8 as *const libc::c_char,
                            &mut explanations,
                        ) != 0
                        {
                            (*reqData_5)
                                .retExplain = malloc(
                                strSize
                                    .wrapping_mul(
                                        ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                    ),
                            ) as *mut libc::c_char;
                            strncpy(
                                (*reqData_5).retExplain,
                                b"We're playing this track because it features \0"
                                    as *const u8 as *const libc::c_char,
                                strSize,
                            );
                            let mut i_5: libc::c_int = 0 as libc::c_int;
                            while (i_5 as libc::c_ulong)
                                < json_object_array_length(explanations)
                            {
                                let mut e: *mut json_object = json_object_array_get_idx(
                                    explanations,
                                    i_5 as size_t,
                                );
                                let mut f: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    e,
                                    b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                    &mut f,
                                ) == 0)
                                {
                                    let mut s_3: *const libc::c_char = json_object_get_string(
                                        f,
                                    );
                                    PianoStrpcat((*reqData_5).retExplain, s_3, strSize);
                                    if (i_5 as libc::c_ulong)
                                        < (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b", \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else if i_5 as libc::c_ulong
                                        == (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b" and \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b".\0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    }
                                }
                                i_5 += 1;
                                i_5;
                            }
                        }
                    }
                    9240481512215375588 => {
                        let mut station_0: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*station_0).isCreator = 1 as libc::c_int as libc::c_char;
                    }
                    5908482871227205451 => {
                        let mut categories: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"categories\0" as *const u8 as *const libc::c_char,
                            &mut categories,
                        ) != 0
                        {
                            let mut i_4: libc::c_int = 0 as libc::c_int;
                            while (i_4 as libc::c_ulong)
                                < json_object_array_length(categories)
                            {
                                let mut c: *mut json_object = json_object_array_get_idx(
                                    categories,
                                    i_4 as size_t,
                                );
                                let mut tmpGenreCategory: *mut PianoGenreCategory_t = 0
                                    as *mut PianoGenreCategory_t;
                                tmpGenreCategory = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoGenreCategory_t>()
                                        as libc::c_ulong,
                                ) as *mut PianoGenreCategory_t;
                                if tmpGenreCategory.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*tmpGenreCategory)
                                    .name = PianoJsonStrdup(
                                    c,
                                    b"categoryName\0" as *const u8 as *const libc::c_char,
                                );
                                let mut stations_0: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    c,
                                    b"stations\0" as *const u8 as *const libc::c_char,
                                    &mut stations_0,
                                ) != 0
                                {
                                    let mut k_0: libc::c_int = 0 as libc::c_int;
                                    while (k_0 as libc::c_ulong)
                                        < json_object_array_length(stations_0)
                                    {
                                        let mut s_2: *mut json_object = json_object_array_get_idx(
                                            stations_0,
                                            k_0 as size_t,
                                        );
                                        let mut tmpGenre: *mut PianoGenre_t = 0
                                            as *mut PianoGenre_t;
                                        tmpGenre = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                        ) as *mut PianoGenre_t;
                                        if tmpGenre.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*tmpGenre)
                                            .name = PianoJsonStrdup(
                                            s_2,
                                            b"stationName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenre)
                                            .musicId = PianoJsonStrdup(
                                            s_2,
                                            b"stationToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenreCategory)
                                            .genres = PianoListAppend(
                                            if ((*tmpGenreCategory).genres).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*tmpGenreCategory).genres).head
                                            },
                                            &mut (*tmpGenre).head,
                                        ) as *mut PianoGenre_t;
                                        k_0 += 1;
                                        k_0;
                                    }
                                }
                                (*ph)
                                    .genreStations = PianoListAppend(
                                    if ((*ph).genreStations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).genreStations).head
                                    },
                                    &mut (*tmpGenreCategory).head,
                                ) as *mut PianoGenreCategory_t;
                                i_4 += 1;
                                i_4;
                            }
                        }
                    }
                    5260680050201874961 => {
                        let song_1: *mut PianoSong_t = (*req).data as *mut PianoSong_t;
                        (*song_1).rating = PIANO_RATE_TIRED;
                    }
                    11235674318412060590 => {
                        let mut tmpStation_0: *mut PianoStation_t = 0
                            as *mut PianoStation_t;
                        tmpStation_0 = calloc(
                            1 as libc::c_int as libc::c_ulong,
                            ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                        ) as *mut PianoStation_t;
                        if tmpStation_0.is_null() {
                            return PIANO_RET_OUT_OF_MEMORY;
                        }
                        PianoJsonParseStation(result, tmpStation_0);
                        let mut search: *mut PianoStation_t = PianoFindStationById(
                            (*ph).stations,
                            (*tmpStation_0).id,
                        );
                        if !search.is_null() {
                            (*ph)
                                .stations = PianoListDelete(
                                if ((*ph).stations).is_null() {
                                    0 as *mut PianoListHead_t
                                } else {
                                    &mut (*(*ph).stations).head
                                },
                                &mut (*search).head,
                            ) as *mut PianoStation_t;
                            PianoDestroyStation(search);
                            free(search as *mut libc::c_void);
                        }
                        (*ph)
                            .stations = PianoListAppend(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*tmpStation_0).head,
                        ) as *mut PianoStation_t;
                    }
                    10109057886293123569 => {
                        let mut reqData_4: *mut PianoRequestDataSearch_t = (*req).data
                            as *mut PianoRequestDataSearch_t;
                        let mut searchResult: *mut PianoSearchResult_t = 0
                            as *mut PianoSearchResult_t;
                        searchResult = &mut (*reqData_4).searchResult;
                        memset(
                            searchResult as *mut libc::c_void,
                            0 as libc::c_int,
                            ::std::mem::size_of::<PianoSearchResult_t>() as libc::c_ulong,
                        );
                        let mut artists: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"artists\0" as *const u8 as *const libc::c_char,
                            &mut artists,
                        ) != 0
                        {
                            let mut i_2: libc::c_int = 0 as libc::c_int;
                            while (i_2 as libc::c_ulong)
                                < json_object_array_length(artists)
                            {
                                let mut a: *mut json_object = json_object_array_get_idx(
                                    artists,
                                    i_2 as size_t,
                                );
                                let mut artist: *mut PianoArtist_t = 0
                                    as *mut PianoArtist_t;
                                artist = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                ) as *mut PianoArtist_t;
                                if artist.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*artist)
                                    .name = PianoJsonStrdup(
                                    a,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*artist)
                                    .musicId = PianoJsonStrdup(
                                    a,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .artists = PianoListAppend(
                                    if ((*searchResult).artists).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).artists).head
                                    },
                                    &mut (*artist).head,
                                ) as *mut PianoArtist_t;
                                i_2 += 1;
                                i_2;
                            }
                        }
                        let mut songs: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"songs\0" as *const u8 as *const libc::c_char,
                            &mut songs,
                        ) != 0
                        {
                            let mut i_3: libc::c_int = 0 as libc::c_int;
                            while (i_3 as libc::c_ulong)
                                < json_object_array_length(songs)
                            {
                                let mut s_1: *mut json_object = json_object_array_get_idx(
                                    songs,
                                    i_3 as size_t,
                                );
                                let mut song_0: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song_0 = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song_0.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*song_0)
                                    .title = PianoJsonStrdup(
                                    s_1,
                                    b"songName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .artist = PianoJsonStrdup(
                                    s_1,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .musicId = PianoJsonStrdup(
                                    s_1,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .songs = PianoListAppend(
                                    if ((*searchResult).songs).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).songs).head
                                    },
                                    &mut (*song_0).head,
                                ) as *mut PianoSong_t;
                                i_3 += 1;
                                i_3;
                            }
                        }
                    }
                    4983594971376015098 => {
                        let mut station: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*ph)
                            .stations = PianoListDelete(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*station).head,
                        ) as *mut PianoStation_t;
                        PianoDestroyStation(station);
                        free(station as *mut libc::c_void);
                    }
                    17372050596571538954 => {
                        let mut reqData_3: *mut PianoRequestDataRenameStation_t = (*req)
                            .data as *mut PianoRequestDataRenameStation_t;
                        free((*(*reqData_3).station).name as *mut libc::c_void);
                        (*(*reqData_3).station).name = strdup((*reqData_3).newName);
                    }
                    7297078374430259003 => {
                        let mut reqData_2: *mut PianoRequestDataRateSong_t = (*req).data
                            as *mut PianoRequestDataRateSong_t;
                        (*(*reqData_2).song).rating = (*reqData_2).rating;
                    }
                    17075014677070940716 => {
                        let mut reqData_1: *mut PianoRequestDataGetPlaylist_t = (*req)
                            .data as *mut PianoRequestDataGetPlaylist_t;
                        let mut playlist: *mut PianoSong_t = 0 as *mut PianoSong_t;
                        let mut items: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"items\0" as *const u8 as *const libc::c_char,
                            &mut items,
                        ) == 0)
                        {
                            let mut i_1: libc::c_int = 0 as libc::c_int;
                            loop {
                                if !((i_1 as libc::c_ulong)
                                    < json_object_array_length(items))
                                {
                                    current_block = 4488496028633655612;
                                    break;
                                }
                                let mut s_0: *mut json_object = json_object_array_get_idx(
                                    items,
                                    i_1 as size_t,
                                );
                                let mut song: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                if json_object_object_get_ex(
                                    s_0,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                    0 as *mut *mut json_object,
                                ) == 0
                                {
                                    free(song as *mut libc::c_void);
                                } else {
                                    static mut qualityMap: [*const libc::c_char; 4] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"lowQuality\0" as *const u8 as *const libc::c_char,
                                        b"mediumQuality\0" as *const u8 as *const libc::c_char,
                                        b"highQuality\0" as *const u8 as *const libc::c_char,
                                    ];
                                    static mut formatMap: [*const libc::c_char; 3] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"aacplus\0" as *const u8 as *const libc::c_char,
                                        b"mp3\0" as *const u8 as *const libc::c_char,
                                    ];
                                    let mut umap: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        s_0,
                                        b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                        &mut umap,
                                    ) != 0
                                    {
                                        let mut jsonEncoding: *mut json_object = 0
                                            as *mut json_object;
                                        let mut qmap: *mut json_object = 0 as *mut json_object;
                                        if json_object_object_get_ex(
                                            umap,
                                            qualityMap[(*reqData_1).quality as usize],
                                            &mut qmap,
                                        ) != 0
                                            && json_object_object_get_ex(
                                                qmap,
                                                b"encoding\0" as *const u8 as *const libc::c_char,
                                                &mut jsonEncoding,
                                            ) != 0
                                        {
                                            let mut encoding: *const libc::c_char = json_object_get_string(
                                                jsonEncoding,
                                            );
                                            let mut k: size_t = 0 as libc::c_int as size_t;
                                            while k
                                                < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                    as libc::c_ulong)
                                                    .wrapping_div(
                                                        ::std::mem::size_of::<*const libc::c_char>()
                                                            as libc::c_ulong,
                                                    )
                                            {
                                                if strcmp(formatMap[k as usize], encoding)
                                                    == 0 as libc::c_int
                                                {
                                                    (*song).audioFormat = k as PianoAudioFormat_t;
                                                    break;
                                                } else {
                                                    k = k.wrapping_add(1);
                                                    k;
                                                }
                                            }
                                            (*song)
                                                .audioUrl = PianoJsonStrdup(
                                                qmap,
                                                b"audioUrl\0" as *const u8 as *const libc::c_char,
                                            );
                                        } else {
                                            ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                            free(song as *mut libc::c_void);
                                            PianoDestroyPlaylist(playlist);
                                            current_block = 9169893888141833765;
                                            break;
                                        }
                                    }
                                    let mut v: *mut json_object = 0 as *mut json_object;
                                    (*song)
                                        .artist = PianoJsonStrdup(
                                        s_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .album = PianoJsonStrdup(
                                        s_0,
                                        b"albumName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .title = PianoJsonStrdup(
                                        s_0,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .trackToken = PianoJsonStrdup(
                                        s_0,
                                        b"trackToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .stationId = PianoJsonStrdup(
                                        s_0,
                                        b"stationId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .coverArt = PianoJsonStrdup(
                                        s_0,
                                        b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .detailUrl = PianoJsonStrdup(
                                        s_0,
                                        b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .fileGain = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackGain\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_double(v)
                                    } else {
                                        0.0f64
                                    }) as libc::c_float;
                                    (*song)
                                        .length = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackLength\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    }) as libc::c_uint;
                                    match if json_object_object_get_ex(
                                        s_0,
                                        b"songRating\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    } {
                                        1 => {
                                            (*song).rating = PIANO_RATE_LOVE;
                                        }
                                        _ => {}
                                    }
                                    playlist = PianoListAppend(
                                        if playlist.is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*playlist).head
                                        },
                                        &mut (*song).head,
                                    ) as *mut PianoSong_t;
                                }
                                i_1 += 1;
                                i_1;
                            }
                            match current_block {
                                9169893888141833765 => {}
                                _ => {
                                    (*reqData_1).retPlaylist = playlist;
                                }
                            }
                        }
                    }
                    6450597802325118133 => {
                        let mut stations: *mut json_object = 0 as *mut json_object;
                        let mut mix: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"stations\0" as *const u8 as *const libc::c_char,
                            &mut stations,
                        ) == 0)
                        {
                            let mut i: libc::c_int = 0 as libc::c_int;
                            while (i as libc::c_ulong)
                                < json_object_array_length(stations)
                            {
                                let mut tmpStation: *mut PianoStation_t = 0
                                    as *mut PianoStation_t;
                                let mut s: *mut json_object = json_object_array_get_idx(
                                    stations,
                                    i as size_t,
                                );
                                tmpStation = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                ) as *mut PianoStation_t;
                                if tmpStation.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                PianoJsonParseStation(s, tmpStation);
                                if (*tmpStation).isQuickMix != 0 {
                                    json_object_object_get_ex(
                                        s,
                                        b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                        &mut mix,
                                    );
                                }
                                (*ph)
                                    .stations = PianoListAppend(
                                    if ((*ph).stations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).stations).head
                                    },
                                    &mut (*tmpStation).head,
                                ) as *mut PianoStation_t;
                                i += 1;
                                i;
                            }
                            if !mix.is_null() {
                                let mut curStation: *mut PianoStation_t = (*ph).stations;
                                while !curStation.is_null() {
                                    let mut i_0: libc::c_int = 0 as libc::c_int;
                                    while (i_0 as libc::c_ulong) < json_object_array_length(mix)
                                    {
                                        let mut id: *mut json_object = json_object_array_get_idx(
                                            mix,
                                            i_0 as size_t,
                                        );
                                        if strcmp(json_object_get_string(id), (*curStation).id)
                                            == 0 as libc::c_int
                                        {
                                            (*curStation)
                                                .useQuickMix = 1 as libc::c_int as libc::c_char;
                                        }
                                        i_0 += 1;
                                        i_0;
                                    }
                                    curStation = (*curStation).head.next as *mut libc::c_void
                                        as *mut PianoStation_t;
                                }
                            }
                        }
                    }
                    12039483399334584727 => {
                        let mut reqData_0: *mut PianoRequestDataLogin_t = (*req).data
                            as *mut PianoRequestDataLogin_t;
                        match (*reqData_0).step as libc::c_int {
                            0 => {
                                let mut jsonTimestamp: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    result,
                                    b"syncTime\0" as *const u8 as *const libc::c_char,
                                    &mut jsonTimestamp,
                                ) == 0
                                {
                                    ret = PIANO_RET_INVALID_RESPONSE;
                                } else {
                                    let cryptedTimestamp: *const libc::c_char = json_object_get_string(
                                        jsonTimestamp,
                                    );
                                    let realTimestamp: time_t = time(0 as *mut time_t);
                                    let mut decryptedTimestamp: *mut libc::c_char = 0
                                        as *mut libc::c_char;
                                    let mut decryptedSize: size_t = 0;
                                    ret = PIANO_RET_ERR;
                                    decryptedTimestamp = PianoDecryptString(
                                        (*ph).partner.in_0,
                                        cryptedTimestamp,
                                        &mut decryptedSize,
                                    );
                                    if !decryptedTimestamp.is_null()
                                        && decryptedSize > 4 as libc::c_int as libc::c_ulong
                                    {
                                        let timestamp: libc::c_ulong = strtoul(
                                            decryptedTimestamp.offset(4 as libc::c_int as isize),
                                            0 as *mut *mut libc::c_char,
                                            0 as libc::c_int,
                                        );
                                        (*ph)
                                            .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                            as libc::c_int;
                                        ret = PIANO_RET_CONTINUE_REQUEST;
                                    }
                                    free(decryptedTimestamp as *mut libc::c_void);
                                    (*ph)
                                        .partner
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    let mut partnerId: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        result,
                                        b"partnerId\0" as *const u8 as *const libc::c_char,
                                        &mut partnerId,
                                    ) == 0
                                    {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        (*ph)
                                            .partner
                                            .id = json_object_get_int(partnerId) as libc::c_uint;
                                        (*reqData_0).step = ((*reqData_0).step).wrapping_add(1);
                                        (*reqData_0).step;
                                    }
                                }
                            }
                            1 => {
                                if !((*ph).user.listenerId).is_null() {
                                    PianoDestroyUserInfo(&mut (*ph).user);
                                }
                                (*ph)
                                    .user
                                    .listenerId = PianoJsonStrdup(
                                    result,
                                    b"userId\0" as *const u8 as *const libc::c_char,
                                );
                                (*ph)
                                    .user
                                    .authToken = PianoJsonStrdup(
                                    result,
                                    b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                );
                            }
                            _ => {}
                        }
                    }
                    10223170376184624358 => {
                        let mut reqData_8: *mut PianoRequestDataSetStationMode_t = (*req)
                            .data as *mut PianoRequestDataSetStationMode_t;
                        let mut active_0: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode_0: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode_0,
                        ) != 0
                        {
                            active_0 = json_object_get_int(activeMode_0);
                        }
                        if active_0 as libc::c_uint != (*reqData_8).id {
                            return PIANO_RET_ERR;
                        }
                    }
                    _ => {
                        let mut reqData_7: *mut PianoRequestDataGetStationModes_t = (*req)
                            .data as *mut PianoRequestDataGetStationModes_t;
                        let mut active: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode,
                        ) != 0
                        {
                            active = json_object_get_int(activeMode);
                        }
                        let mut availableModes: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"availableModes\0" as *const u8 as *const libc::c_char,
                            &mut availableModes,
                        ) != 0
                        {
                            let mut i_10: libc::c_int = 0 as libc::c_int;
                            while (i_10 as libc::c_ulong)
                                < json_object_array_length(availableModes)
                            {
                                let mut val_0: *mut json_object = json_object_array_get_idx(
                                    availableModes,
                                    i_10 as size_t,
                                );
                                let mut mode: *mut PianoStationMode_t = 0
                                    as *mut PianoStationMode_t;
                                mode = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                ) as *mut PianoStationMode_t;
                                if mode.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                let mut modeId: *mut json_object = 0 as *mut json_object;
                                if json_object_object_get_ex(
                                    val_0,
                                    b"modeId\0" as *const u8 as *const libc::c_char,
                                    &mut modeId,
                                ) != 0
                                {
                                    (*mode).id = json_object_get_int(modeId);
                                    (*mode)
                                        .name = PianoJsonStrdup(
                                        val_0,
                                        b"modeName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .description = PianoJsonStrdup(
                                        val_0,
                                        b"modeDescription\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .isAlgorithmic = getBoolDefault(
                                        val_0,
                                        b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode)
                                        .isTakeover = getBoolDefault(
                                        val_0,
                                        b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode).active = active == (*mode).id;
                                }
                                (*reqData_7)
                                    .retModes = PianoListAppend(
                                    if ((*reqData_7).retModes).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*reqData_7).retModes).head
                                    },
                                    &mut (*mode).head,
                                ) as *mut PianoStationMode_t;
                                i_10 += 1;
                                i_10;
                            }
                        }
                    }
                }
            }
            12 => {
                current_block = 5260680050201874961;
                match current_block {
                    14870924983410776565 => {}
                    4367030874028593650 => {
                        let mut reqData_6: *mut PianoRequestDataGetStationInfo_t = (*req)
                            .data as *mut PianoRequestDataGetStationInfo_t;
                        let mut info: *mut PianoStationInfo_t = 0
                            as *mut PianoStationInfo_t;
                        info = &mut (*reqData_6).info;
                        let mut music: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"music\0" as *const u8 as *const libc::c_char,
                            &mut music,
                        ) != 0
                        {
                            let mut songs_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs_0,
                            ) != 0
                            {
                                let mut i_6: libc::c_int = 0 as libc::c_int;
                                while (i_6 as libc::c_ulong)
                                    < json_object_array_length(songs_0)
                                {
                                    let mut s_4: *mut json_object = json_object_array_get_idx(
                                        songs_0,
                                        i_6 as size_t,
                                    );
                                    let mut seedSong: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                    seedSong = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    ) as *mut PianoSong_t;
                                    if seedSong.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedSong)
                                        .title = PianoJsonStrdup(
                                        s_4,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .artist = PianoJsonStrdup(
                                        s_4,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .seedId = PianoJsonStrdup(
                                        s_4,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .songSeeds = PianoListAppend(
                                        if ((*info).songSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).songSeeds).head
                                        },
                                        &mut (*seedSong).head,
                                    ) as *mut PianoSong_t;
                                    i_6 += 1;
                                    i_6;
                                }
                            }
                            let mut artists_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists_0,
                            ) != 0
                            {
                                let mut i_7: libc::c_int = 0 as libc::c_int;
                                while (i_7 as libc::c_ulong)
                                    < json_object_array_length(artists_0)
                                {
                                    let mut a_0: *mut json_object = json_object_array_get_idx(
                                        artists_0,
                                        i_7 as size_t,
                                    );
                                    let mut seedArtist: *mut PianoArtist_t = 0
                                        as *mut PianoArtist_t;
                                    seedArtist = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    ) as *mut PianoArtist_t;
                                    if seedArtist.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedArtist)
                                        .name = PianoJsonStrdup(
                                        a_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedArtist)
                                        .seedId = PianoJsonStrdup(
                                        a_0,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .artistSeeds = PianoListAppend(
                                        if ((*info).artistSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).artistSeeds).head
                                        },
                                        &mut (*seedArtist).head,
                                    ) as *mut PianoArtist_t;
                                    i_7 += 1;
                                    i_7;
                                }
                            }
                        }
                        let mut feedback: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"feedback\0" as *const u8 as *const libc::c_char,
                            &mut feedback,
                        ) != 0
                        {
                            static mut keys: [*const libc::c_char; 2] = [
                                b"thumbsUp\0" as *const u8 as *const libc::c_char,
                                b"thumbsDown\0" as *const u8 as *const libc::c_char,
                            ];
                            let mut i_8: size_t = 0 as libc::c_int as size_t;
                            while i_8
                                < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                    as libc::c_ulong)
                                    .wrapping_div(
                                        ::std::mem::size_of::<*const libc::c_char>()
                                            as libc::c_ulong,
                                    )
                            {
                                let mut val: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    feedback,
                                    keys[i_8 as usize],
                                    &mut val,
                                ) == 0)
                                {
                                    let mut i_9: libc::c_int = 0 as libc::c_int;
                                    while (i_9 as libc::c_ulong) < json_object_array_length(val)
                                    {
                                        let mut s_5: *mut json_object = json_object_array_get_idx(
                                            val,
                                            i_9 as size_t,
                                        );
                                        let mut feedbackSong: *mut PianoSong_t = 0
                                            as *mut PianoSong_t;
                                        feedbackSong = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        ) as *mut PianoSong_t;
                                        if feedbackSong.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*feedbackSong)
                                            .title = PianoJsonStrdup(
                                            s_5,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .artist = PianoJsonStrdup(
                                            s_5,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .feedbackId = PianoJsonStrdup(
                                            s_5,
                                            b"feedbackId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .rating = (if getBoolDefault(
                                            s_5,
                                            b"isPositive\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        ) as libc::c_int != 0
                                        {
                                            PIANO_RATE_LOVE as libc::c_int
                                        } else {
                                            PIANO_RATE_BAN as libc::c_int
                                        }) as PianoSongRating_t;
                                        let mut v_0: *mut json_object = 0 as *mut json_object;
                                        (*feedbackSong)
                                            .length = (if json_object_object_get_ex(
                                            s_5,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v_0,
                                        ) != 0
                                        {
                                            json_object_get_int(v_0)
                                        } else {
                                            0 as libc::c_int
                                        }) as libc::c_uint;
                                        (*info)
                                            .feedback = PianoListAppend(
                                            if ((*info).feedback).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*info).feedback).head
                                            },
                                            &mut (*feedbackSong).head,
                                        ) as *mut PianoSong_t;
                                        i_9 += 1;
                                        i_9;
                                    }
                                }
                                i_8 = i_8.wrapping_add(1);
                                i_8;
                            }
                        }
                    }
                    11202235766349324107 => {
                        let settings: *mut PianoSettings_t = (*req).data
                            as *mut PianoSettings_t;
                        (*settings)
                            .explicitContentFilter = getBoolDefault(
                            result,
                            b"isExplicitContentFilterEnabled\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int != 0,
                        );
                        (*settings)
                            .username = PianoJsonStrdup(
                            result,
                            b"username\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    145651165234646754 => {
                        let mut reqData_5: *mut PianoRequestDataExplain_t = (*req).data
                            as *mut PianoRequestDataExplain_t;
                        let strSize: size_t = 768 as libc::c_int as size_t;
                        let mut explanations: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"explanations\0" as *const u8 as *const libc::c_char,
                            &mut explanations,
                        ) != 0
                        {
                            (*reqData_5)
                                .retExplain = malloc(
                                strSize
                                    .wrapping_mul(
                                        ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                    ),
                            ) as *mut libc::c_char;
                            strncpy(
                                (*reqData_5).retExplain,
                                b"We're playing this track because it features \0"
                                    as *const u8 as *const libc::c_char,
                                strSize,
                            );
                            let mut i_5: libc::c_int = 0 as libc::c_int;
                            while (i_5 as libc::c_ulong)
                                < json_object_array_length(explanations)
                            {
                                let mut e: *mut json_object = json_object_array_get_idx(
                                    explanations,
                                    i_5 as size_t,
                                );
                                let mut f: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    e,
                                    b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                    &mut f,
                                ) == 0)
                                {
                                    let mut s_3: *const libc::c_char = json_object_get_string(
                                        f,
                                    );
                                    PianoStrpcat((*reqData_5).retExplain, s_3, strSize);
                                    if (i_5 as libc::c_ulong)
                                        < (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b", \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else if i_5 as libc::c_ulong
                                        == (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b" and \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b".\0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    }
                                }
                                i_5 += 1;
                                i_5;
                            }
                        }
                    }
                    9240481512215375588 => {
                        let mut station_0: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*station_0).isCreator = 1 as libc::c_int as libc::c_char;
                    }
                    5908482871227205451 => {
                        let mut categories: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"categories\0" as *const u8 as *const libc::c_char,
                            &mut categories,
                        ) != 0
                        {
                            let mut i_4: libc::c_int = 0 as libc::c_int;
                            while (i_4 as libc::c_ulong)
                                < json_object_array_length(categories)
                            {
                                let mut c: *mut json_object = json_object_array_get_idx(
                                    categories,
                                    i_4 as size_t,
                                );
                                let mut tmpGenreCategory: *mut PianoGenreCategory_t = 0
                                    as *mut PianoGenreCategory_t;
                                tmpGenreCategory = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoGenreCategory_t>()
                                        as libc::c_ulong,
                                ) as *mut PianoGenreCategory_t;
                                if tmpGenreCategory.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*tmpGenreCategory)
                                    .name = PianoJsonStrdup(
                                    c,
                                    b"categoryName\0" as *const u8 as *const libc::c_char,
                                );
                                let mut stations_0: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    c,
                                    b"stations\0" as *const u8 as *const libc::c_char,
                                    &mut stations_0,
                                ) != 0
                                {
                                    let mut k_0: libc::c_int = 0 as libc::c_int;
                                    while (k_0 as libc::c_ulong)
                                        < json_object_array_length(stations_0)
                                    {
                                        let mut s_2: *mut json_object = json_object_array_get_idx(
                                            stations_0,
                                            k_0 as size_t,
                                        );
                                        let mut tmpGenre: *mut PianoGenre_t = 0
                                            as *mut PianoGenre_t;
                                        tmpGenre = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                        ) as *mut PianoGenre_t;
                                        if tmpGenre.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*tmpGenre)
                                            .name = PianoJsonStrdup(
                                            s_2,
                                            b"stationName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenre)
                                            .musicId = PianoJsonStrdup(
                                            s_2,
                                            b"stationToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenreCategory)
                                            .genres = PianoListAppend(
                                            if ((*tmpGenreCategory).genres).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*tmpGenreCategory).genres).head
                                            },
                                            &mut (*tmpGenre).head,
                                        ) as *mut PianoGenre_t;
                                        k_0 += 1;
                                        k_0;
                                    }
                                }
                                (*ph)
                                    .genreStations = PianoListAppend(
                                    if ((*ph).genreStations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).genreStations).head
                                    },
                                    &mut (*tmpGenreCategory).head,
                                ) as *mut PianoGenreCategory_t;
                                i_4 += 1;
                                i_4;
                            }
                        }
                    }
                    5260680050201874961 => {
                        let song_1: *mut PianoSong_t = (*req).data as *mut PianoSong_t;
                        (*song_1).rating = PIANO_RATE_TIRED;
                    }
                    11235674318412060590 => {
                        let mut tmpStation_0: *mut PianoStation_t = 0
                            as *mut PianoStation_t;
                        tmpStation_0 = calloc(
                            1 as libc::c_int as libc::c_ulong,
                            ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                        ) as *mut PianoStation_t;
                        if tmpStation_0.is_null() {
                            return PIANO_RET_OUT_OF_MEMORY;
                        }
                        PianoJsonParseStation(result, tmpStation_0);
                        let mut search: *mut PianoStation_t = PianoFindStationById(
                            (*ph).stations,
                            (*tmpStation_0).id,
                        );
                        if !search.is_null() {
                            (*ph)
                                .stations = PianoListDelete(
                                if ((*ph).stations).is_null() {
                                    0 as *mut PianoListHead_t
                                } else {
                                    &mut (*(*ph).stations).head
                                },
                                &mut (*search).head,
                            ) as *mut PianoStation_t;
                            PianoDestroyStation(search);
                            free(search as *mut libc::c_void);
                        }
                        (*ph)
                            .stations = PianoListAppend(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*tmpStation_0).head,
                        ) as *mut PianoStation_t;
                    }
                    10109057886293123569 => {
                        let mut reqData_4: *mut PianoRequestDataSearch_t = (*req).data
                            as *mut PianoRequestDataSearch_t;
                        let mut searchResult: *mut PianoSearchResult_t = 0
                            as *mut PianoSearchResult_t;
                        searchResult = &mut (*reqData_4).searchResult;
                        memset(
                            searchResult as *mut libc::c_void,
                            0 as libc::c_int,
                            ::std::mem::size_of::<PianoSearchResult_t>() as libc::c_ulong,
                        );
                        let mut artists: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"artists\0" as *const u8 as *const libc::c_char,
                            &mut artists,
                        ) != 0
                        {
                            let mut i_2: libc::c_int = 0 as libc::c_int;
                            while (i_2 as libc::c_ulong)
                                < json_object_array_length(artists)
                            {
                                let mut a: *mut json_object = json_object_array_get_idx(
                                    artists,
                                    i_2 as size_t,
                                );
                                let mut artist: *mut PianoArtist_t = 0
                                    as *mut PianoArtist_t;
                                artist = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                ) as *mut PianoArtist_t;
                                if artist.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*artist)
                                    .name = PianoJsonStrdup(
                                    a,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*artist)
                                    .musicId = PianoJsonStrdup(
                                    a,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .artists = PianoListAppend(
                                    if ((*searchResult).artists).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).artists).head
                                    },
                                    &mut (*artist).head,
                                ) as *mut PianoArtist_t;
                                i_2 += 1;
                                i_2;
                            }
                        }
                        let mut songs: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"songs\0" as *const u8 as *const libc::c_char,
                            &mut songs,
                        ) != 0
                        {
                            let mut i_3: libc::c_int = 0 as libc::c_int;
                            while (i_3 as libc::c_ulong)
                                < json_object_array_length(songs)
                            {
                                let mut s_1: *mut json_object = json_object_array_get_idx(
                                    songs,
                                    i_3 as size_t,
                                );
                                let mut song_0: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song_0 = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song_0.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*song_0)
                                    .title = PianoJsonStrdup(
                                    s_1,
                                    b"songName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .artist = PianoJsonStrdup(
                                    s_1,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .musicId = PianoJsonStrdup(
                                    s_1,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .songs = PianoListAppend(
                                    if ((*searchResult).songs).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).songs).head
                                    },
                                    &mut (*song_0).head,
                                ) as *mut PianoSong_t;
                                i_3 += 1;
                                i_3;
                            }
                        }
                    }
                    4983594971376015098 => {
                        let mut station: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*ph)
                            .stations = PianoListDelete(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*station).head,
                        ) as *mut PianoStation_t;
                        PianoDestroyStation(station);
                        free(station as *mut libc::c_void);
                    }
                    17372050596571538954 => {
                        let mut reqData_3: *mut PianoRequestDataRenameStation_t = (*req)
                            .data as *mut PianoRequestDataRenameStation_t;
                        free((*(*reqData_3).station).name as *mut libc::c_void);
                        (*(*reqData_3).station).name = strdup((*reqData_3).newName);
                    }
                    7297078374430259003 => {
                        let mut reqData_2: *mut PianoRequestDataRateSong_t = (*req).data
                            as *mut PianoRequestDataRateSong_t;
                        (*(*reqData_2).song).rating = (*reqData_2).rating;
                    }
                    17075014677070940716 => {
                        let mut reqData_1: *mut PianoRequestDataGetPlaylist_t = (*req)
                            .data as *mut PianoRequestDataGetPlaylist_t;
                        let mut playlist: *mut PianoSong_t = 0 as *mut PianoSong_t;
                        let mut items: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"items\0" as *const u8 as *const libc::c_char,
                            &mut items,
                        ) == 0)
                        {
                            let mut i_1: libc::c_int = 0 as libc::c_int;
                            loop {
                                if !((i_1 as libc::c_ulong)
                                    < json_object_array_length(items))
                                {
                                    current_block = 4488496028633655612;
                                    break;
                                }
                                let mut s_0: *mut json_object = json_object_array_get_idx(
                                    items,
                                    i_1 as size_t,
                                );
                                let mut song: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                if json_object_object_get_ex(
                                    s_0,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                    0 as *mut *mut json_object,
                                ) == 0
                                {
                                    free(song as *mut libc::c_void);
                                } else {
                                    static mut qualityMap: [*const libc::c_char; 4] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"lowQuality\0" as *const u8 as *const libc::c_char,
                                        b"mediumQuality\0" as *const u8 as *const libc::c_char,
                                        b"highQuality\0" as *const u8 as *const libc::c_char,
                                    ];
                                    static mut formatMap: [*const libc::c_char; 3] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"aacplus\0" as *const u8 as *const libc::c_char,
                                        b"mp3\0" as *const u8 as *const libc::c_char,
                                    ];
                                    let mut umap: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        s_0,
                                        b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                        &mut umap,
                                    ) != 0
                                    {
                                        let mut jsonEncoding: *mut json_object = 0
                                            as *mut json_object;
                                        let mut qmap: *mut json_object = 0 as *mut json_object;
                                        if json_object_object_get_ex(
                                            umap,
                                            qualityMap[(*reqData_1).quality as usize],
                                            &mut qmap,
                                        ) != 0
                                            && json_object_object_get_ex(
                                                qmap,
                                                b"encoding\0" as *const u8 as *const libc::c_char,
                                                &mut jsonEncoding,
                                            ) != 0
                                        {
                                            let mut encoding: *const libc::c_char = json_object_get_string(
                                                jsonEncoding,
                                            );
                                            let mut k: size_t = 0 as libc::c_int as size_t;
                                            while k
                                                < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                    as libc::c_ulong)
                                                    .wrapping_div(
                                                        ::std::mem::size_of::<*const libc::c_char>()
                                                            as libc::c_ulong,
                                                    )
                                            {
                                                if strcmp(formatMap[k as usize], encoding)
                                                    == 0 as libc::c_int
                                                {
                                                    (*song).audioFormat = k as PianoAudioFormat_t;
                                                    break;
                                                } else {
                                                    k = k.wrapping_add(1);
                                                    k;
                                                }
                                            }
                                            (*song)
                                                .audioUrl = PianoJsonStrdup(
                                                qmap,
                                                b"audioUrl\0" as *const u8 as *const libc::c_char,
                                            );
                                        } else {
                                            ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                            free(song as *mut libc::c_void);
                                            PianoDestroyPlaylist(playlist);
                                            current_block = 9169893888141833765;
                                            break;
                                        }
                                    }
                                    let mut v: *mut json_object = 0 as *mut json_object;
                                    (*song)
                                        .artist = PianoJsonStrdup(
                                        s_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .album = PianoJsonStrdup(
                                        s_0,
                                        b"albumName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .title = PianoJsonStrdup(
                                        s_0,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .trackToken = PianoJsonStrdup(
                                        s_0,
                                        b"trackToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .stationId = PianoJsonStrdup(
                                        s_0,
                                        b"stationId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .coverArt = PianoJsonStrdup(
                                        s_0,
                                        b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .detailUrl = PianoJsonStrdup(
                                        s_0,
                                        b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .fileGain = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackGain\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_double(v)
                                    } else {
                                        0.0f64
                                    }) as libc::c_float;
                                    (*song)
                                        .length = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackLength\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    }) as libc::c_uint;
                                    match if json_object_object_get_ex(
                                        s_0,
                                        b"songRating\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    } {
                                        1 => {
                                            (*song).rating = PIANO_RATE_LOVE;
                                        }
                                        _ => {}
                                    }
                                    playlist = PianoListAppend(
                                        if playlist.is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*playlist).head
                                        },
                                        &mut (*song).head,
                                    ) as *mut PianoSong_t;
                                }
                                i_1 += 1;
                                i_1;
                            }
                            match current_block {
                                9169893888141833765 => {}
                                _ => {
                                    (*reqData_1).retPlaylist = playlist;
                                }
                            }
                        }
                    }
                    6450597802325118133 => {
                        let mut stations: *mut json_object = 0 as *mut json_object;
                        let mut mix: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"stations\0" as *const u8 as *const libc::c_char,
                            &mut stations,
                        ) == 0)
                        {
                            let mut i: libc::c_int = 0 as libc::c_int;
                            while (i as libc::c_ulong)
                                < json_object_array_length(stations)
                            {
                                let mut tmpStation: *mut PianoStation_t = 0
                                    as *mut PianoStation_t;
                                let mut s: *mut json_object = json_object_array_get_idx(
                                    stations,
                                    i as size_t,
                                );
                                tmpStation = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                ) as *mut PianoStation_t;
                                if tmpStation.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                PianoJsonParseStation(s, tmpStation);
                                if (*tmpStation).isQuickMix != 0 {
                                    json_object_object_get_ex(
                                        s,
                                        b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                        &mut mix,
                                    );
                                }
                                (*ph)
                                    .stations = PianoListAppend(
                                    if ((*ph).stations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).stations).head
                                    },
                                    &mut (*tmpStation).head,
                                ) as *mut PianoStation_t;
                                i += 1;
                                i;
                            }
                            if !mix.is_null() {
                                let mut curStation: *mut PianoStation_t = (*ph).stations;
                                while !curStation.is_null() {
                                    let mut i_0: libc::c_int = 0 as libc::c_int;
                                    while (i_0 as libc::c_ulong) < json_object_array_length(mix)
                                    {
                                        let mut id: *mut json_object = json_object_array_get_idx(
                                            mix,
                                            i_0 as size_t,
                                        );
                                        if strcmp(json_object_get_string(id), (*curStation).id)
                                            == 0 as libc::c_int
                                        {
                                            (*curStation)
                                                .useQuickMix = 1 as libc::c_int as libc::c_char;
                                        }
                                        i_0 += 1;
                                        i_0;
                                    }
                                    curStation = (*curStation).head.next as *mut libc::c_void
                                        as *mut PianoStation_t;
                                }
                            }
                        }
                    }
                    12039483399334584727 => {
                        let mut reqData_0: *mut PianoRequestDataLogin_t = (*req).data
                            as *mut PianoRequestDataLogin_t;
                        match (*reqData_0).step as libc::c_int {
                            0 => {
                                let mut jsonTimestamp: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    result,
                                    b"syncTime\0" as *const u8 as *const libc::c_char,
                                    &mut jsonTimestamp,
                                ) == 0
                                {
                                    ret = PIANO_RET_INVALID_RESPONSE;
                                } else {
                                    let cryptedTimestamp: *const libc::c_char = json_object_get_string(
                                        jsonTimestamp,
                                    );
                                    let realTimestamp: time_t = time(0 as *mut time_t);
                                    let mut decryptedTimestamp: *mut libc::c_char = 0
                                        as *mut libc::c_char;
                                    let mut decryptedSize: size_t = 0;
                                    ret = PIANO_RET_ERR;
                                    decryptedTimestamp = PianoDecryptString(
                                        (*ph).partner.in_0,
                                        cryptedTimestamp,
                                        &mut decryptedSize,
                                    );
                                    if !decryptedTimestamp.is_null()
                                        && decryptedSize > 4 as libc::c_int as libc::c_ulong
                                    {
                                        let timestamp: libc::c_ulong = strtoul(
                                            decryptedTimestamp.offset(4 as libc::c_int as isize),
                                            0 as *mut *mut libc::c_char,
                                            0 as libc::c_int,
                                        );
                                        (*ph)
                                            .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                            as libc::c_int;
                                        ret = PIANO_RET_CONTINUE_REQUEST;
                                    }
                                    free(decryptedTimestamp as *mut libc::c_void);
                                    (*ph)
                                        .partner
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    let mut partnerId: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        result,
                                        b"partnerId\0" as *const u8 as *const libc::c_char,
                                        &mut partnerId,
                                    ) == 0
                                    {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        (*ph)
                                            .partner
                                            .id = json_object_get_int(partnerId) as libc::c_uint;
                                        (*reqData_0).step = ((*reqData_0).step).wrapping_add(1);
                                        (*reqData_0).step;
                                    }
                                }
                            }
                            1 => {
                                if !((*ph).user.listenerId).is_null() {
                                    PianoDestroyUserInfo(&mut (*ph).user);
                                }
                                (*ph)
                                    .user
                                    .listenerId = PianoJsonStrdup(
                                    result,
                                    b"userId\0" as *const u8 as *const libc::c_char,
                                );
                                (*ph)
                                    .user
                                    .authToken = PianoJsonStrdup(
                                    result,
                                    b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                );
                            }
                            _ => {}
                        }
                    }
                    10223170376184624358 => {
                        let mut reqData_8: *mut PianoRequestDataSetStationMode_t = (*req)
                            .data as *mut PianoRequestDataSetStationMode_t;
                        let mut active_0: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode_0: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode_0,
                        ) != 0
                        {
                            active_0 = json_object_get_int(activeMode_0);
                        }
                        if active_0 as libc::c_uint != (*reqData_8).id {
                            return PIANO_RET_ERR;
                        }
                    }
                    _ => {
                        let mut reqData_7: *mut PianoRequestDataGetStationModes_t = (*req)
                            .data as *mut PianoRequestDataGetStationModes_t;
                        let mut active: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode,
                        ) != 0
                        {
                            active = json_object_get_int(activeMode);
                        }
                        let mut availableModes: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"availableModes\0" as *const u8 as *const libc::c_char,
                            &mut availableModes,
                        ) != 0
                        {
                            let mut i_10: libc::c_int = 0 as libc::c_int;
                            while (i_10 as libc::c_ulong)
                                < json_object_array_length(availableModes)
                            {
                                let mut val_0: *mut json_object = json_object_array_get_idx(
                                    availableModes,
                                    i_10 as size_t,
                                );
                                let mut mode: *mut PianoStationMode_t = 0
                                    as *mut PianoStationMode_t;
                                mode = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                ) as *mut PianoStationMode_t;
                                if mode.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                let mut modeId: *mut json_object = 0 as *mut json_object;
                                if json_object_object_get_ex(
                                    val_0,
                                    b"modeId\0" as *const u8 as *const libc::c_char,
                                    &mut modeId,
                                ) != 0
                                {
                                    (*mode).id = json_object_get_int(modeId);
                                    (*mode)
                                        .name = PianoJsonStrdup(
                                        val_0,
                                        b"modeName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .description = PianoJsonStrdup(
                                        val_0,
                                        b"modeDescription\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .isAlgorithmic = getBoolDefault(
                                        val_0,
                                        b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode)
                                        .isTakeover = getBoolDefault(
                                        val_0,
                                        b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode).active = active == (*mode).id;
                                }
                                (*reqData_7)
                                    .retModes = PianoListAppend(
                                    if ((*reqData_7).retModes).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*reqData_7).retModes).head
                                    },
                                    &mut (*mode).head,
                                ) as *mut PianoStationMode_t;
                                i_10 += 1;
                                i_10;
                            }
                        }
                    }
                }
            }
            14 => {
                current_block = 5908482871227205451;
                match current_block {
                    14870924983410776565 => {}
                    4367030874028593650 => {
                        let mut reqData_6: *mut PianoRequestDataGetStationInfo_t = (*req)
                            .data as *mut PianoRequestDataGetStationInfo_t;
                        let mut info: *mut PianoStationInfo_t = 0
                            as *mut PianoStationInfo_t;
                        info = &mut (*reqData_6).info;
                        let mut music: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"music\0" as *const u8 as *const libc::c_char,
                            &mut music,
                        ) != 0
                        {
                            let mut songs_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs_0,
                            ) != 0
                            {
                                let mut i_6: libc::c_int = 0 as libc::c_int;
                                while (i_6 as libc::c_ulong)
                                    < json_object_array_length(songs_0)
                                {
                                    let mut s_4: *mut json_object = json_object_array_get_idx(
                                        songs_0,
                                        i_6 as size_t,
                                    );
                                    let mut seedSong: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                    seedSong = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    ) as *mut PianoSong_t;
                                    if seedSong.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedSong)
                                        .title = PianoJsonStrdup(
                                        s_4,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .artist = PianoJsonStrdup(
                                        s_4,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .seedId = PianoJsonStrdup(
                                        s_4,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .songSeeds = PianoListAppend(
                                        if ((*info).songSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).songSeeds).head
                                        },
                                        &mut (*seedSong).head,
                                    ) as *mut PianoSong_t;
                                    i_6 += 1;
                                    i_6;
                                }
                            }
                            let mut artists_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists_0,
                            ) != 0
                            {
                                let mut i_7: libc::c_int = 0 as libc::c_int;
                                while (i_7 as libc::c_ulong)
                                    < json_object_array_length(artists_0)
                                {
                                    let mut a_0: *mut json_object = json_object_array_get_idx(
                                        artists_0,
                                        i_7 as size_t,
                                    );
                                    let mut seedArtist: *mut PianoArtist_t = 0
                                        as *mut PianoArtist_t;
                                    seedArtist = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    ) as *mut PianoArtist_t;
                                    if seedArtist.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedArtist)
                                        .name = PianoJsonStrdup(
                                        a_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedArtist)
                                        .seedId = PianoJsonStrdup(
                                        a_0,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .artistSeeds = PianoListAppend(
                                        if ((*info).artistSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).artistSeeds).head
                                        },
                                        &mut (*seedArtist).head,
                                    ) as *mut PianoArtist_t;
                                    i_7 += 1;
                                    i_7;
                                }
                            }
                        }
                        let mut feedback: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"feedback\0" as *const u8 as *const libc::c_char,
                            &mut feedback,
                        ) != 0
                        {
                            static mut keys: [*const libc::c_char; 2] = [
                                b"thumbsUp\0" as *const u8 as *const libc::c_char,
                                b"thumbsDown\0" as *const u8 as *const libc::c_char,
                            ];
                            let mut i_8: size_t = 0 as libc::c_int as size_t;
                            while i_8
                                < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                    as libc::c_ulong)
                                    .wrapping_div(
                                        ::std::mem::size_of::<*const libc::c_char>()
                                            as libc::c_ulong,
                                    )
                            {
                                let mut val: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    feedback,
                                    keys[i_8 as usize],
                                    &mut val,
                                ) == 0)
                                {
                                    let mut i_9: libc::c_int = 0 as libc::c_int;
                                    while (i_9 as libc::c_ulong) < json_object_array_length(val)
                                    {
                                        let mut s_5: *mut json_object = json_object_array_get_idx(
                                            val,
                                            i_9 as size_t,
                                        );
                                        let mut feedbackSong: *mut PianoSong_t = 0
                                            as *mut PianoSong_t;
                                        feedbackSong = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        ) as *mut PianoSong_t;
                                        if feedbackSong.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*feedbackSong)
                                            .title = PianoJsonStrdup(
                                            s_5,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .artist = PianoJsonStrdup(
                                            s_5,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .feedbackId = PianoJsonStrdup(
                                            s_5,
                                            b"feedbackId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .rating = (if getBoolDefault(
                                            s_5,
                                            b"isPositive\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        ) as libc::c_int != 0
                                        {
                                            PIANO_RATE_LOVE as libc::c_int
                                        } else {
                                            PIANO_RATE_BAN as libc::c_int
                                        }) as PianoSongRating_t;
                                        let mut v_0: *mut json_object = 0 as *mut json_object;
                                        (*feedbackSong)
                                            .length = (if json_object_object_get_ex(
                                            s_5,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v_0,
                                        ) != 0
                                        {
                                            json_object_get_int(v_0)
                                        } else {
                                            0 as libc::c_int
                                        }) as libc::c_uint;
                                        (*info)
                                            .feedback = PianoListAppend(
                                            if ((*info).feedback).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*info).feedback).head
                                            },
                                            &mut (*feedbackSong).head,
                                        ) as *mut PianoSong_t;
                                        i_9 += 1;
                                        i_9;
                                    }
                                }
                                i_8 = i_8.wrapping_add(1);
                                i_8;
                            }
                        }
                    }
                    11202235766349324107 => {
                        let settings: *mut PianoSettings_t = (*req).data
                            as *mut PianoSettings_t;
                        (*settings)
                            .explicitContentFilter = getBoolDefault(
                            result,
                            b"isExplicitContentFilterEnabled\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int != 0,
                        );
                        (*settings)
                            .username = PianoJsonStrdup(
                            result,
                            b"username\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    145651165234646754 => {
                        let mut reqData_5: *mut PianoRequestDataExplain_t = (*req).data
                            as *mut PianoRequestDataExplain_t;
                        let strSize: size_t = 768 as libc::c_int as size_t;
                        let mut explanations: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"explanations\0" as *const u8 as *const libc::c_char,
                            &mut explanations,
                        ) != 0
                        {
                            (*reqData_5)
                                .retExplain = malloc(
                                strSize
                                    .wrapping_mul(
                                        ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                    ),
                            ) as *mut libc::c_char;
                            strncpy(
                                (*reqData_5).retExplain,
                                b"We're playing this track because it features \0"
                                    as *const u8 as *const libc::c_char,
                                strSize,
                            );
                            let mut i_5: libc::c_int = 0 as libc::c_int;
                            while (i_5 as libc::c_ulong)
                                < json_object_array_length(explanations)
                            {
                                let mut e: *mut json_object = json_object_array_get_idx(
                                    explanations,
                                    i_5 as size_t,
                                );
                                let mut f: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    e,
                                    b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                    &mut f,
                                ) == 0)
                                {
                                    let mut s_3: *const libc::c_char = json_object_get_string(
                                        f,
                                    );
                                    PianoStrpcat((*reqData_5).retExplain, s_3, strSize);
                                    if (i_5 as libc::c_ulong)
                                        < (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b", \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else if i_5 as libc::c_ulong
                                        == (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b" and \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b".\0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    }
                                }
                                i_5 += 1;
                                i_5;
                            }
                        }
                    }
                    9240481512215375588 => {
                        let mut station_0: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*station_0).isCreator = 1 as libc::c_int as libc::c_char;
                    }
                    5908482871227205451 => {
                        let mut categories: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"categories\0" as *const u8 as *const libc::c_char,
                            &mut categories,
                        ) != 0
                        {
                            let mut i_4: libc::c_int = 0 as libc::c_int;
                            while (i_4 as libc::c_ulong)
                                < json_object_array_length(categories)
                            {
                                let mut c: *mut json_object = json_object_array_get_idx(
                                    categories,
                                    i_4 as size_t,
                                );
                                let mut tmpGenreCategory: *mut PianoGenreCategory_t = 0
                                    as *mut PianoGenreCategory_t;
                                tmpGenreCategory = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoGenreCategory_t>()
                                        as libc::c_ulong,
                                ) as *mut PianoGenreCategory_t;
                                if tmpGenreCategory.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*tmpGenreCategory)
                                    .name = PianoJsonStrdup(
                                    c,
                                    b"categoryName\0" as *const u8 as *const libc::c_char,
                                );
                                let mut stations_0: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    c,
                                    b"stations\0" as *const u8 as *const libc::c_char,
                                    &mut stations_0,
                                ) != 0
                                {
                                    let mut k_0: libc::c_int = 0 as libc::c_int;
                                    while (k_0 as libc::c_ulong)
                                        < json_object_array_length(stations_0)
                                    {
                                        let mut s_2: *mut json_object = json_object_array_get_idx(
                                            stations_0,
                                            k_0 as size_t,
                                        );
                                        let mut tmpGenre: *mut PianoGenre_t = 0
                                            as *mut PianoGenre_t;
                                        tmpGenre = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                        ) as *mut PianoGenre_t;
                                        if tmpGenre.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*tmpGenre)
                                            .name = PianoJsonStrdup(
                                            s_2,
                                            b"stationName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenre)
                                            .musicId = PianoJsonStrdup(
                                            s_2,
                                            b"stationToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenreCategory)
                                            .genres = PianoListAppend(
                                            if ((*tmpGenreCategory).genres).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*tmpGenreCategory).genres).head
                                            },
                                            &mut (*tmpGenre).head,
                                        ) as *mut PianoGenre_t;
                                        k_0 += 1;
                                        k_0;
                                    }
                                }
                                (*ph)
                                    .genreStations = PianoListAppend(
                                    if ((*ph).genreStations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).genreStations).head
                                    },
                                    &mut (*tmpGenreCategory).head,
                                ) as *mut PianoGenreCategory_t;
                                i_4 += 1;
                                i_4;
                            }
                        }
                    }
                    5260680050201874961 => {
                        let song_1: *mut PianoSong_t = (*req).data as *mut PianoSong_t;
                        (*song_1).rating = PIANO_RATE_TIRED;
                    }
                    11235674318412060590 => {
                        let mut tmpStation_0: *mut PianoStation_t = 0
                            as *mut PianoStation_t;
                        tmpStation_0 = calloc(
                            1 as libc::c_int as libc::c_ulong,
                            ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                        ) as *mut PianoStation_t;
                        if tmpStation_0.is_null() {
                            return PIANO_RET_OUT_OF_MEMORY;
                        }
                        PianoJsonParseStation(result, tmpStation_0);
                        let mut search: *mut PianoStation_t = PianoFindStationById(
                            (*ph).stations,
                            (*tmpStation_0).id,
                        );
                        if !search.is_null() {
                            (*ph)
                                .stations = PianoListDelete(
                                if ((*ph).stations).is_null() {
                                    0 as *mut PianoListHead_t
                                } else {
                                    &mut (*(*ph).stations).head
                                },
                                &mut (*search).head,
                            ) as *mut PianoStation_t;
                            PianoDestroyStation(search);
                            free(search as *mut libc::c_void);
                        }
                        (*ph)
                            .stations = PianoListAppend(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*tmpStation_0).head,
                        ) as *mut PianoStation_t;
                    }
                    10109057886293123569 => {
                        let mut reqData_4: *mut PianoRequestDataSearch_t = (*req).data
                            as *mut PianoRequestDataSearch_t;
                        let mut searchResult: *mut PianoSearchResult_t = 0
                            as *mut PianoSearchResult_t;
                        searchResult = &mut (*reqData_4).searchResult;
                        memset(
                            searchResult as *mut libc::c_void,
                            0 as libc::c_int,
                            ::std::mem::size_of::<PianoSearchResult_t>() as libc::c_ulong,
                        );
                        let mut artists: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"artists\0" as *const u8 as *const libc::c_char,
                            &mut artists,
                        ) != 0
                        {
                            let mut i_2: libc::c_int = 0 as libc::c_int;
                            while (i_2 as libc::c_ulong)
                                < json_object_array_length(artists)
                            {
                                let mut a: *mut json_object = json_object_array_get_idx(
                                    artists,
                                    i_2 as size_t,
                                );
                                let mut artist: *mut PianoArtist_t = 0
                                    as *mut PianoArtist_t;
                                artist = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                ) as *mut PianoArtist_t;
                                if artist.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*artist)
                                    .name = PianoJsonStrdup(
                                    a,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*artist)
                                    .musicId = PianoJsonStrdup(
                                    a,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .artists = PianoListAppend(
                                    if ((*searchResult).artists).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).artists).head
                                    },
                                    &mut (*artist).head,
                                ) as *mut PianoArtist_t;
                                i_2 += 1;
                                i_2;
                            }
                        }
                        let mut songs: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"songs\0" as *const u8 as *const libc::c_char,
                            &mut songs,
                        ) != 0
                        {
                            let mut i_3: libc::c_int = 0 as libc::c_int;
                            while (i_3 as libc::c_ulong)
                                < json_object_array_length(songs)
                            {
                                let mut s_1: *mut json_object = json_object_array_get_idx(
                                    songs,
                                    i_3 as size_t,
                                );
                                let mut song_0: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song_0 = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song_0.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*song_0)
                                    .title = PianoJsonStrdup(
                                    s_1,
                                    b"songName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .artist = PianoJsonStrdup(
                                    s_1,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .musicId = PianoJsonStrdup(
                                    s_1,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .songs = PianoListAppend(
                                    if ((*searchResult).songs).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).songs).head
                                    },
                                    &mut (*song_0).head,
                                ) as *mut PianoSong_t;
                                i_3 += 1;
                                i_3;
                            }
                        }
                    }
                    4983594971376015098 => {
                        let mut station: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*ph)
                            .stations = PianoListDelete(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*station).head,
                        ) as *mut PianoStation_t;
                        PianoDestroyStation(station);
                        free(station as *mut libc::c_void);
                    }
                    17372050596571538954 => {
                        let mut reqData_3: *mut PianoRequestDataRenameStation_t = (*req)
                            .data as *mut PianoRequestDataRenameStation_t;
                        free((*(*reqData_3).station).name as *mut libc::c_void);
                        (*(*reqData_3).station).name = strdup((*reqData_3).newName);
                    }
                    7297078374430259003 => {
                        let mut reqData_2: *mut PianoRequestDataRateSong_t = (*req).data
                            as *mut PianoRequestDataRateSong_t;
                        (*(*reqData_2).song).rating = (*reqData_2).rating;
                    }
                    17075014677070940716 => {
                        let mut reqData_1: *mut PianoRequestDataGetPlaylist_t = (*req)
                            .data as *mut PianoRequestDataGetPlaylist_t;
                        let mut playlist: *mut PianoSong_t = 0 as *mut PianoSong_t;
                        let mut items: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"items\0" as *const u8 as *const libc::c_char,
                            &mut items,
                        ) == 0)
                        {
                            let mut i_1: libc::c_int = 0 as libc::c_int;
                            loop {
                                if !((i_1 as libc::c_ulong)
                                    < json_object_array_length(items))
                                {
                                    current_block = 4488496028633655612;
                                    break;
                                }
                                let mut s_0: *mut json_object = json_object_array_get_idx(
                                    items,
                                    i_1 as size_t,
                                );
                                let mut song: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                if json_object_object_get_ex(
                                    s_0,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                    0 as *mut *mut json_object,
                                ) == 0
                                {
                                    free(song as *mut libc::c_void);
                                } else {
                                    static mut qualityMap: [*const libc::c_char; 4] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"lowQuality\0" as *const u8 as *const libc::c_char,
                                        b"mediumQuality\0" as *const u8 as *const libc::c_char,
                                        b"highQuality\0" as *const u8 as *const libc::c_char,
                                    ];
                                    static mut formatMap: [*const libc::c_char; 3] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"aacplus\0" as *const u8 as *const libc::c_char,
                                        b"mp3\0" as *const u8 as *const libc::c_char,
                                    ];
                                    let mut umap: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        s_0,
                                        b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                        &mut umap,
                                    ) != 0
                                    {
                                        let mut jsonEncoding: *mut json_object = 0
                                            as *mut json_object;
                                        let mut qmap: *mut json_object = 0 as *mut json_object;
                                        if json_object_object_get_ex(
                                            umap,
                                            qualityMap[(*reqData_1).quality as usize],
                                            &mut qmap,
                                        ) != 0
                                            && json_object_object_get_ex(
                                                qmap,
                                                b"encoding\0" as *const u8 as *const libc::c_char,
                                                &mut jsonEncoding,
                                            ) != 0
                                        {
                                            let mut encoding: *const libc::c_char = json_object_get_string(
                                                jsonEncoding,
                                            );
                                            let mut k: size_t = 0 as libc::c_int as size_t;
                                            while k
                                                < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                    as libc::c_ulong)
                                                    .wrapping_div(
                                                        ::std::mem::size_of::<*const libc::c_char>()
                                                            as libc::c_ulong,
                                                    )
                                            {
                                                if strcmp(formatMap[k as usize], encoding)
                                                    == 0 as libc::c_int
                                                {
                                                    (*song).audioFormat = k as PianoAudioFormat_t;
                                                    break;
                                                } else {
                                                    k = k.wrapping_add(1);
                                                    k;
                                                }
                                            }
                                            (*song)
                                                .audioUrl = PianoJsonStrdup(
                                                qmap,
                                                b"audioUrl\0" as *const u8 as *const libc::c_char,
                                            );
                                        } else {
                                            ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                            free(song as *mut libc::c_void);
                                            PianoDestroyPlaylist(playlist);
                                            current_block = 9169893888141833765;
                                            break;
                                        }
                                    }
                                    let mut v: *mut json_object = 0 as *mut json_object;
                                    (*song)
                                        .artist = PianoJsonStrdup(
                                        s_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .album = PianoJsonStrdup(
                                        s_0,
                                        b"albumName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .title = PianoJsonStrdup(
                                        s_0,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .trackToken = PianoJsonStrdup(
                                        s_0,
                                        b"trackToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .stationId = PianoJsonStrdup(
                                        s_0,
                                        b"stationId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .coverArt = PianoJsonStrdup(
                                        s_0,
                                        b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .detailUrl = PianoJsonStrdup(
                                        s_0,
                                        b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .fileGain = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackGain\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_double(v)
                                    } else {
                                        0.0f64
                                    }) as libc::c_float;
                                    (*song)
                                        .length = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackLength\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    }) as libc::c_uint;
                                    match if json_object_object_get_ex(
                                        s_0,
                                        b"songRating\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    } {
                                        1 => {
                                            (*song).rating = PIANO_RATE_LOVE;
                                        }
                                        _ => {}
                                    }
                                    playlist = PianoListAppend(
                                        if playlist.is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*playlist).head
                                        },
                                        &mut (*song).head,
                                    ) as *mut PianoSong_t;
                                }
                                i_1 += 1;
                                i_1;
                            }
                            match current_block {
                                9169893888141833765 => {}
                                _ => {
                                    (*reqData_1).retPlaylist = playlist;
                                }
                            }
                        }
                    }
                    6450597802325118133 => {
                        let mut stations: *mut json_object = 0 as *mut json_object;
                        let mut mix: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"stations\0" as *const u8 as *const libc::c_char,
                            &mut stations,
                        ) == 0)
                        {
                            let mut i: libc::c_int = 0 as libc::c_int;
                            while (i as libc::c_ulong)
                                < json_object_array_length(stations)
                            {
                                let mut tmpStation: *mut PianoStation_t = 0
                                    as *mut PianoStation_t;
                                let mut s: *mut json_object = json_object_array_get_idx(
                                    stations,
                                    i as size_t,
                                );
                                tmpStation = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                ) as *mut PianoStation_t;
                                if tmpStation.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                PianoJsonParseStation(s, tmpStation);
                                if (*tmpStation).isQuickMix != 0 {
                                    json_object_object_get_ex(
                                        s,
                                        b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                        &mut mix,
                                    );
                                }
                                (*ph)
                                    .stations = PianoListAppend(
                                    if ((*ph).stations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).stations).head
                                    },
                                    &mut (*tmpStation).head,
                                ) as *mut PianoStation_t;
                                i += 1;
                                i;
                            }
                            if !mix.is_null() {
                                let mut curStation: *mut PianoStation_t = (*ph).stations;
                                while !curStation.is_null() {
                                    let mut i_0: libc::c_int = 0 as libc::c_int;
                                    while (i_0 as libc::c_ulong) < json_object_array_length(mix)
                                    {
                                        let mut id: *mut json_object = json_object_array_get_idx(
                                            mix,
                                            i_0 as size_t,
                                        );
                                        if strcmp(json_object_get_string(id), (*curStation).id)
                                            == 0 as libc::c_int
                                        {
                                            (*curStation)
                                                .useQuickMix = 1 as libc::c_int as libc::c_char;
                                        }
                                        i_0 += 1;
                                        i_0;
                                    }
                                    curStation = (*curStation).head.next as *mut libc::c_void
                                        as *mut PianoStation_t;
                                }
                            }
                        }
                    }
                    12039483399334584727 => {
                        let mut reqData_0: *mut PianoRequestDataLogin_t = (*req).data
                            as *mut PianoRequestDataLogin_t;
                        match (*reqData_0).step as libc::c_int {
                            0 => {
                                let mut jsonTimestamp: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    result,
                                    b"syncTime\0" as *const u8 as *const libc::c_char,
                                    &mut jsonTimestamp,
                                ) == 0
                                {
                                    ret = PIANO_RET_INVALID_RESPONSE;
                                } else {
                                    let cryptedTimestamp: *const libc::c_char = json_object_get_string(
                                        jsonTimestamp,
                                    );
                                    let realTimestamp: time_t = time(0 as *mut time_t);
                                    let mut decryptedTimestamp: *mut libc::c_char = 0
                                        as *mut libc::c_char;
                                    let mut decryptedSize: size_t = 0;
                                    ret = PIANO_RET_ERR;
                                    decryptedTimestamp = PianoDecryptString(
                                        (*ph).partner.in_0,
                                        cryptedTimestamp,
                                        &mut decryptedSize,
                                    );
                                    if !decryptedTimestamp.is_null()
                                        && decryptedSize > 4 as libc::c_int as libc::c_ulong
                                    {
                                        let timestamp: libc::c_ulong = strtoul(
                                            decryptedTimestamp.offset(4 as libc::c_int as isize),
                                            0 as *mut *mut libc::c_char,
                                            0 as libc::c_int,
                                        );
                                        (*ph)
                                            .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                            as libc::c_int;
                                        ret = PIANO_RET_CONTINUE_REQUEST;
                                    }
                                    free(decryptedTimestamp as *mut libc::c_void);
                                    (*ph)
                                        .partner
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    let mut partnerId: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        result,
                                        b"partnerId\0" as *const u8 as *const libc::c_char,
                                        &mut partnerId,
                                    ) == 0
                                    {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        (*ph)
                                            .partner
                                            .id = json_object_get_int(partnerId) as libc::c_uint;
                                        (*reqData_0).step = ((*reqData_0).step).wrapping_add(1);
                                        (*reqData_0).step;
                                    }
                                }
                            }
                            1 => {
                                if !((*ph).user.listenerId).is_null() {
                                    PianoDestroyUserInfo(&mut (*ph).user);
                                }
                                (*ph)
                                    .user
                                    .listenerId = PianoJsonStrdup(
                                    result,
                                    b"userId\0" as *const u8 as *const libc::c_char,
                                );
                                (*ph)
                                    .user
                                    .authToken = PianoJsonStrdup(
                                    result,
                                    b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                );
                            }
                            _ => {}
                        }
                    }
                    10223170376184624358 => {
                        let mut reqData_8: *mut PianoRequestDataSetStationMode_t = (*req)
                            .data as *mut PianoRequestDataSetStationMode_t;
                        let mut active_0: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode_0: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode_0,
                        ) != 0
                        {
                            active_0 = json_object_get_int(activeMode_0);
                        }
                        if active_0 as libc::c_uint != (*reqData_8).id {
                            return PIANO_RET_ERR;
                        }
                    }
                    _ => {
                        let mut reqData_7: *mut PianoRequestDataGetStationModes_t = (*req)
                            .data as *mut PianoRequestDataGetStationModes_t;
                        let mut active: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode,
                        ) != 0
                        {
                            active = json_object_get_int(activeMode);
                        }
                        let mut availableModes: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"availableModes\0" as *const u8 as *const libc::c_char,
                            &mut availableModes,
                        ) != 0
                        {
                            let mut i_10: libc::c_int = 0 as libc::c_int;
                            while (i_10 as libc::c_ulong)
                                < json_object_array_length(availableModes)
                            {
                                let mut val_0: *mut json_object = json_object_array_get_idx(
                                    availableModes,
                                    i_10 as size_t,
                                );
                                let mut mode: *mut PianoStationMode_t = 0
                                    as *mut PianoStationMode_t;
                                mode = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                ) as *mut PianoStationMode_t;
                                if mode.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                let mut modeId: *mut json_object = 0 as *mut json_object;
                                if json_object_object_get_ex(
                                    val_0,
                                    b"modeId\0" as *const u8 as *const libc::c_char,
                                    &mut modeId,
                                ) != 0
                                {
                                    (*mode).id = json_object_get_int(modeId);
                                    (*mode)
                                        .name = PianoJsonStrdup(
                                        val_0,
                                        b"modeName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .description = PianoJsonStrdup(
                                        val_0,
                                        b"modeDescription\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .isAlgorithmic = getBoolDefault(
                                        val_0,
                                        b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode)
                                        .isTakeover = getBoolDefault(
                                        val_0,
                                        b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode).active = active == (*mode).id;
                                }
                                (*reqData_7)
                                    .retModes = PianoListAppend(
                                    if ((*reqData_7).retModes).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*reqData_7).retModes).head
                                    },
                                    &mut (*mode).head,
                                ) as *mut PianoStationMode_t;
                                i_10 += 1;
                                i_10;
                            }
                        }
                    }
                }
            }
            15 => {
                current_block = 9240481512215375588;
                match current_block {
                    14870924983410776565 => {}
                    4367030874028593650 => {
                        let mut reqData_6: *mut PianoRequestDataGetStationInfo_t = (*req)
                            .data as *mut PianoRequestDataGetStationInfo_t;
                        let mut info: *mut PianoStationInfo_t = 0
                            as *mut PianoStationInfo_t;
                        info = &mut (*reqData_6).info;
                        let mut music: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"music\0" as *const u8 as *const libc::c_char,
                            &mut music,
                        ) != 0
                        {
                            let mut songs_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs_0,
                            ) != 0
                            {
                                let mut i_6: libc::c_int = 0 as libc::c_int;
                                while (i_6 as libc::c_ulong)
                                    < json_object_array_length(songs_0)
                                {
                                    let mut s_4: *mut json_object = json_object_array_get_idx(
                                        songs_0,
                                        i_6 as size_t,
                                    );
                                    let mut seedSong: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                    seedSong = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    ) as *mut PianoSong_t;
                                    if seedSong.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedSong)
                                        .title = PianoJsonStrdup(
                                        s_4,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .artist = PianoJsonStrdup(
                                        s_4,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .seedId = PianoJsonStrdup(
                                        s_4,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .songSeeds = PianoListAppend(
                                        if ((*info).songSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).songSeeds).head
                                        },
                                        &mut (*seedSong).head,
                                    ) as *mut PianoSong_t;
                                    i_6 += 1;
                                    i_6;
                                }
                            }
                            let mut artists_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists_0,
                            ) != 0
                            {
                                let mut i_7: libc::c_int = 0 as libc::c_int;
                                while (i_7 as libc::c_ulong)
                                    < json_object_array_length(artists_0)
                                {
                                    let mut a_0: *mut json_object = json_object_array_get_idx(
                                        artists_0,
                                        i_7 as size_t,
                                    );
                                    let mut seedArtist: *mut PianoArtist_t = 0
                                        as *mut PianoArtist_t;
                                    seedArtist = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    ) as *mut PianoArtist_t;
                                    if seedArtist.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedArtist)
                                        .name = PianoJsonStrdup(
                                        a_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedArtist)
                                        .seedId = PianoJsonStrdup(
                                        a_0,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .artistSeeds = PianoListAppend(
                                        if ((*info).artistSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).artistSeeds).head
                                        },
                                        &mut (*seedArtist).head,
                                    ) as *mut PianoArtist_t;
                                    i_7 += 1;
                                    i_7;
                                }
                            }
                        }
                        let mut feedback: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"feedback\0" as *const u8 as *const libc::c_char,
                            &mut feedback,
                        ) != 0
                        {
                            static mut keys: [*const libc::c_char; 2] = [
                                b"thumbsUp\0" as *const u8 as *const libc::c_char,
                                b"thumbsDown\0" as *const u8 as *const libc::c_char,
                            ];
                            let mut i_8: size_t = 0 as libc::c_int as size_t;
                            while i_8
                                < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                    as libc::c_ulong)
                                    .wrapping_div(
                                        ::std::mem::size_of::<*const libc::c_char>()
                                            as libc::c_ulong,
                                    )
                            {
                                let mut val: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    feedback,
                                    keys[i_8 as usize],
                                    &mut val,
                                ) == 0)
                                {
                                    let mut i_9: libc::c_int = 0 as libc::c_int;
                                    while (i_9 as libc::c_ulong) < json_object_array_length(val)
                                    {
                                        let mut s_5: *mut json_object = json_object_array_get_idx(
                                            val,
                                            i_9 as size_t,
                                        );
                                        let mut feedbackSong: *mut PianoSong_t = 0
                                            as *mut PianoSong_t;
                                        feedbackSong = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        ) as *mut PianoSong_t;
                                        if feedbackSong.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*feedbackSong)
                                            .title = PianoJsonStrdup(
                                            s_5,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .artist = PianoJsonStrdup(
                                            s_5,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .feedbackId = PianoJsonStrdup(
                                            s_5,
                                            b"feedbackId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .rating = (if getBoolDefault(
                                            s_5,
                                            b"isPositive\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        ) as libc::c_int != 0
                                        {
                                            PIANO_RATE_LOVE as libc::c_int
                                        } else {
                                            PIANO_RATE_BAN as libc::c_int
                                        }) as PianoSongRating_t;
                                        let mut v_0: *mut json_object = 0 as *mut json_object;
                                        (*feedbackSong)
                                            .length = (if json_object_object_get_ex(
                                            s_5,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v_0,
                                        ) != 0
                                        {
                                            json_object_get_int(v_0)
                                        } else {
                                            0 as libc::c_int
                                        }) as libc::c_uint;
                                        (*info)
                                            .feedback = PianoListAppend(
                                            if ((*info).feedback).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*info).feedback).head
                                            },
                                            &mut (*feedbackSong).head,
                                        ) as *mut PianoSong_t;
                                        i_9 += 1;
                                        i_9;
                                    }
                                }
                                i_8 = i_8.wrapping_add(1);
                                i_8;
                            }
                        }
                    }
                    11202235766349324107 => {
                        let settings: *mut PianoSettings_t = (*req).data
                            as *mut PianoSettings_t;
                        (*settings)
                            .explicitContentFilter = getBoolDefault(
                            result,
                            b"isExplicitContentFilterEnabled\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int != 0,
                        );
                        (*settings)
                            .username = PianoJsonStrdup(
                            result,
                            b"username\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    145651165234646754 => {
                        let mut reqData_5: *mut PianoRequestDataExplain_t = (*req).data
                            as *mut PianoRequestDataExplain_t;
                        let strSize: size_t = 768 as libc::c_int as size_t;
                        let mut explanations: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"explanations\0" as *const u8 as *const libc::c_char,
                            &mut explanations,
                        ) != 0
                        {
                            (*reqData_5)
                                .retExplain = malloc(
                                strSize
                                    .wrapping_mul(
                                        ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                    ),
                            ) as *mut libc::c_char;
                            strncpy(
                                (*reqData_5).retExplain,
                                b"We're playing this track because it features \0"
                                    as *const u8 as *const libc::c_char,
                                strSize,
                            );
                            let mut i_5: libc::c_int = 0 as libc::c_int;
                            while (i_5 as libc::c_ulong)
                                < json_object_array_length(explanations)
                            {
                                let mut e: *mut json_object = json_object_array_get_idx(
                                    explanations,
                                    i_5 as size_t,
                                );
                                let mut f: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    e,
                                    b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                    &mut f,
                                ) == 0)
                                {
                                    let mut s_3: *const libc::c_char = json_object_get_string(
                                        f,
                                    );
                                    PianoStrpcat((*reqData_5).retExplain, s_3, strSize);
                                    if (i_5 as libc::c_ulong)
                                        < (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b", \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else if i_5 as libc::c_ulong
                                        == (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b" and \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b".\0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    }
                                }
                                i_5 += 1;
                                i_5;
                            }
                        }
                    }
                    9240481512215375588 => {
                        let mut station_0: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*station_0).isCreator = 1 as libc::c_int as libc::c_char;
                    }
                    5908482871227205451 => {
                        let mut categories: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"categories\0" as *const u8 as *const libc::c_char,
                            &mut categories,
                        ) != 0
                        {
                            let mut i_4: libc::c_int = 0 as libc::c_int;
                            while (i_4 as libc::c_ulong)
                                < json_object_array_length(categories)
                            {
                                let mut c: *mut json_object = json_object_array_get_idx(
                                    categories,
                                    i_4 as size_t,
                                );
                                let mut tmpGenreCategory: *mut PianoGenreCategory_t = 0
                                    as *mut PianoGenreCategory_t;
                                tmpGenreCategory = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoGenreCategory_t>()
                                        as libc::c_ulong,
                                ) as *mut PianoGenreCategory_t;
                                if tmpGenreCategory.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*tmpGenreCategory)
                                    .name = PianoJsonStrdup(
                                    c,
                                    b"categoryName\0" as *const u8 as *const libc::c_char,
                                );
                                let mut stations_0: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    c,
                                    b"stations\0" as *const u8 as *const libc::c_char,
                                    &mut stations_0,
                                ) != 0
                                {
                                    let mut k_0: libc::c_int = 0 as libc::c_int;
                                    while (k_0 as libc::c_ulong)
                                        < json_object_array_length(stations_0)
                                    {
                                        let mut s_2: *mut json_object = json_object_array_get_idx(
                                            stations_0,
                                            k_0 as size_t,
                                        );
                                        let mut tmpGenre: *mut PianoGenre_t = 0
                                            as *mut PianoGenre_t;
                                        tmpGenre = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                        ) as *mut PianoGenre_t;
                                        if tmpGenre.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*tmpGenre)
                                            .name = PianoJsonStrdup(
                                            s_2,
                                            b"stationName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenre)
                                            .musicId = PianoJsonStrdup(
                                            s_2,
                                            b"stationToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenreCategory)
                                            .genres = PianoListAppend(
                                            if ((*tmpGenreCategory).genres).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*tmpGenreCategory).genres).head
                                            },
                                            &mut (*tmpGenre).head,
                                        ) as *mut PianoGenre_t;
                                        k_0 += 1;
                                        k_0;
                                    }
                                }
                                (*ph)
                                    .genreStations = PianoListAppend(
                                    if ((*ph).genreStations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).genreStations).head
                                    },
                                    &mut (*tmpGenreCategory).head,
                                ) as *mut PianoGenreCategory_t;
                                i_4 += 1;
                                i_4;
                            }
                        }
                    }
                    5260680050201874961 => {
                        let song_1: *mut PianoSong_t = (*req).data as *mut PianoSong_t;
                        (*song_1).rating = PIANO_RATE_TIRED;
                    }
                    11235674318412060590 => {
                        let mut tmpStation_0: *mut PianoStation_t = 0
                            as *mut PianoStation_t;
                        tmpStation_0 = calloc(
                            1 as libc::c_int as libc::c_ulong,
                            ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                        ) as *mut PianoStation_t;
                        if tmpStation_0.is_null() {
                            return PIANO_RET_OUT_OF_MEMORY;
                        }
                        PianoJsonParseStation(result, tmpStation_0);
                        let mut search: *mut PianoStation_t = PianoFindStationById(
                            (*ph).stations,
                            (*tmpStation_0).id,
                        );
                        if !search.is_null() {
                            (*ph)
                                .stations = PianoListDelete(
                                if ((*ph).stations).is_null() {
                                    0 as *mut PianoListHead_t
                                } else {
                                    &mut (*(*ph).stations).head
                                },
                                &mut (*search).head,
                            ) as *mut PianoStation_t;
                            PianoDestroyStation(search);
                            free(search as *mut libc::c_void);
                        }
                        (*ph)
                            .stations = PianoListAppend(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*tmpStation_0).head,
                        ) as *mut PianoStation_t;
                    }
                    10109057886293123569 => {
                        let mut reqData_4: *mut PianoRequestDataSearch_t = (*req).data
                            as *mut PianoRequestDataSearch_t;
                        let mut searchResult: *mut PianoSearchResult_t = 0
                            as *mut PianoSearchResult_t;
                        searchResult = &mut (*reqData_4).searchResult;
                        memset(
                            searchResult as *mut libc::c_void,
                            0 as libc::c_int,
                            ::std::mem::size_of::<PianoSearchResult_t>() as libc::c_ulong,
                        );
                        let mut artists: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"artists\0" as *const u8 as *const libc::c_char,
                            &mut artists,
                        ) != 0
                        {
                            let mut i_2: libc::c_int = 0 as libc::c_int;
                            while (i_2 as libc::c_ulong)
                                < json_object_array_length(artists)
                            {
                                let mut a: *mut json_object = json_object_array_get_idx(
                                    artists,
                                    i_2 as size_t,
                                );
                                let mut artist: *mut PianoArtist_t = 0
                                    as *mut PianoArtist_t;
                                artist = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                ) as *mut PianoArtist_t;
                                if artist.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*artist)
                                    .name = PianoJsonStrdup(
                                    a,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*artist)
                                    .musicId = PianoJsonStrdup(
                                    a,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .artists = PianoListAppend(
                                    if ((*searchResult).artists).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).artists).head
                                    },
                                    &mut (*artist).head,
                                ) as *mut PianoArtist_t;
                                i_2 += 1;
                                i_2;
                            }
                        }
                        let mut songs: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"songs\0" as *const u8 as *const libc::c_char,
                            &mut songs,
                        ) != 0
                        {
                            let mut i_3: libc::c_int = 0 as libc::c_int;
                            while (i_3 as libc::c_ulong)
                                < json_object_array_length(songs)
                            {
                                let mut s_1: *mut json_object = json_object_array_get_idx(
                                    songs,
                                    i_3 as size_t,
                                );
                                let mut song_0: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song_0 = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song_0.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*song_0)
                                    .title = PianoJsonStrdup(
                                    s_1,
                                    b"songName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .artist = PianoJsonStrdup(
                                    s_1,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .musicId = PianoJsonStrdup(
                                    s_1,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .songs = PianoListAppend(
                                    if ((*searchResult).songs).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).songs).head
                                    },
                                    &mut (*song_0).head,
                                ) as *mut PianoSong_t;
                                i_3 += 1;
                                i_3;
                            }
                        }
                    }
                    4983594971376015098 => {
                        let mut station: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*ph)
                            .stations = PianoListDelete(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*station).head,
                        ) as *mut PianoStation_t;
                        PianoDestroyStation(station);
                        free(station as *mut libc::c_void);
                    }
                    17372050596571538954 => {
                        let mut reqData_3: *mut PianoRequestDataRenameStation_t = (*req)
                            .data as *mut PianoRequestDataRenameStation_t;
                        free((*(*reqData_3).station).name as *mut libc::c_void);
                        (*(*reqData_3).station).name = strdup((*reqData_3).newName);
                    }
                    7297078374430259003 => {
                        let mut reqData_2: *mut PianoRequestDataRateSong_t = (*req).data
                            as *mut PianoRequestDataRateSong_t;
                        (*(*reqData_2).song).rating = (*reqData_2).rating;
                    }
                    17075014677070940716 => {
                        let mut reqData_1: *mut PianoRequestDataGetPlaylist_t = (*req)
                            .data as *mut PianoRequestDataGetPlaylist_t;
                        let mut playlist: *mut PianoSong_t = 0 as *mut PianoSong_t;
                        let mut items: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"items\0" as *const u8 as *const libc::c_char,
                            &mut items,
                        ) == 0)
                        {
                            let mut i_1: libc::c_int = 0 as libc::c_int;
                            loop {
                                if !((i_1 as libc::c_ulong)
                                    < json_object_array_length(items))
                                {
                                    current_block = 4488496028633655612;
                                    break;
                                }
                                let mut s_0: *mut json_object = json_object_array_get_idx(
                                    items,
                                    i_1 as size_t,
                                );
                                let mut song: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                if json_object_object_get_ex(
                                    s_0,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                    0 as *mut *mut json_object,
                                ) == 0
                                {
                                    free(song as *mut libc::c_void);
                                } else {
                                    static mut qualityMap: [*const libc::c_char; 4] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"lowQuality\0" as *const u8 as *const libc::c_char,
                                        b"mediumQuality\0" as *const u8 as *const libc::c_char,
                                        b"highQuality\0" as *const u8 as *const libc::c_char,
                                    ];
                                    static mut formatMap: [*const libc::c_char; 3] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"aacplus\0" as *const u8 as *const libc::c_char,
                                        b"mp3\0" as *const u8 as *const libc::c_char,
                                    ];
                                    let mut umap: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        s_0,
                                        b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                        &mut umap,
                                    ) != 0
                                    {
                                        let mut jsonEncoding: *mut json_object = 0
                                            as *mut json_object;
                                        let mut qmap: *mut json_object = 0 as *mut json_object;
                                        if json_object_object_get_ex(
                                            umap,
                                            qualityMap[(*reqData_1).quality as usize],
                                            &mut qmap,
                                        ) != 0
                                            && json_object_object_get_ex(
                                                qmap,
                                                b"encoding\0" as *const u8 as *const libc::c_char,
                                                &mut jsonEncoding,
                                            ) != 0
                                        {
                                            let mut encoding: *const libc::c_char = json_object_get_string(
                                                jsonEncoding,
                                            );
                                            let mut k: size_t = 0 as libc::c_int as size_t;
                                            while k
                                                < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                    as libc::c_ulong)
                                                    .wrapping_div(
                                                        ::std::mem::size_of::<*const libc::c_char>()
                                                            as libc::c_ulong,
                                                    )
                                            {
                                                if strcmp(formatMap[k as usize], encoding)
                                                    == 0 as libc::c_int
                                                {
                                                    (*song).audioFormat = k as PianoAudioFormat_t;
                                                    break;
                                                } else {
                                                    k = k.wrapping_add(1);
                                                    k;
                                                }
                                            }
                                            (*song)
                                                .audioUrl = PianoJsonStrdup(
                                                qmap,
                                                b"audioUrl\0" as *const u8 as *const libc::c_char,
                                            );
                                        } else {
                                            ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                            free(song as *mut libc::c_void);
                                            PianoDestroyPlaylist(playlist);
                                            current_block = 9169893888141833765;
                                            break;
                                        }
                                    }
                                    let mut v: *mut json_object = 0 as *mut json_object;
                                    (*song)
                                        .artist = PianoJsonStrdup(
                                        s_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .album = PianoJsonStrdup(
                                        s_0,
                                        b"albumName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .title = PianoJsonStrdup(
                                        s_0,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .trackToken = PianoJsonStrdup(
                                        s_0,
                                        b"trackToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .stationId = PianoJsonStrdup(
                                        s_0,
                                        b"stationId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .coverArt = PianoJsonStrdup(
                                        s_0,
                                        b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .detailUrl = PianoJsonStrdup(
                                        s_0,
                                        b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .fileGain = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackGain\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_double(v)
                                    } else {
                                        0.0f64
                                    }) as libc::c_float;
                                    (*song)
                                        .length = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackLength\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    }) as libc::c_uint;
                                    match if json_object_object_get_ex(
                                        s_0,
                                        b"songRating\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    } {
                                        1 => {
                                            (*song).rating = PIANO_RATE_LOVE;
                                        }
                                        _ => {}
                                    }
                                    playlist = PianoListAppend(
                                        if playlist.is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*playlist).head
                                        },
                                        &mut (*song).head,
                                    ) as *mut PianoSong_t;
                                }
                                i_1 += 1;
                                i_1;
                            }
                            match current_block {
                                9169893888141833765 => {}
                                _ => {
                                    (*reqData_1).retPlaylist = playlist;
                                }
                            }
                        }
                    }
                    6450597802325118133 => {
                        let mut stations: *mut json_object = 0 as *mut json_object;
                        let mut mix: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"stations\0" as *const u8 as *const libc::c_char,
                            &mut stations,
                        ) == 0)
                        {
                            let mut i: libc::c_int = 0 as libc::c_int;
                            while (i as libc::c_ulong)
                                < json_object_array_length(stations)
                            {
                                let mut tmpStation: *mut PianoStation_t = 0
                                    as *mut PianoStation_t;
                                let mut s: *mut json_object = json_object_array_get_idx(
                                    stations,
                                    i as size_t,
                                );
                                tmpStation = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                ) as *mut PianoStation_t;
                                if tmpStation.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                PianoJsonParseStation(s, tmpStation);
                                if (*tmpStation).isQuickMix != 0 {
                                    json_object_object_get_ex(
                                        s,
                                        b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                        &mut mix,
                                    );
                                }
                                (*ph)
                                    .stations = PianoListAppend(
                                    if ((*ph).stations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).stations).head
                                    },
                                    &mut (*tmpStation).head,
                                ) as *mut PianoStation_t;
                                i += 1;
                                i;
                            }
                            if !mix.is_null() {
                                let mut curStation: *mut PianoStation_t = (*ph).stations;
                                while !curStation.is_null() {
                                    let mut i_0: libc::c_int = 0 as libc::c_int;
                                    while (i_0 as libc::c_ulong) < json_object_array_length(mix)
                                    {
                                        let mut id: *mut json_object = json_object_array_get_idx(
                                            mix,
                                            i_0 as size_t,
                                        );
                                        if strcmp(json_object_get_string(id), (*curStation).id)
                                            == 0 as libc::c_int
                                        {
                                            (*curStation)
                                                .useQuickMix = 1 as libc::c_int as libc::c_char;
                                        }
                                        i_0 += 1;
                                        i_0;
                                    }
                                    curStation = (*curStation).head.next as *mut libc::c_void
                                        as *mut PianoStation_t;
                                }
                            }
                        }
                    }
                    12039483399334584727 => {
                        let mut reqData_0: *mut PianoRequestDataLogin_t = (*req).data
                            as *mut PianoRequestDataLogin_t;
                        match (*reqData_0).step as libc::c_int {
                            0 => {
                                let mut jsonTimestamp: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    result,
                                    b"syncTime\0" as *const u8 as *const libc::c_char,
                                    &mut jsonTimestamp,
                                ) == 0
                                {
                                    ret = PIANO_RET_INVALID_RESPONSE;
                                } else {
                                    let cryptedTimestamp: *const libc::c_char = json_object_get_string(
                                        jsonTimestamp,
                                    );
                                    let realTimestamp: time_t = time(0 as *mut time_t);
                                    let mut decryptedTimestamp: *mut libc::c_char = 0
                                        as *mut libc::c_char;
                                    let mut decryptedSize: size_t = 0;
                                    ret = PIANO_RET_ERR;
                                    decryptedTimestamp = PianoDecryptString(
                                        (*ph).partner.in_0,
                                        cryptedTimestamp,
                                        &mut decryptedSize,
                                    );
                                    if !decryptedTimestamp.is_null()
                                        && decryptedSize > 4 as libc::c_int as libc::c_ulong
                                    {
                                        let timestamp: libc::c_ulong = strtoul(
                                            decryptedTimestamp.offset(4 as libc::c_int as isize),
                                            0 as *mut *mut libc::c_char,
                                            0 as libc::c_int,
                                        );
                                        (*ph)
                                            .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                            as libc::c_int;
                                        ret = PIANO_RET_CONTINUE_REQUEST;
                                    }
                                    free(decryptedTimestamp as *mut libc::c_void);
                                    (*ph)
                                        .partner
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    let mut partnerId: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        result,
                                        b"partnerId\0" as *const u8 as *const libc::c_char,
                                        &mut partnerId,
                                    ) == 0
                                    {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        (*ph)
                                            .partner
                                            .id = json_object_get_int(partnerId) as libc::c_uint;
                                        (*reqData_0).step = ((*reqData_0).step).wrapping_add(1);
                                        (*reqData_0).step;
                                    }
                                }
                            }
                            1 => {
                                if !((*ph).user.listenerId).is_null() {
                                    PianoDestroyUserInfo(&mut (*ph).user);
                                }
                                (*ph)
                                    .user
                                    .listenerId = PianoJsonStrdup(
                                    result,
                                    b"userId\0" as *const u8 as *const libc::c_char,
                                );
                                (*ph)
                                    .user
                                    .authToken = PianoJsonStrdup(
                                    result,
                                    b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                );
                            }
                            _ => {}
                        }
                    }
                    10223170376184624358 => {
                        let mut reqData_8: *mut PianoRequestDataSetStationMode_t = (*req)
                            .data as *mut PianoRequestDataSetStationMode_t;
                        let mut active_0: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode_0: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode_0,
                        ) != 0
                        {
                            active_0 = json_object_get_int(activeMode_0);
                        }
                        if active_0 as libc::c_uint != (*reqData_8).id {
                            return PIANO_RET_ERR;
                        }
                    }
                    _ => {
                        let mut reqData_7: *mut PianoRequestDataGetStationModes_t = (*req)
                            .data as *mut PianoRequestDataGetStationModes_t;
                        let mut active: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode,
                        ) != 0
                        {
                            active = json_object_get_int(activeMode);
                        }
                        let mut availableModes: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"availableModes\0" as *const u8 as *const libc::c_char,
                            &mut availableModes,
                        ) != 0
                        {
                            let mut i_10: libc::c_int = 0 as libc::c_int;
                            while (i_10 as libc::c_ulong)
                                < json_object_array_length(availableModes)
                            {
                                let mut val_0: *mut json_object = json_object_array_get_idx(
                                    availableModes,
                                    i_10 as size_t,
                                );
                                let mut mode: *mut PianoStationMode_t = 0
                                    as *mut PianoStationMode_t;
                                mode = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                ) as *mut PianoStationMode_t;
                                if mode.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                let mut modeId: *mut json_object = 0 as *mut json_object;
                                if json_object_object_get_ex(
                                    val_0,
                                    b"modeId\0" as *const u8 as *const libc::c_char,
                                    &mut modeId,
                                ) != 0
                                {
                                    (*mode).id = json_object_get_int(modeId);
                                    (*mode)
                                        .name = PianoJsonStrdup(
                                        val_0,
                                        b"modeName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .description = PianoJsonStrdup(
                                        val_0,
                                        b"modeDescription\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .isAlgorithmic = getBoolDefault(
                                        val_0,
                                        b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode)
                                        .isTakeover = getBoolDefault(
                                        val_0,
                                        b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode).active = active == (*mode).id;
                                }
                                (*reqData_7)
                                    .retModes = PianoListAppend(
                                    if ((*reqData_7).retModes).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*reqData_7).retModes).head
                                    },
                                    &mut (*mode).head,
                                ) as *mut PianoStationMode_t;
                                i_10 += 1;
                                i_10;
                            }
                        }
                    }
                }
            }
            16 => {
                current_block = 145651165234646754;
                match current_block {
                    14870924983410776565 => {}
                    4367030874028593650 => {
                        let mut reqData_6: *mut PianoRequestDataGetStationInfo_t = (*req)
                            .data as *mut PianoRequestDataGetStationInfo_t;
                        let mut info: *mut PianoStationInfo_t = 0
                            as *mut PianoStationInfo_t;
                        info = &mut (*reqData_6).info;
                        let mut music: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"music\0" as *const u8 as *const libc::c_char,
                            &mut music,
                        ) != 0
                        {
                            let mut songs_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs_0,
                            ) != 0
                            {
                                let mut i_6: libc::c_int = 0 as libc::c_int;
                                while (i_6 as libc::c_ulong)
                                    < json_object_array_length(songs_0)
                                {
                                    let mut s_4: *mut json_object = json_object_array_get_idx(
                                        songs_0,
                                        i_6 as size_t,
                                    );
                                    let mut seedSong: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                    seedSong = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    ) as *mut PianoSong_t;
                                    if seedSong.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedSong)
                                        .title = PianoJsonStrdup(
                                        s_4,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .artist = PianoJsonStrdup(
                                        s_4,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .seedId = PianoJsonStrdup(
                                        s_4,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .songSeeds = PianoListAppend(
                                        if ((*info).songSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).songSeeds).head
                                        },
                                        &mut (*seedSong).head,
                                    ) as *mut PianoSong_t;
                                    i_6 += 1;
                                    i_6;
                                }
                            }
                            let mut artists_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists_0,
                            ) != 0
                            {
                                let mut i_7: libc::c_int = 0 as libc::c_int;
                                while (i_7 as libc::c_ulong)
                                    < json_object_array_length(artists_0)
                                {
                                    let mut a_0: *mut json_object = json_object_array_get_idx(
                                        artists_0,
                                        i_7 as size_t,
                                    );
                                    let mut seedArtist: *mut PianoArtist_t = 0
                                        as *mut PianoArtist_t;
                                    seedArtist = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    ) as *mut PianoArtist_t;
                                    if seedArtist.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedArtist)
                                        .name = PianoJsonStrdup(
                                        a_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedArtist)
                                        .seedId = PianoJsonStrdup(
                                        a_0,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .artistSeeds = PianoListAppend(
                                        if ((*info).artistSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).artistSeeds).head
                                        },
                                        &mut (*seedArtist).head,
                                    ) as *mut PianoArtist_t;
                                    i_7 += 1;
                                    i_7;
                                }
                            }
                        }
                        let mut feedback: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"feedback\0" as *const u8 as *const libc::c_char,
                            &mut feedback,
                        ) != 0
                        {
                            static mut keys: [*const libc::c_char; 2] = [
                                b"thumbsUp\0" as *const u8 as *const libc::c_char,
                                b"thumbsDown\0" as *const u8 as *const libc::c_char,
                            ];
                            let mut i_8: size_t = 0 as libc::c_int as size_t;
                            while i_8
                                < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                    as libc::c_ulong)
                                    .wrapping_div(
                                        ::std::mem::size_of::<*const libc::c_char>()
                                            as libc::c_ulong,
                                    )
                            {
                                let mut val: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    feedback,
                                    keys[i_8 as usize],
                                    &mut val,
                                ) == 0)
                                {
                                    let mut i_9: libc::c_int = 0 as libc::c_int;
                                    while (i_9 as libc::c_ulong) < json_object_array_length(val)
                                    {
                                        let mut s_5: *mut json_object = json_object_array_get_idx(
                                            val,
                                            i_9 as size_t,
                                        );
                                        let mut feedbackSong: *mut PianoSong_t = 0
                                            as *mut PianoSong_t;
                                        feedbackSong = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        ) as *mut PianoSong_t;
                                        if feedbackSong.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*feedbackSong)
                                            .title = PianoJsonStrdup(
                                            s_5,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .artist = PianoJsonStrdup(
                                            s_5,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .feedbackId = PianoJsonStrdup(
                                            s_5,
                                            b"feedbackId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .rating = (if getBoolDefault(
                                            s_5,
                                            b"isPositive\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        ) as libc::c_int != 0
                                        {
                                            PIANO_RATE_LOVE as libc::c_int
                                        } else {
                                            PIANO_RATE_BAN as libc::c_int
                                        }) as PianoSongRating_t;
                                        let mut v_0: *mut json_object = 0 as *mut json_object;
                                        (*feedbackSong)
                                            .length = (if json_object_object_get_ex(
                                            s_5,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v_0,
                                        ) != 0
                                        {
                                            json_object_get_int(v_0)
                                        } else {
                                            0 as libc::c_int
                                        }) as libc::c_uint;
                                        (*info)
                                            .feedback = PianoListAppend(
                                            if ((*info).feedback).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*info).feedback).head
                                            },
                                            &mut (*feedbackSong).head,
                                        ) as *mut PianoSong_t;
                                        i_9 += 1;
                                        i_9;
                                    }
                                }
                                i_8 = i_8.wrapping_add(1);
                                i_8;
                            }
                        }
                    }
                    11202235766349324107 => {
                        let settings: *mut PianoSettings_t = (*req).data
                            as *mut PianoSettings_t;
                        (*settings)
                            .explicitContentFilter = getBoolDefault(
                            result,
                            b"isExplicitContentFilterEnabled\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int != 0,
                        );
                        (*settings)
                            .username = PianoJsonStrdup(
                            result,
                            b"username\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    145651165234646754 => {
                        let mut reqData_5: *mut PianoRequestDataExplain_t = (*req).data
                            as *mut PianoRequestDataExplain_t;
                        let strSize: size_t = 768 as libc::c_int as size_t;
                        let mut explanations: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"explanations\0" as *const u8 as *const libc::c_char,
                            &mut explanations,
                        ) != 0
                        {
                            (*reqData_5)
                                .retExplain = malloc(
                                strSize
                                    .wrapping_mul(
                                        ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                    ),
                            ) as *mut libc::c_char;
                            strncpy(
                                (*reqData_5).retExplain,
                                b"We're playing this track because it features \0"
                                    as *const u8 as *const libc::c_char,
                                strSize,
                            );
                            let mut i_5: libc::c_int = 0 as libc::c_int;
                            while (i_5 as libc::c_ulong)
                                < json_object_array_length(explanations)
                            {
                                let mut e: *mut json_object = json_object_array_get_idx(
                                    explanations,
                                    i_5 as size_t,
                                );
                                let mut f: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    e,
                                    b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                    &mut f,
                                ) == 0)
                                {
                                    let mut s_3: *const libc::c_char = json_object_get_string(
                                        f,
                                    );
                                    PianoStrpcat((*reqData_5).retExplain, s_3, strSize);
                                    if (i_5 as libc::c_ulong)
                                        < (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b", \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else if i_5 as libc::c_ulong
                                        == (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b" and \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b".\0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    }
                                }
                                i_5 += 1;
                                i_5;
                            }
                        }
                    }
                    9240481512215375588 => {
                        let mut station_0: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*station_0).isCreator = 1 as libc::c_int as libc::c_char;
                    }
                    5908482871227205451 => {
                        let mut categories: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"categories\0" as *const u8 as *const libc::c_char,
                            &mut categories,
                        ) != 0
                        {
                            let mut i_4: libc::c_int = 0 as libc::c_int;
                            while (i_4 as libc::c_ulong)
                                < json_object_array_length(categories)
                            {
                                let mut c: *mut json_object = json_object_array_get_idx(
                                    categories,
                                    i_4 as size_t,
                                );
                                let mut tmpGenreCategory: *mut PianoGenreCategory_t = 0
                                    as *mut PianoGenreCategory_t;
                                tmpGenreCategory = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoGenreCategory_t>()
                                        as libc::c_ulong,
                                ) as *mut PianoGenreCategory_t;
                                if tmpGenreCategory.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*tmpGenreCategory)
                                    .name = PianoJsonStrdup(
                                    c,
                                    b"categoryName\0" as *const u8 as *const libc::c_char,
                                );
                                let mut stations_0: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    c,
                                    b"stations\0" as *const u8 as *const libc::c_char,
                                    &mut stations_0,
                                ) != 0
                                {
                                    let mut k_0: libc::c_int = 0 as libc::c_int;
                                    while (k_0 as libc::c_ulong)
                                        < json_object_array_length(stations_0)
                                    {
                                        let mut s_2: *mut json_object = json_object_array_get_idx(
                                            stations_0,
                                            k_0 as size_t,
                                        );
                                        let mut tmpGenre: *mut PianoGenre_t = 0
                                            as *mut PianoGenre_t;
                                        tmpGenre = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                        ) as *mut PianoGenre_t;
                                        if tmpGenre.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*tmpGenre)
                                            .name = PianoJsonStrdup(
                                            s_2,
                                            b"stationName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenre)
                                            .musicId = PianoJsonStrdup(
                                            s_2,
                                            b"stationToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenreCategory)
                                            .genres = PianoListAppend(
                                            if ((*tmpGenreCategory).genres).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*tmpGenreCategory).genres).head
                                            },
                                            &mut (*tmpGenre).head,
                                        ) as *mut PianoGenre_t;
                                        k_0 += 1;
                                        k_0;
                                    }
                                }
                                (*ph)
                                    .genreStations = PianoListAppend(
                                    if ((*ph).genreStations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).genreStations).head
                                    },
                                    &mut (*tmpGenreCategory).head,
                                ) as *mut PianoGenreCategory_t;
                                i_4 += 1;
                                i_4;
                            }
                        }
                    }
                    5260680050201874961 => {
                        let song_1: *mut PianoSong_t = (*req).data as *mut PianoSong_t;
                        (*song_1).rating = PIANO_RATE_TIRED;
                    }
                    11235674318412060590 => {
                        let mut tmpStation_0: *mut PianoStation_t = 0
                            as *mut PianoStation_t;
                        tmpStation_0 = calloc(
                            1 as libc::c_int as libc::c_ulong,
                            ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                        ) as *mut PianoStation_t;
                        if tmpStation_0.is_null() {
                            return PIANO_RET_OUT_OF_MEMORY;
                        }
                        PianoJsonParseStation(result, tmpStation_0);
                        let mut search: *mut PianoStation_t = PianoFindStationById(
                            (*ph).stations,
                            (*tmpStation_0).id,
                        );
                        if !search.is_null() {
                            (*ph)
                                .stations = PianoListDelete(
                                if ((*ph).stations).is_null() {
                                    0 as *mut PianoListHead_t
                                } else {
                                    &mut (*(*ph).stations).head
                                },
                                &mut (*search).head,
                            ) as *mut PianoStation_t;
                            PianoDestroyStation(search);
                            free(search as *mut libc::c_void);
                        }
                        (*ph)
                            .stations = PianoListAppend(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*tmpStation_0).head,
                        ) as *mut PianoStation_t;
                    }
                    10109057886293123569 => {
                        let mut reqData_4: *mut PianoRequestDataSearch_t = (*req).data
                            as *mut PianoRequestDataSearch_t;
                        let mut searchResult: *mut PianoSearchResult_t = 0
                            as *mut PianoSearchResult_t;
                        searchResult = &mut (*reqData_4).searchResult;
                        memset(
                            searchResult as *mut libc::c_void,
                            0 as libc::c_int,
                            ::std::mem::size_of::<PianoSearchResult_t>() as libc::c_ulong,
                        );
                        let mut artists: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"artists\0" as *const u8 as *const libc::c_char,
                            &mut artists,
                        ) != 0
                        {
                            let mut i_2: libc::c_int = 0 as libc::c_int;
                            while (i_2 as libc::c_ulong)
                                < json_object_array_length(artists)
                            {
                                let mut a: *mut json_object = json_object_array_get_idx(
                                    artists,
                                    i_2 as size_t,
                                );
                                let mut artist: *mut PianoArtist_t = 0
                                    as *mut PianoArtist_t;
                                artist = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                ) as *mut PianoArtist_t;
                                if artist.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*artist)
                                    .name = PianoJsonStrdup(
                                    a,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*artist)
                                    .musicId = PianoJsonStrdup(
                                    a,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .artists = PianoListAppend(
                                    if ((*searchResult).artists).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).artists).head
                                    },
                                    &mut (*artist).head,
                                ) as *mut PianoArtist_t;
                                i_2 += 1;
                                i_2;
                            }
                        }
                        let mut songs: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"songs\0" as *const u8 as *const libc::c_char,
                            &mut songs,
                        ) != 0
                        {
                            let mut i_3: libc::c_int = 0 as libc::c_int;
                            while (i_3 as libc::c_ulong)
                                < json_object_array_length(songs)
                            {
                                let mut s_1: *mut json_object = json_object_array_get_idx(
                                    songs,
                                    i_3 as size_t,
                                );
                                let mut song_0: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song_0 = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song_0.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*song_0)
                                    .title = PianoJsonStrdup(
                                    s_1,
                                    b"songName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .artist = PianoJsonStrdup(
                                    s_1,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .musicId = PianoJsonStrdup(
                                    s_1,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .songs = PianoListAppend(
                                    if ((*searchResult).songs).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).songs).head
                                    },
                                    &mut (*song_0).head,
                                ) as *mut PianoSong_t;
                                i_3 += 1;
                                i_3;
                            }
                        }
                    }
                    4983594971376015098 => {
                        let mut station: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*ph)
                            .stations = PianoListDelete(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*station).head,
                        ) as *mut PianoStation_t;
                        PianoDestroyStation(station);
                        free(station as *mut libc::c_void);
                    }
                    17372050596571538954 => {
                        let mut reqData_3: *mut PianoRequestDataRenameStation_t = (*req)
                            .data as *mut PianoRequestDataRenameStation_t;
                        free((*(*reqData_3).station).name as *mut libc::c_void);
                        (*(*reqData_3).station).name = strdup((*reqData_3).newName);
                    }
                    7297078374430259003 => {
                        let mut reqData_2: *mut PianoRequestDataRateSong_t = (*req).data
                            as *mut PianoRequestDataRateSong_t;
                        (*(*reqData_2).song).rating = (*reqData_2).rating;
                    }
                    17075014677070940716 => {
                        let mut reqData_1: *mut PianoRequestDataGetPlaylist_t = (*req)
                            .data as *mut PianoRequestDataGetPlaylist_t;
                        let mut playlist: *mut PianoSong_t = 0 as *mut PianoSong_t;
                        let mut items: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"items\0" as *const u8 as *const libc::c_char,
                            &mut items,
                        ) == 0)
                        {
                            let mut i_1: libc::c_int = 0 as libc::c_int;
                            loop {
                                if !((i_1 as libc::c_ulong)
                                    < json_object_array_length(items))
                                {
                                    current_block = 4488496028633655612;
                                    break;
                                }
                                let mut s_0: *mut json_object = json_object_array_get_idx(
                                    items,
                                    i_1 as size_t,
                                );
                                let mut song: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                if json_object_object_get_ex(
                                    s_0,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                    0 as *mut *mut json_object,
                                ) == 0
                                {
                                    free(song as *mut libc::c_void);
                                } else {
                                    static mut qualityMap: [*const libc::c_char; 4] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"lowQuality\0" as *const u8 as *const libc::c_char,
                                        b"mediumQuality\0" as *const u8 as *const libc::c_char,
                                        b"highQuality\0" as *const u8 as *const libc::c_char,
                                    ];
                                    static mut formatMap: [*const libc::c_char; 3] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"aacplus\0" as *const u8 as *const libc::c_char,
                                        b"mp3\0" as *const u8 as *const libc::c_char,
                                    ];
                                    let mut umap: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        s_0,
                                        b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                        &mut umap,
                                    ) != 0
                                    {
                                        let mut jsonEncoding: *mut json_object = 0
                                            as *mut json_object;
                                        let mut qmap: *mut json_object = 0 as *mut json_object;
                                        if json_object_object_get_ex(
                                            umap,
                                            qualityMap[(*reqData_1).quality as usize],
                                            &mut qmap,
                                        ) != 0
                                            && json_object_object_get_ex(
                                                qmap,
                                                b"encoding\0" as *const u8 as *const libc::c_char,
                                                &mut jsonEncoding,
                                            ) != 0
                                        {
                                            let mut encoding: *const libc::c_char = json_object_get_string(
                                                jsonEncoding,
                                            );
                                            let mut k: size_t = 0 as libc::c_int as size_t;
                                            while k
                                                < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                    as libc::c_ulong)
                                                    .wrapping_div(
                                                        ::std::mem::size_of::<*const libc::c_char>()
                                                            as libc::c_ulong,
                                                    )
                                            {
                                                if strcmp(formatMap[k as usize], encoding)
                                                    == 0 as libc::c_int
                                                {
                                                    (*song).audioFormat = k as PianoAudioFormat_t;
                                                    break;
                                                } else {
                                                    k = k.wrapping_add(1);
                                                    k;
                                                }
                                            }
                                            (*song)
                                                .audioUrl = PianoJsonStrdup(
                                                qmap,
                                                b"audioUrl\0" as *const u8 as *const libc::c_char,
                                            );
                                        } else {
                                            ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                            free(song as *mut libc::c_void);
                                            PianoDestroyPlaylist(playlist);
                                            current_block = 9169893888141833765;
                                            break;
                                        }
                                    }
                                    let mut v: *mut json_object = 0 as *mut json_object;
                                    (*song)
                                        .artist = PianoJsonStrdup(
                                        s_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .album = PianoJsonStrdup(
                                        s_0,
                                        b"albumName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .title = PianoJsonStrdup(
                                        s_0,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .trackToken = PianoJsonStrdup(
                                        s_0,
                                        b"trackToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .stationId = PianoJsonStrdup(
                                        s_0,
                                        b"stationId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .coverArt = PianoJsonStrdup(
                                        s_0,
                                        b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .detailUrl = PianoJsonStrdup(
                                        s_0,
                                        b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .fileGain = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackGain\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_double(v)
                                    } else {
                                        0.0f64
                                    }) as libc::c_float;
                                    (*song)
                                        .length = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackLength\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    }) as libc::c_uint;
                                    match if json_object_object_get_ex(
                                        s_0,
                                        b"songRating\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    } {
                                        1 => {
                                            (*song).rating = PIANO_RATE_LOVE;
                                        }
                                        _ => {}
                                    }
                                    playlist = PianoListAppend(
                                        if playlist.is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*playlist).head
                                        },
                                        &mut (*song).head,
                                    ) as *mut PianoSong_t;
                                }
                                i_1 += 1;
                                i_1;
                            }
                            match current_block {
                                9169893888141833765 => {}
                                _ => {
                                    (*reqData_1).retPlaylist = playlist;
                                }
                            }
                        }
                    }
                    6450597802325118133 => {
                        let mut stations: *mut json_object = 0 as *mut json_object;
                        let mut mix: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"stations\0" as *const u8 as *const libc::c_char,
                            &mut stations,
                        ) == 0)
                        {
                            let mut i: libc::c_int = 0 as libc::c_int;
                            while (i as libc::c_ulong)
                                < json_object_array_length(stations)
                            {
                                let mut tmpStation: *mut PianoStation_t = 0
                                    as *mut PianoStation_t;
                                let mut s: *mut json_object = json_object_array_get_idx(
                                    stations,
                                    i as size_t,
                                );
                                tmpStation = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                ) as *mut PianoStation_t;
                                if tmpStation.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                PianoJsonParseStation(s, tmpStation);
                                if (*tmpStation).isQuickMix != 0 {
                                    json_object_object_get_ex(
                                        s,
                                        b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                        &mut mix,
                                    );
                                }
                                (*ph)
                                    .stations = PianoListAppend(
                                    if ((*ph).stations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).stations).head
                                    },
                                    &mut (*tmpStation).head,
                                ) as *mut PianoStation_t;
                                i += 1;
                                i;
                            }
                            if !mix.is_null() {
                                let mut curStation: *mut PianoStation_t = (*ph).stations;
                                while !curStation.is_null() {
                                    let mut i_0: libc::c_int = 0 as libc::c_int;
                                    while (i_0 as libc::c_ulong) < json_object_array_length(mix)
                                    {
                                        let mut id: *mut json_object = json_object_array_get_idx(
                                            mix,
                                            i_0 as size_t,
                                        );
                                        if strcmp(json_object_get_string(id), (*curStation).id)
                                            == 0 as libc::c_int
                                        {
                                            (*curStation)
                                                .useQuickMix = 1 as libc::c_int as libc::c_char;
                                        }
                                        i_0 += 1;
                                        i_0;
                                    }
                                    curStation = (*curStation).head.next as *mut libc::c_void
                                        as *mut PianoStation_t;
                                }
                            }
                        }
                    }
                    12039483399334584727 => {
                        let mut reqData_0: *mut PianoRequestDataLogin_t = (*req).data
                            as *mut PianoRequestDataLogin_t;
                        match (*reqData_0).step as libc::c_int {
                            0 => {
                                let mut jsonTimestamp: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    result,
                                    b"syncTime\0" as *const u8 as *const libc::c_char,
                                    &mut jsonTimestamp,
                                ) == 0
                                {
                                    ret = PIANO_RET_INVALID_RESPONSE;
                                } else {
                                    let cryptedTimestamp: *const libc::c_char = json_object_get_string(
                                        jsonTimestamp,
                                    );
                                    let realTimestamp: time_t = time(0 as *mut time_t);
                                    let mut decryptedTimestamp: *mut libc::c_char = 0
                                        as *mut libc::c_char;
                                    let mut decryptedSize: size_t = 0;
                                    ret = PIANO_RET_ERR;
                                    decryptedTimestamp = PianoDecryptString(
                                        (*ph).partner.in_0,
                                        cryptedTimestamp,
                                        &mut decryptedSize,
                                    );
                                    if !decryptedTimestamp.is_null()
                                        && decryptedSize > 4 as libc::c_int as libc::c_ulong
                                    {
                                        let timestamp: libc::c_ulong = strtoul(
                                            decryptedTimestamp.offset(4 as libc::c_int as isize),
                                            0 as *mut *mut libc::c_char,
                                            0 as libc::c_int,
                                        );
                                        (*ph)
                                            .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                            as libc::c_int;
                                        ret = PIANO_RET_CONTINUE_REQUEST;
                                    }
                                    free(decryptedTimestamp as *mut libc::c_void);
                                    (*ph)
                                        .partner
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    let mut partnerId: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        result,
                                        b"partnerId\0" as *const u8 as *const libc::c_char,
                                        &mut partnerId,
                                    ) == 0
                                    {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        (*ph)
                                            .partner
                                            .id = json_object_get_int(partnerId) as libc::c_uint;
                                        (*reqData_0).step = ((*reqData_0).step).wrapping_add(1);
                                        (*reqData_0).step;
                                    }
                                }
                            }
                            1 => {
                                if !((*ph).user.listenerId).is_null() {
                                    PianoDestroyUserInfo(&mut (*ph).user);
                                }
                                (*ph)
                                    .user
                                    .listenerId = PianoJsonStrdup(
                                    result,
                                    b"userId\0" as *const u8 as *const libc::c_char,
                                );
                                (*ph)
                                    .user
                                    .authToken = PianoJsonStrdup(
                                    result,
                                    b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                );
                            }
                            _ => {}
                        }
                    }
                    10223170376184624358 => {
                        let mut reqData_8: *mut PianoRequestDataSetStationMode_t = (*req)
                            .data as *mut PianoRequestDataSetStationMode_t;
                        let mut active_0: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode_0: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode_0,
                        ) != 0
                        {
                            active_0 = json_object_get_int(activeMode_0);
                        }
                        if active_0 as libc::c_uint != (*reqData_8).id {
                            return PIANO_RET_ERR;
                        }
                    }
                    _ => {
                        let mut reqData_7: *mut PianoRequestDataGetStationModes_t = (*req)
                            .data as *mut PianoRequestDataGetStationModes_t;
                        let mut active: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode,
                        ) != 0
                        {
                            active = json_object_get_int(activeMode);
                        }
                        let mut availableModes: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"availableModes\0" as *const u8 as *const libc::c_char,
                            &mut availableModes,
                        ) != 0
                        {
                            let mut i_10: libc::c_int = 0 as libc::c_int;
                            while (i_10 as libc::c_ulong)
                                < json_object_array_length(availableModes)
                            {
                                let mut val_0: *mut json_object = json_object_array_get_idx(
                                    availableModes,
                                    i_10 as size_t,
                                );
                                let mut mode: *mut PianoStationMode_t = 0
                                    as *mut PianoStationMode_t;
                                mode = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                ) as *mut PianoStationMode_t;
                                if mode.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                let mut modeId: *mut json_object = 0 as *mut json_object;
                                if json_object_object_get_ex(
                                    val_0,
                                    b"modeId\0" as *const u8 as *const libc::c_char,
                                    &mut modeId,
                                ) != 0
                                {
                                    (*mode).id = json_object_get_int(modeId);
                                    (*mode)
                                        .name = PianoJsonStrdup(
                                        val_0,
                                        b"modeName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .description = PianoJsonStrdup(
                                        val_0,
                                        b"modeDescription\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .isAlgorithmic = getBoolDefault(
                                        val_0,
                                        b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode)
                                        .isTakeover = getBoolDefault(
                                        val_0,
                                        b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode).active = active == (*mode).id;
                                }
                                (*reqData_7)
                                    .retModes = PianoListAppend(
                                    if ((*reqData_7).retModes).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*reqData_7).retModes).head
                                    },
                                    &mut (*mode).head,
                                ) as *mut PianoStationMode_t;
                                i_10 += 1;
                                i_10;
                            }
                        }
                    }
                }
            }
            23 => {
                current_block = 11202235766349324107;
                match current_block {
                    14870924983410776565 => {}
                    4367030874028593650 => {
                        let mut reqData_6: *mut PianoRequestDataGetStationInfo_t = (*req)
                            .data as *mut PianoRequestDataGetStationInfo_t;
                        let mut info: *mut PianoStationInfo_t = 0
                            as *mut PianoStationInfo_t;
                        info = &mut (*reqData_6).info;
                        let mut music: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"music\0" as *const u8 as *const libc::c_char,
                            &mut music,
                        ) != 0
                        {
                            let mut songs_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs_0,
                            ) != 0
                            {
                                let mut i_6: libc::c_int = 0 as libc::c_int;
                                while (i_6 as libc::c_ulong)
                                    < json_object_array_length(songs_0)
                                {
                                    let mut s_4: *mut json_object = json_object_array_get_idx(
                                        songs_0,
                                        i_6 as size_t,
                                    );
                                    let mut seedSong: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                    seedSong = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    ) as *mut PianoSong_t;
                                    if seedSong.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedSong)
                                        .title = PianoJsonStrdup(
                                        s_4,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .artist = PianoJsonStrdup(
                                        s_4,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .seedId = PianoJsonStrdup(
                                        s_4,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .songSeeds = PianoListAppend(
                                        if ((*info).songSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).songSeeds).head
                                        },
                                        &mut (*seedSong).head,
                                    ) as *mut PianoSong_t;
                                    i_6 += 1;
                                    i_6;
                                }
                            }
                            let mut artists_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists_0,
                            ) != 0
                            {
                                let mut i_7: libc::c_int = 0 as libc::c_int;
                                while (i_7 as libc::c_ulong)
                                    < json_object_array_length(artists_0)
                                {
                                    let mut a_0: *mut json_object = json_object_array_get_idx(
                                        artists_0,
                                        i_7 as size_t,
                                    );
                                    let mut seedArtist: *mut PianoArtist_t = 0
                                        as *mut PianoArtist_t;
                                    seedArtist = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    ) as *mut PianoArtist_t;
                                    if seedArtist.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedArtist)
                                        .name = PianoJsonStrdup(
                                        a_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedArtist)
                                        .seedId = PianoJsonStrdup(
                                        a_0,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .artistSeeds = PianoListAppend(
                                        if ((*info).artistSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).artistSeeds).head
                                        },
                                        &mut (*seedArtist).head,
                                    ) as *mut PianoArtist_t;
                                    i_7 += 1;
                                    i_7;
                                }
                            }
                        }
                        let mut feedback: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"feedback\0" as *const u8 as *const libc::c_char,
                            &mut feedback,
                        ) != 0
                        {
                            static mut keys: [*const libc::c_char; 2] = [
                                b"thumbsUp\0" as *const u8 as *const libc::c_char,
                                b"thumbsDown\0" as *const u8 as *const libc::c_char,
                            ];
                            let mut i_8: size_t = 0 as libc::c_int as size_t;
                            while i_8
                                < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                    as libc::c_ulong)
                                    .wrapping_div(
                                        ::std::mem::size_of::<*const libc::c_char>()
                                            as libc::c_ulong,
                                    )
                            {
                                let mut val: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    feedback,
                                    keys[i_8 as usize],
                                    &mut val,
                                ) == 0)
                                {
                                    let mut i_9: libc::c_int = 0 as libc::c_int;
                                    while (i_9 as libc::c_ulong) < json_object_array_length(val)
                                    {
                                        let mut s_5: *mut json_object = json_object_array_get_idx(
                                            val,
                                            i_9 as size_t,
                                        );
                                        let mut feedbackSong: *mut PianoSong_t = 0
                                            as *mut PianoSong_t;
                                        feedbackSong = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        ) as *mut PianoSong_t;
                                        if feedbackSong.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*feedbackSong)
                                            .title = PianoJsonStrdup(
                                            s_5,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .artist = PianoJsonStrdup(
                                            s_5,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .feedbackId = PianoJsonStrdup(
                                            s_5,
                                            b"feedbackId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .rating = (if getBoolDefault(
                                            s_5,
                                            b"isPositive\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        ) as libc::c_int != 0
                                        {
                                            PIANO_RATE_LOVE as libc::c_int
                                        } else {
                                            PIANO_RATE_BAN as libc::c_int
                                        }) as PianoSongRating_t;
                                        let mut v_0: *mut json_object = 0 as *mut json_object;
                                        (*feedbackSong)
                                            .length = (if json_object_object_get_ex(
                                            s_5,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v_0,
                                        ) != 0
                                        {
                                            json_object_get_int(v_0)
                                        } else {
                                            0 as libc::c_int
                                        }) as libc::c_uint;
                                        (*info)
                                            .feedback = PianoListAppend(
                                            if ((*info).feedback).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*info).feedback).head
                                            },
                                            &mut (*feedbackSong).head,
                                        ) as *mut PianoSong_t;
                                        i_9 += 1;
                                        i_9;
                                    }
                                }
                                i_8 = i_8.wrapping_add(1);
                                i_8;
                            }
                        }
                    }
                    11202235766349324107 => {
                        let settings: *mut PianoSettings_t = (*req).data
                            as *mut PianoSettings_t;
                        (*settings)
                            .explicitContentFilter = getBoolDefault(
                            result,
                            b"isExplicitContentFilterEnabled\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int != 0,
                        );
                        (*settings)
                            .username = PianoJsonStrdup(
                            result,
                            b"username\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    145651165234646754 => {
                        let mut reqData_5: *mut PianoRequestDataExplain_t = (*req).data
                            as *mut PianoRequestDataExplain_t;
                        let strSize: size_t = 768 as libc::c_int as size_t;
                        let mut explanations: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"explanations\0" as *const u8 as *const libc::c_char,
                            &mut explanations,
                        ) != 0
                        {
                            (*reqData_5)
                                .retExplain = malloc(
                                strSize
                                    .wrapping_mul(
                                        ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                    ),
                            ) as *mut libc::c_char;
                            strncpy(
                                (*reqData_5).retExplain,
                                b"We're playing this track because it features \0"
                                    as *const u8 as *const libc::c_char,
                                strSize,
                            );
                            let mut i_5: libc::c_int = 0 as libc::c_int;
                            while (i_5 as libc::c_ulong)
                                < json_object_array_length(explanations)
                            {
                                let mut e: *mut json_object = json_object_array_get_idx(
                                    explanations,
                                    i_5 as size_t,
                                );
                                let mut f: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    e,
                                    b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                    &mut f,
                                ) == 0)
                                {
                                    let mut s_3: *const libc::c_char = json_object_get_string(
                                        f,
                                    );
                                    PianoStrpcat((*reqData_5).retExplain, s_3, strSize);
                                    if (i_5 as libc::c_ulong)
                                        < (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b", \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else if i_5 as libc::c_ulong
                                        == (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b" and \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b".\0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    }
                                }
                                i_5 += 1;
                                i_5;
                            }
                        }
                    }
                    9240481512215375588 => {
                        let mut station_0: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*station_0).isCreator = 1 as libc::c_int as libc::c_char;
                    }
                    5908482871227205451 => {
                        let mut categories: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"categories\0" as *const u8 as *const libc::c_char,
                            &mut categories,
                        ) != 0
                        {
                            let mut i_4: libc::c_int = 0 as libc::c_int;
                            while (i_4 as libc::c_ulong)
                                < json_object_array_length(categories)
                            {
                                let mut c: *mut json_object = json_object_array_get_idx(
                                    categories,
                                    i_4 as size_t,
                                );
                                let mut tmpGenreCategory: *mut PianoGenreCategory_t = 0
                                    as *mut PianoGenreCategory_t;
                                tmpGenreCategory = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoGenreCategory_t>()
                                        as libc::c_ulong,
                                ) as *mut PianoGenreCategory_t;
                                if tmpGenreCategory.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*tmpGenreCategory)
                                    .name = PianoJsonStrdup(
                                    c,
                                    b"categoryName\0" as *const u8 as *const libc::c_char,
                                );
                                let mut stations_0: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    c,
                                    b"stations\0" as *const u8 as *const libc::c_char,
                                    &mut stations_0,
                                ) != 0
                                {
                                    let mut k_0: libc::c_int = 0 as libc::c_int;
                                    while (k_0 as libc::c_ulong)
                                        < json_object_array_length(stations_0)
                                    {
                                        let mut s_2: *mut json_object = json_object_array_get_idx(
                                            stations_0,
                                            k_0 as size_t,
                                        );
                                        let mut tmpGenre: *mut PianoGenre_t = 0
                                            as *mut PianoGenre_t;
                                        tmpGenre = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                        ) as *mut PianoGenre_t;
                                        if tmpGenre.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*tmpGenre)
                                            .name = PianoJsonStrdup(
                                            s_2,
                                            b"stationName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenre)
                                            .musicId = PianoJsonStrdup(
                                            s_2,
                                            b"stationToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenreCategory)
                                            .genres = PianoListAppend(
                                            if ((*tmpGenreCategory).genres).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*tmpGenreCategory).genres).head
                                            },
                                            &mut (*tmpGenre).head,
                                        ) as *mut PianoGenre_t;
                                        k_0 += 1;
                                        k_0;
                                    }
                                }
                                (*ph)
                                    .genreStations = PianoListAppend(
                                    if ((*ph).genreStations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).genreStations).head
                                    },
                                    &mut (*tmpGenreCategory).head,
                                ) as *mut PianoGenreCategory_t;
                                i_4 += 1;
                                i_4;
                            }
                        }
                    }
                    5260680050201874961 => {
                        let song_1: *mut PianoSong_t = (*req).data as *mut PianoSong_t;
                        (*song_1).rating = PIANO_RATE_TIRED;
                    }
                    11235674318412060590 => {
                        let mut tmpStation_0: *mut PianoStation_t = 0
                            as *mut PianoStation_t;
                        tmpStation_0 = calloc(
                            1 as libc::c_int as libc::c_ulong,
                            ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                        ) as *mut PianoStation_t;
                        if tmpStation_0.is_null() {
                            return PIANO_RET_OUT_OF_MEMORY;
                        }
                        PianoJsonParseStation(result, tmpStation_0);
                        let mut search: *mut PianoStation_t = PianoFindStationById(
                            (*ph).stations,
                            (*tmpStation_0).id,
                        );
                        if !search.is_null() {
                            (*ph)
                                .stations = PianoListDelete(
                                if ((*ph).stations).is_null() {
                                    0 as *mut PianoListHead_t
                                } else {
                                    &mut (*(*ph).stations).head
                                },
                                &mut (*search).head,
                            ) as *mut PianoStation_t;
                            PianoDestroyStation(search);
                            free(search as *mut libc::c_void);
                        }
                        (*ph)
                            .stations = PianoListAppend(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*tmpStation_0).head,
                        ) as *mut PianoStation_t;
                    }
                    10109057886293123569 => {
                        let mut reqData_4: *mut PianoRequestDataSearch_t = (*req).data
                            as *mut PianoRequestDataSearch_t;
                        let mut searchResult: *mut PianoSearchResult_t = 0
                            as *mut PianoSearchResult_t;
                        searchResult = &mut (*reqData_4).searchResult;
                        memset(
                            searchResult as *mut libc::c_void,
                            0 as libc::c_int,
                            ::std::mem::size_of::<PianoSearchResult_t>() as libc::c_ulong,
                        );
                        let mut artists: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"artists\0" as *const u8 as *const libc::c_char,
                            &mut artists,
                        ) != 0
                        {
                            let mut i_2: libc::c_int = 0 as libc::c_int;
                            while (i_2 as libc::c_ulong)
                                < json_object_array_length(artists)
                            {
                                let mut a: *mut json_object = json_object_array_get_idx(
                                    artists,
                                    i_2 as size_t,
                                );
                                let mut artist: *mut PianoArtist_t = 0
                                    as *mut PianoArtist_t;
                                artist = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                ) as *mut PianoArtist_t;
                                if artist.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*artist)
                                    .name = PianoJsonStrdup(
                                    a,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*artist)
                                    .musicId = PianoJsonStrdup(
                                    a,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .artists = PianoListAppend(
                                    if ((*searchResult).artists).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).artists).head
                                    },
                                    &mut (*artist).head,
                                ) as *mut PianoArtist_t;
                                i_2 += 1;
                                i_2;
                            }
                        }
                        let mut songs: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"songs\0" as *const u8 as *const libc::c_char,
                            &mut songs,
                        ) != 0
                        {
                            let mut i_3: libc::c_int = 0 as libc::c_int;
                            while (i_3 as libc::c_ulong)
                                < json_object_array_length(songs)
                            {
                                let mut s_1: *mut json_object = json_object_array_get_idx(
                                    songs,
                                    i_3 as size_t,
                                );
                                let mut song_0: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song_0 = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song_0.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*song_0)
                                    .title = PianoJsonStrdup(
                                    s_1,
                                    b"songName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .artist = PianoJsonStrdup(
                                    s_1,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .musicId = PianoJsonStrdup(
                                    s_1,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .songs = PianoListAppend(
                                    if ((*searchResult).songs).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).songs).head
                                    },
                                    &mut (*song_0).head,
                                ) as *mut PianoSong_t;
                                i_3 += 1;
                                i_3;
                            }
                        }
                    }
                    4983594971376015098 => {
                        let mut station: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*ph)
                            .stations = PianoListDelete(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*station).head,
                        ) as *mut PianoStation_t;
                        PianoDestroyStation(station);
                        free(station as *mut libc::c_void);
                    }
                    17372050596571538954 => {
                        let mut reqData_3: *mut PianoRequestDataRenameStation_t = (*req)
                            .data as *mut PianoRequestDataRenameStation_t;
                        free((*(*reqData_3).station).name as *mut libc::c_void);
                        (*(*reqData_3).station).name = strdup((*reqData_3).newName);
                    }
                    7297078374430259003 => {
                        let mut reqData_2: *mut PianoRequestDataRateSong_t = (*req).data
                            as *mut PianoRequestDataRateSong_t;
                        (*(*reqData_2).song).rating = (*reqData_2).rating;
                    }
                    17075014677070940716 => {
                        let mut reqData_1: *mut PianoRequestDataGetPlaylist_t = (*req)
                            .data as *mut PianoRequestDataGetPlaylist_t;
                        let mut playlist: *mut PianoSong_t = 0 as *mut PianoSong_t;
                        let mut items: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"items\0" as *const u8 as *const libc::c_char,
                            &mut items,
                        ) == 0)
                        {
                            let mut i_1: libc::c_int = 0 as libc::c_int;
                            loop {
                                if !((i_1 as libc::c_ulong)
                                    < json_object_array_length(items))
                                {
                                    current_block = 4488496028633655612;
                                    break;
                                }
                                let mut s_0: *mut json_object = json_object_array_get_idx(
                                    items,
                                    i_1 as size_t,
                                );
                                let mut song: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                if json_object_object_get_ex(
                                    s_0,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                    0 as *mut *mut json_object,
                                ) == 0
                                {
                                    free(song as *mut libc::c_void);
                                } else {
                                    static mut qualityMap: [*const libc::c_char; 4] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"lowQuality\0" as *const u8 as *const libc::c_char,
                                        b"mediumQuality\0" as *const u8 as *const libc::c_char,
                                        b"highQuality\0" as *const u8 as *const libc::c_char,
                                    ];
                                    static mut formatMap: [*const libc::c_char; 3] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"aacplus\0" as *const u8 as *const libc::c_char,
                                        b"mp3\0" as *const u8 as *const libc::c_char,
                                    ];
                                    let mut umap: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        s_0,
                                        b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                        &mut umap,
                                    ) != 0
                                    {
                                        let mut jsonEncoding: *mut json_object = 0
                                            as *mut json_object;
                                        let mut qmap: *mut json_object = 0 as *mut json_object;
                                        if json_object_object_get_ex(
                                            umap,
                                            qualityMap[(*reqData_1).quality as usize],
                                            &mut qmap,
                                        ) != 0
                                            && json_object_object_get_ex(
                                                qmap,
                                                b"encoding\0" as *const u8 as *const libc::c_char,
                                                &mut jsonEncoding,
                                            ) != 0
                                        {
                                            let mut encoding: *const libc::c_char = json_object_get_string(
                                                jsonEncoding,
                                            );
                                            let mut k: size_t = 0 as libc::c_int as size_t;
                                            while k
                                                < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                    as libc::c_ulong)
                                                    .wrapping_div(
                                                        ::std::mem::size_of::<*const libc::c_char>()
                                                            as libc::c_ulong,
                                                    )
                                            {
                                                if strcmp(formatMap[k as usize], encoding)
                                                    == 0 as libc::c_int
                                                {
                                                    (*song).audioFormat = k as PianoAudioFormat_t;
                                                    break;
                                                } else {
                                                    k = k.wrapping_add(1);
                                                    k;
                                                }
                                            }
                                            (*song)
                                                .audioUrl = PianoJsonStrdup(
                                                qmap,
                                                b"audioUrl\0" as *const u8 as *const libc::c_char,
                                            );
                                        } else {
                                            ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                            free(song as *mut libc::c_void);
                                            PianoDestroyPlaylist(playlist);
                                            current_block = 9169893888141833765;
                                            break;
                                        }
                                    }
                                    let mut v: *mut json_object = 0 as *mut json_object;
                                    (*song)
                                        .artist = PianoJsonStrdup(
                                        s_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .album = PianoJsonStrdup(
                                        s_0,
                                        b"albumName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .title = PianoJsonStrdup(
                                        s_0,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .trackToken = PianoJsonStrdup(
                                        s_0,
                                        b"trackToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .stationId = PianoJsonStrdup(
                                        s_0,
                                        b"stationId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .coverArt = PianoJsonStrdup(
                                        s_0,
                                        b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .detailUrl = PianoJsonStrdup(
                                        s_0,
                                        b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .fileGain = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackGain\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_double(v)
                                    } else {
                                        0.0f64
                                    }) as libc::c_float;
                                    (*song)
                                        .length = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackLength\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    }) as libc::c_uint;
                                    match if json_object_object_get_ex(
                                        s_0,
                                        b"songRating\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    } {
                                        1 => {
                                            (*song).rating = PIANO_RATE_LOVE;
                                        }
                                        _ => {}
                                    }
                                    playlist = PianoListAppend(
                                        if playlist.is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*playlist).head
                                        },
                                        &mut (*song).head,
                                    ) as *mut PianoSong_t;
                                }
                                i_1 += 1;
                                i_1;
                            }
                            match current_block {
                                9169893888141833765 => {}
                                _ => {
                                    (*reqData_1).retPlaylist = playlist;
                                }
                            }
                        }
                    }
                    6450597802325118133 => {
                        let mut stations: *mut json_object = 0 as *mut json_object;
                        let mut mix: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"stations\0" as *const u8 as *const libc::c_char,
                            &mut stations,
                        ) == 0)
                        {
                            let mut i: libc::c_int = 0 as libc::c_int;
                            while (i as libc::c_ulong)
                                < json_object_array_length(stations)
                            {
                                let mut tmpStation: *mut PianoStation_t = 0
                                    as *mut PianoStation_t;
                                let mut s: *mut json_object = json_object_array_get_idx(
                                    stations,
                                    i as size_t,
                                );
                                tmpStation = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                ) as *mut PianoStation_t;
                                if tmpStation.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                PianoJsonParseStation(s, tmpStation);
                                if (*tmpStation).isQuickMix != 0 {
                                    json_object_object_get_ex(
                                        s,
                                        b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                        &mut mix,
                                    );
                                }
                                (*ph)
                                    .stations = PianoListAppend(
                                    if ((*ph).stations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).stations).head
                                    },
                                    &mut (*tmpStation).head,
                                ) as *mut PianoStation_t;
                                i += 1;
                                i;
                            }
                            if !mix.is_null() {
                                let mut curStation: *mut PianoStation_t = (*ph).stations;
                                while !curStation.is_null() {
                                    let mut i_0: libc::c_int = 0 as libc::c_int;
                                    while (i_0 as libc::c_ulong) < json_object_array_length(mix)
                                    {
                                        let mut id: *mut json_object = json_object_array_get_idx(
                                            mix,
                                            i_0 as size_t,
                                        );
                                        if strcmp(json_object_get_string(id), (*curStation).id)
                                            == 0 as libc::c_int
                                        {
                                            (*curStation)
                                                .useQuickMix = 1 as libc::c_int as libc::c_char;
                                        }
                                        i_0 += 1;
                                        i_0;
                                    }
                                    curStation = (*curStation).head.next as *mut libc::c_void
                                        as *mut PianoStation_t;
                                }
                            }
                        }
                    }
                    12039483399334584727 => {
                        let mut reqData_0: *mut PianoRequestDataLogin_t = (*req).data
                            as *mut PianoRequestDataLogin_t;
                        match (*reqData_0).step as libc::c_int {
                            0 => {
                                let mut jsonTimestamp: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    result,
                                    b"syncTime\0" as *const u8 as *const libc::c_char,
                                    &mut jsonTimestamp,
                                ) == 0
                                {
                                    ret = PIANO_RET_INVALID_RESPONSE;
                                } else {
                                    let cryptedTimestamp: *const libc::c_char = json_object_get_string(
                                        jsonTimestamp,
                                    );
                                    let realTimestamp: time_t = time(0 as *mut time_t);
                                    let mut decryptedTimestamp: *mut libc::c_char = 0
                                        as *mut libc::c_char;
                                    let mut decryptedSize: size_t = 0;
                                    ret = PIANO_RET_ERR;
                                    decryptedTimestamp = PianoDecryptString(
                                        (*ph).partner.in_0,
                                        cryptedTimestamp,
                                        &mut decryptedSize,
                                    );
                                    if !decryptedTimestamp.is_null()
                                        && decryptedSize > 4 as libc::c_int as libc::c_ulong
                                    {
                                        let timestamp: libc::c_ulong = strtoul(
                                            decryptedTimestamp.offset(4 as libc::c_int as isize),
                                            0 as *mut *mut libc::c_char,
                                            0 as libc::c_int,
                                        );
                                        (*ph)
                                            .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                            as libc::c_int;
                                        ret = PIANO_RET_CONTINUE_REQUEST;
                                    }
                                    free(decryptedTimestamp as *mut libc::c_void);
                                    (*ph)
                                        .partner
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    let mut partnerId: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        result,
                                        b"partnerId\0" as *const u8 as *const libc::c_char,
                                        &mut partnerId,
                                    ) == 0
                                    {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        (*ph)
                                            .partner
                                            .id = json_object_get_int(partnerId) as libc::c_uint;
                                        (*reqData_0).step = ((*reqData_0).step).wrapping_add(1);
                                        (*reqData_0).step;
                                    }
                                }
                            }
                            1 => {
                                if !((*ph).user.listenerId).is_null() {
                                    PianoDestroyUserInfo(&mut (*ph).user);
                                }
                                (*ph)
                                    .user
                                    .listenerId = PianoJsonStrdup(
                                    result,
                                    b"userId\0" as *const u8 as *const libc::c_char,
                                );
                                (*ph)
                                    .user
                                    .authToken = PianoJsonStrdup(
                                    result,
                                    b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                );
                            }
                            _ => {}
                        }
                    }
                    10223170376184624358 => {
                        let mut reqData_8: *mut PianoRequestDataSetStationMode_t = (*req)
                            .data as *mut PianoRequestDataSetStationMode_t;
                        let mut active_0: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode_0: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode_0,
                        ) != 0
                        {
                            active_0 = json_object_get_int(activeMode_0);
                        }
                        if active_0 as libc::c_uint != (*reqData_8).id {
                            return PIANO_RET_ERR;
                        }
                    }
                    _ => {
                        let mut reqData_7: *mut PianoRequestDataGetStationModes_t = (*req)
                            .data as *mut PianoRequestDataGetStationModes_t;
                        let mut active: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode,
                        ) != 0
                        {
                            active = json_object_get_int(activeMode);
                        }
                        let mut availableModes: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"availableModes\0" as *const u8 as *const libc::c_char,
                            &mut availableModes,
                        ) != 0
                        {
                            let mut i_10: libc::c_int = 0 as libc::c_int;
                            while (i_10 as libc::c_ulong)
                                < json_object_array_length(availableModes)
                            {
                                let mut val_0: *mut json_object = json_object_array_get_idx(
                                    availableModes,
                                    i_10 as size_t,
                                );
                                let mut mode: *mut PianoStationMode_t = 0
                                    as *mut PianoStationMode_t;
                                mode = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                ) as *mut PianoStationMode_t;
                                if mode.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                let mut modeId: *mut json_object = 0 as *mut json_object;
                                if json_object_object_get_ex(
                                    val_0,
                                    b"modeId\0" as *const u8 as *const libc::c_char,
                                    &mut modeId,
                                ) != 0
                                {
                                    (*mode).id = json_object_get_int(modeId);
                                    (*mode)
                                        .name = PianoJsonStrdup(
                                        val_0,
                                        b"modeName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .description = PianoJsonStrdup(
                                        val_0,
                                        b"modeDescription\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .isAlgorithmic = getBoolDefault(
                                        val_0,
                                        b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode)
                                        .isTakeover = getBoolDefault(
                                        val_0,
                                        b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode).active = active == (*mode).id;
                                }
                                (*reqData_7)
                                    .retModes = PianoListAppend(
                                    if ((*reqData_7).retModes).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*reqData_7).retModes).head
                                    },
                                    &mut (*mode).head,
                                ) as *mut PianoStationMode_t;
                                i_10 += 1;
                                i_10;
                            }
                        }
                    }
                }
            }
            20 => {
                current_block = 4367030874028593650;
                match current_block {
                    14870924983410776565 => {}
                    4367030874028593650 => {
                        let mut reqData_6: *mut PianoRequestDataGetStationInfo_t = (*req)
                            .data as *mut PianoRequestDataGetStationInfo_t;
                        let mut info: *mut PianoStationInfo_t = 0
                            as *mut PianoStationInfo_t;
                        info = &mut (*reqData_6).info;
                        let mut music: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"music\0" as *const u8 as *const libc::c_char,
                            &mut music,
                        ) != 0
                        {
                            let mut songs_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs_0,
                            ) != 0
                            {
                                let mut i_6: libc::c_int = 0 as libc::c_int;
                                while (i_6 as libc::c_ulong)
                                    < json_object_array_length(songs_0)
                                {
                                    let mut s_4: *mut json_object = json_object_array_get_idx(
                                        songs_0,
                                        i_6 as size_t,
                                    );
                                    let mut seedSong: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                    seedSong = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    ) as *mut PianoSong_t;
                                    if seedSong.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedSong)
                                        .title = PianoJsonStrdup(
                                        s_4,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .artist = PianoJsonStrdup(
                                        s_4,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .seedId = PianoJsonStrdup(
                                        s_4,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .songSeeds = PianoListAppend(
                                        if ((*info).songSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).songSeeds).head
                                        },
                                        &mut (*seedSong).head,
                                    ) as *mut PianoSong_t;
                                    i_6 += 1;
                                    i_6;
                                }
                            }
                            let mut artists_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists_0,
                            ) != 0
                            {
                                let mut i_7: libc::c_int = 0 as libc::c_int;
                                while (i_7 as libc::c_ulong)
                                    < json_object_array_length(artists_0)
                                {
                                    let mut a_0: *mut json_object = json_object_array_get_idx(
                                        artists_0,
                                        i_7 as size_t,
                                    );
                                    let mut seedArtist: *mut PianoArtist_t = 0
                                        as *mut PianoArtist_t;
                                    seedArtist = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    ) as *mut PianoArtist_t;
                                    if seedArtist.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedArtist)
                                        .name = PianoJsonStrdup(
                                        a_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedArtist)
                                        .seedId = PianoJsonStrdup(
                                        a_0,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .artistSeeds = PianoListAppend(
                                        if ((*info).artistSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).artistSeeds).head
                                        },
                                        &mut (*seedArtist).head,
                                    ) as *mut PianoArtist_t;
                                    i_7 += 1;
                                    i_7;
                                }
                            }
                        }
                        let mut feedback: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"feedback\0" as *const u8 as *const libc::c_char,
                            &mut feedback,
                        ) != 0
                        {
                            static mut keys: [*const libc::c_char; 2] = [
                                b"thumbsUp\0" as *const u8 as *const libc::c_char,
                                b"thumbsDown\0" as *const u8 as *const libc::c_char,
                            ];
                            let mut i_8: size_t = 0 as libc::c_int as size_t;
                            while i_8
                                < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                    as libc::c_ulong)
                                    .wrapping_div(
                                        ::std::mem::size_of::<*const libc::c_char>()
                                            as libc::c_ulong,
                                    )
                            {
                                let mut val: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    feedback,
                                    keys[i_8 as usize],
                                    &mut val,
                                ) == 0)
                                {
                                    let mut i_9: libc::c_int = 0 as libc::c_int;
                                    while (i_9 as libc::c_ulong) < json_object_array_length(val)
                                    {
                                        let mut s_5: *mut json_object = json_object_array_get_idx(
                                            val,
                                            i_9 as size_t,
                                        );
                                        let mut feedbackSong: *mut PianoSong_t = 0
                                            as *mut PianoSong_t;
                                        feedbackSong = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        ) as *mut PianoSong_t;
                                        if feedbackSong.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*feedbackSong)
                                            .title = PianoJsonStrdup(
                                            s_5,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .artist = PianoJsonStrdup(
                                            s_5,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .feedbackId = PianoJsonStrdup(
                                            s_5,
                                            b"feedbackId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .rating = (if getBoolDefault(
                                            s_5,
                                            b"isPositive\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        ) as libc::c_int != 0
                                        {
                                            PIANO_RATE_LOVE as libc::c_int
                                        } else {
                                            PIANO_RATE_BAN as libc::c_int
                                        }) as PianoSongRating_t;
                                        let mut v_0: *mut json_object = 0 as *mut json_object;
                                        (*feedbackSong)
                                            .length = (if json_object_object_get_ex(
                                            s_5,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v_0,
                                        ) != 0
                                        {
                                            json_object_get_int(v_0)
                                        } else {
                                            0 as libc::c_int
                                        }) as libc::c_uint;
                                        (*info)
                                            .feedback = PianoListAppend(
                                            if ((*info).feedback).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*info).feedback).head
                                            },
                                            &mut (*feedbackSong).head,
                                        ) as *mut PianoSong_t;
                                        i_9 += 1;
                                        i_9;
                                    }
                                }
                                i_8 = i_8.wrapping_add(1);
                                i_8;
                            }
                        }
                    }
                    11202235766349324107 => {
                        let settings: *mut PianoSettings_t = (*req).data
                            as *mut PianoSettings_t;
                        (*settings)
                            .explicitContentFilter = getBoolDefault(
                            result,
                            b"isExplicitContentFilterEnabled\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int != 0,
                        );
                        (*settings)
                            .username = PianoJsonStrdup(
                            result,
                            b"username\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    145651165234646754 => {
                        let mut reqData_5: *mut PianoRequestDataExplain_t = (*req).data
                            as *mut PianoRequestDataExplain_t;
                        let strSize: size_t = 768 as libc::c_int as size_t;
                        let mut explanations: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"explanations\0" as *const u8 as *const libc::c_char,
                            &mut explanations,
                        ) != 0
                        {
                            (*reqData_5)
                                .retExplain = malloc(
                                strSize
                                    .wrapping_mul(
                                        ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                    ),
                            ) as *mut libc::c_char;
                            strncpy(
                                (*reqData_5).retExplain,
                                b"We're playing this track because it features \0"
                                    as *const u8 as *const libc::c_char,
                                strSize,
                            );
                            let mut i_5: libc::c_int = 0 as libc::c_int;
                            while (i_5 as libc::c_ulong)
                                < json_object_array_length(explanations)
                            {
                                let mut e: *mut json_object = json_object_array_get_idx(
                                    explanations,
                                    i_5 as size_t,
                                );
                                let mut f: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    e,
                                    b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                    &mut f,
                                ) == 0)
                                {
                                    let mut s_3: *const libc::c_char = json_object_get_string(
                                        f,
                                    );
                                    PianoStrpcat((*reqData_5).retExplain, s_3, strSize);
                                    if (i_5 as libc::c_ulong)
                                        < (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b", \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else if i_5 as libc::c_ulong
                                        == (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b" and \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b".\0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    }
                                }
                                i_5 += 1;
                                i_5;
                            }
                        }
                    }
                    9240481512215375588 => {
                        let mut station_0: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*station_0).isCreator = 1 as libc::c_int as libc::c_char;
                    }
                    5908482871227205451 => {
                        let mut categories: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"categories\0" as *const u8 as *const libc::c_char,
                            &mut categories,
                        ) != 0
                        {
                            let mut i_4: libc::c_int = 0 as libc::c_int;
                            while (i_4 as libc::c_ulong)
                                < json_object_array_length(categories)
                            {
                                let mut c: *mut json_object = json_object_array_get_idx(
                                    categories,
                                    i_4 as size_t,
                                );
                                let mut tmpGenreCategory: *mut PianoGenreCategory_t = 0
                                    as *mut PianoGenreCategory_t;
                                tmpGenreCategory = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoGenreCategory_t>()
                                        as libc::c_ulong,
                                ) as *mut PianoGenreCategory_t;
                                if tmpGenreCategory.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*tmpGenreCategory)
                                    .name = PianoJsonStrdup(
                                    c,
                                    b"categoryName\0" as *const u8 as *const libc::c_char,
                                );
                                let mut stations_0: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    c,
                                    b"stations\0" as *const u8 as *const libc::c_char,
                                    &mut stations_0,
                                ) != 0
                                {
                                    let mut k_0: libc::c_int = 0 as libc::c_int;
                                    while (k_0 as libc::c_ulong)
                                        < json_object_array_length(stations_0)
                                    {
                                        let mut s_2: *mut json_object = json_object_array_get_idx(
                                            stations_0,
                                            k_0 as size_t,
                                        );
                                        let mut tmpGenre: *mut PianoGenre_t = 0
                                            as *mut PianoGenre_t;
                                        tmpGenre = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                        ) as *mut PianoGenre_t;
                                        if tmpGenre.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*tmpGenre)
                                            .name = PianoJsonStrdup(
                                            s_2,
                                            b"stationName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenre)
                                            .musicId = PianoJsonStrdup(
                                            s_2,
                                            b"stationToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenreCategory)
                                            .genres = PianoListAppend(
                                            if ((*tmpGenreCategory).genres).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*tmpGenreCategory).genres).head
                                            },
                                            &mut (*tmpGenre).head,
                                        ) as *mut PianoGenre_t;
                                        k_0 += 1;
                                        k_0;
                                    }
                                }
                                (*ph)
                                    .genreStations = PianoListAppend(
                                    if ((*ph).genreStations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).genreStations).head
                                    },
                                    &mut (*tmpGenreCategory).head,
                                ) as *mut PianoGenreCategory_t;
                                i_4 += 1;
                                i_4;
                            }
                        }
                    }
                    5260680050201874961 => {
                        let song_1: *mut PianoSong_t = (*req).data as *mut PianoSong_t;
                        (*song_1).rating = PIANO_RATE_TIRED;
                    }
                    11235674318412060590 => {
                        let mut tmpStation_0: *mut PianoStation_t = 0
                            as *mut PianoStation_t;
                        tmpStation_0 = calloc(
                            1 as libc::c_int as libc::c_ulong,
                            ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                        ) as *mut PianoStation_t;
                        if tmpStation_0.is_null() {
                            return PIANO_RET_OUT_OF_MEMORY;
                        }
                        PianoJsonParseStation(result, tmpStation_0);
                        let mut search: *mut PianoStation_t = PianoFindStationById(
                            (*ph).stations,
                            (*tmpStation_0).id,
                        );
                        if !search.is_null() {
                            (*ph)
                                .stations = PianoListDelete(
                                if ((*ph).stations).is_null() {
                                    0 as *mut PianoListHead_t
                                } else {
                                    &mut (*(*ph).stations).head
                                },
                                &mut (*search).head,
                            ) as *mut PianoStation_t;
                            PianoDestroyStation(search);
                            free(search as *mut libc::c_void);
                        }
                        (*ph)
                            .stations = PianoListAppend(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*tmpStation_0).head,
                        ) as *mut PianoStation_t;
                    }
                    10109057886293123569 => {
                        let mut reqData_4: *mut PianoRequestDataSearch_t = (*req).data
                            as *mut PianoRequestDataSearch_t;
                        let mut searchResult: *mut PianoSearchResult_t = 0
                            as *mut PianoSearchResult_t;
                        searchResult = &mut (*reqData_4).searchResult;
                        memset(
                            searchResult as *mut libc::c_void,
                            0 as libc::c_int,
                            ::std::mem::size_of::<PianoSearchResult_t>() as libc::c_ulong,
                        );
                        let mut artists: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"artists\0" as *const u8 as *const libc::c_char,
                            &mut artists,
                        ) != 0
                        {
                            let mut i_2: libc::c_int = 0 as libc::c_int;
                            while (i_2 as libc::c_ulong)
                                < json_object_array_length(artists)
                            {
                                let mut a: *mut json_object = json_object_array_get_idx(
                                    artists,
                                    i_2 as size_t,
                                );
                                let mut artist: *mut PianoArtist_t = 0
                                    as *mut PianoArtist_t;
                                artist = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                ) as *mut PianoArtist_t;
                                if artist.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*artist)
                                    .name = PianoJsonStrdup(
                                    a,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*artist)
                                    .musicId = PianoJsonStrdup(
                                    a,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .artists = PianoListAppend(
                                    if ((*searchResult).artists).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).artists).head
                                    },
                                    &mut (*artist).head,
                                ) as *mut PianoArtist_t;
                                i_2 += 1;
                                i_2;
                            }
                        }
                        let mut songs: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"songs\0" as *const u8 as *const libc::c_char,
                            &mut songs,
                        ) != 0
                        {
                            let mut i_3: libc::c_int = 0 as libc::c_int;
                            while (i_3 as libc::c_ulong)
                                < json_object_array_length(songs)
                            {
                                let mut s_1: *mut json_object = json_object_array_get_idx(
                                    songs,
                                    i_3 as size_t,
                                );
                                let mut song_0: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song_0 = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song_0.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*song_0)
                                    .title = PianoJsonStrdup(
                                    s_1,
                                    b"songName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .artist = PianoJsonStrdup(
                                    s_1,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .musicId = PianoJsonStrdup(
                                    s_1,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .songs = PianoListAppend(
                                    if ((*searchResult).songs).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).songs).head
                                    },
                                    &mut (*song_0).head,
                                ) as *mut PianoSong_t;
                                i_3 += 1;
                                i_3;
                            }
                        }
                    }
                    4983594971376015098 => {
                        let mut station: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*ph)
                            .stations = PianoListDelete(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*station).head,
                        ) as *mut PianoStation_t;
                        PianoDestroyStation(station);
                        free(station as *mut libc::c_void);
                    }
                    17372050596571538954 => {
                        let mut reqData_3: *mut PianoRequestDataRenameStation_t = (*req)
                            .data as *mut PianoRequestDataRenameStation_t;
                        free((*(*reqData_3).station).name as *mut libc::c_void);
                        (*(*reqData_3).station).name = strdup((*reqData_3).newName);
                    }
                    7297078374430259003 => {
                        let mut reqData_2: *mut PianoRequestDataRateSong_t = (*req).data
                            as *mut PianoRequestDataRateSong_t;
                        (*(*reqData_2).song).rating = (*reqData_2).rating;
                    }
                    17075014677070940716 => {
                        let mut reqData_1: *mut PianoRequestDataGetPlaylist_t = (*req)
                            .data as *mut PianoRequestDataGetPlaylist_t;
                        let mut playlist: *mut PianoSong_t = 0 as *mut PianoSong_t;
                        let mut items: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"items\0" as *const u8 as *const libc::c_char,
                            &mut items,
                        ) == 0)
                        {
                            let mut i_1: libc::c_int = 0 as libc::c_int;
                            loop {
                                if !((i_1 as libc::c_ulong)
                                    < json_object_array_length(items))
                                {
                                    current_block = 4488496028633655612;
                                    break;
                                }
                                let mut s_0: *mut json_object = json_object_array_get_idx(
                                    items,
                                    i_1 as size_t,
                                );
                                let mut song: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                if json_object_object_get_ex(
                                    s_0,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                    0 as *mut *mut json_object,
                                ) == 0
                                {
                                    free(song as *mut libc::c_void);
                                } else {
                                    static mut qualityMap: [*const libc::c_char; 4] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"lowQuality\0" as *const u8 as *const libc::c_char,
                                        b"mediumQuality\0" as *const u8 as *const libc::c_char,
                                        b"highQuality\0" as *const u8 as *const libc::c_char,
                                    ];
                                    static mut formatMap: [*const libc::c_char; 3] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"aacplus\0" as *const u8 as *const libc::c_char,
                                        b"mp3\0" as *const u8 as *const libc::c_char,
                                    ];
                                    let mut umap: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        s_0,
                                        b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                        &mut umap,
                                    ) != 0
                                    {
                                        let mut jsonEncoding: *mut json_object = 0
                                            as *mut json_object;
                                        let mut qmap: *mut json_object = 0 as *mut json_object;
                                        if json_object_object_get_ex(
                                            umap,
                                            qualityMap[(*reqData_1).quality as usize],
                                            &mut qmap,
                                        ) != 0
                                            && json_object_object_get_ex(
                                                qmap,
                                                b"encoding\0" as *const u8 as *const libc::c_char,
                                                &mut jsonEncoding,
                                            ) != 0
                                        {
                                            let mut encoding: *const libc::c_char = json_object_get_string(
                                                jsonEncoding,
                                            );
                                            let mut k: size_t = 0 as libc::c_int as size_t;
                                            while k
                                                < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                    as libc::c_ulong)
                                                    .wrapping_div(
                                                        ::std::mem::size_of::<*const libc::c_char>()
                                                            as libc::c_ulong,
                                                    )
                                            {
                                                if strcmp(formatMap[k as usize], encoding)
                                                    == 0 as libc::c_int
                                                {
                                                    (*song).audioFormat = k as PianoAudioFormat_t;
                                                    break;
                                                } else {
                                                    k = k.wrapping_add(1);
                                                    k;
                                                }
                                            }
                                            (*song)
                                                .audioUrl = PianoJsonStrdup(
                                                qmap,
                                                b"audioUrl\0" as *const u8 as *const libc::c_char,
                                            );
                                        } else {
                                            ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                            free(song as *mut libc::c_void);
                                            PianoDestroyPlaylist(playlist);
                                            current_block = 9169893888141833765;
                                            break;
                                        }
                                    }
                                    let mut v: *mut json_object = 0 as *mut json_object;
                                    (*song)
                                        .artist = PianoJsonStrdup(
                                        s_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .album = PianoJsonStrdup(
                                        s_0,
                                        b"albumName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .title = PianoJsonStrdup(
                                        s_0,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .trackToken = PianoJsonStrdup(
                                        s_0,
                                        b"trackToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .stationId = PianoJsonStrdup(
                                        s_0,
                                        b"stationId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .coverArt = PianoJsonStrdup(
                                        s_0,
                                        b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .detailUrl = PianoJsonStrdup(
                                        s_0,
                                        b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .fileGain = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackGain\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_double(v)
                                    } else {
                                        0.0f64
                                    }) as libc::c_float;
                                    (*song)
                                        .length = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackLength\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    }) as libc::c_uint;
                                    match if json_object_object_get_ex(
                                        s_0,
                                        b"songRating\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    } {
                                        1 => {
                                            (*song).rating = PIANO_RATE_LOVE;
                                        }
                                        _ => {}
                                    }
                                    playlist = PianoListAppend(
                                        if playlist.is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*playlist).head
                                        },
                                        &mut (*song).head,
                                    ) as *mut PianoSong_t;
                                }
                                i_1 += 1;
                                i_1;
                            }
                            match current_block {
                                9169893888141833765 => {}
                                _ => {
                                    (*reqData_1).retPlaylist = playlist;
                                }
                            }
                        }
                    }
                    6450597802325118133 => {
                        let mut stations: *mut json_object = 0 as *mut json_object;
                        let mut mix: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"stations\0" as *const u8 as *const libc::c_char,
                            &mut stations,
                        ) == 0)
                        {
                            let mut i: libc::c_int = 0 as libc::c_int;
                            while (i as libc::c_ulong)
                                < json_object_array_length(stations)
                            {
                                let mut tmpStation: *mut PianoStation_t = 0
                                    as *mut PianoStation_t;
                                let mut s: *mut json_object = json_object_array_get_idx(
                                    stations,
                                    i as size_t,
                                );
                                tmpStation = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                ) as *mut PianoStation_t;
                                if tmpStation.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                PianoJsonParseStation(s, tmpStation);
                                if (*tmpStation).isQuickMix != 0 {
                                    json_object_object_get_ex(
                                        s,
                                        b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                        &mut mix,
                                    );
                                }
                                (*ph)
                                    .stations = PianoListAppend(
                                    if ((*ph).stations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).stations).head
                                    },
                                    &mut (*tmpStation).head,
                                ) as *mut PianoStation_t;
                                i += 1;
                                i;
                            }
                            if !mix.is_null() {
                                let mut curStation: *mut PianoStation_t = (*ph).stations;
                                while !curStation.is_null() {
                                    let mut i_0: libc::c_int = 0 as libc::c_int;
                                    while (i_0 as libc::c_ulong) < json_object_array_length(mix)
                                    {
                                        let mut id: *mut json_object = json_object_array_get_idx(
                                            mix,
                                            i_0 as size_t,
                                        );
                                        if strcmp(json_object_get_string(id), (*curStation).id)
                                            == 0 as libc::c_int
                                        {
                                            (*curStation)
                                                .useQuickMix = 1 as libc::c_int as libc::c_char;
                                        }
                                        i_0 += 1;
                                        i_0;
                                    }
                                    curStation = (*curStation).head.next as *mut libc::c_void
                                        as *mut PianoStation_t;
                                }
                            }
                        }
                    }
                    12039483399334584727 => {
                        let mut reqData_0: *mut PianoRequestDataLogin_t = (*req).data
                            as *mut PianoRequestDataLogin_t;
                        match (*reqData_0).step as libc::c_int {
                            0 => {
                                let mut jsonTimestamp: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    result,
                                    b"syncTime\0" as *const u8 as *const libc::c_char,
                                    &mut jsonTimestamp,
                                ) == 0
                                {
                                    ret = PIANO_RET_INVALID_RESPONSE;
                                } else {
                                    let cryptedTimestamp: *const libc::c_char = json_object_get_string(
                                        jsonTimestamp,
                                    );
                                    let realTimestamp: time_t = time(0 as *mut time_t);
                                    let mut decryptedTimestamp: *mut libc::c_char = 0
                                        as *mut libc::c_char;
                                    let mut decryptedSize: size_t = 0;
                                    ret = PIANO_RET_ERR;
                                    decryptedTimestamp = PianoDecryptString(
                                        (*ph).partner.in_0,
                                        cryptedTimestamp,
                                        &mut decryptedSize,
                                    );
                                    if !decryptedTimestamp.is_null()
                                        && decryptedSize > 4 as libc::c_int as libc::c_ulong
                                    {
                                        let timestamp: libc::c_ulong = strtoul(
                                            decryptedTimestamp.offset(4 as libc::c_int as isize),
                                            0 as *mut *mut libc::c_char,
                                            0 as libc::c_int,
                                        );
                                        (*ph)
                                            .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                            as libc::c_int;
                                        ret = PIANO_RET_CONTINUE_REQUEST;
                                    }
                                    free(decryptedTimestamp as *mut libc::c_void);
                                    (*ph)
                                        .partner
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    let mut partnerId: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        result,
                                        b"partnerId\0" as *const u8 as *const libc::c_char,
                                        &mut partnerId,
                                    ) == 0
                                    {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        (*ph)
                                            .partner
                                            .id = json_object_get_int(partnerId) as libc::c_uint;
                                        (*reqData_0).step = ((*reqData_0).step).wrapping_add(1);
                                        (*reqData_0).step;
                                    }
                                }
                            }
                            1 => {
                                if !((*ph).user.listenerId).is_null() {
                                    PianoDestroyUserInfo(&mut (*ph).user);
                                }
                                (*ph)
                                    .user
                                    .listenerId = PianoJsonStrdup(
                                    result,
                                    b"userId\0" as *const u8 as *const libc::c_char,
                                );
                                (*ph)
                                    .user
                                    .authToken = PianoJsonStrdup(
                                    result,
                                    b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                );
                            }
                            _ => {}
                        }
                    }
                    10223170376184624358 => {
                        let mut reqData_8: *mut PianoRequestDataSetStationMode_t = (*req)
                            .data as *mut PianoRequestDataSetStationMode_t;
                        let mut active_0: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode_0: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode_0,
                        ) != 0
                        {
                            active_0 = json_object_get_int(activeMode_0);
                        }
                        if active_0 as libc::c_uint != (*reqData_8).id {
                            return PIANO_RET_ERR;
                        }
                    }
                    _ => {
                        let mut reqData_7: *mut PianoRequestDataGetStationModes_t = (*req)
                            .data as *mut PianoRequestDataGetStationModes_t;
                        let mut active: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode,
                        ) != 0
                        {
                            active = json_object_get_int(activeMode);
                        }
                        let mut availableModes: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"availableModes\0" as *const u8 as *const libc::c_char,
                            &mut availableModes,
                        ) != 0
                        {
                            let mut i_10: libc::c_int = 0 as libc::c_int;
                            while (i_10 as libc::c_ulong)
                                < json_object_array_length(availableModes)
                            {
                                let mut val_0: *mut json_object = json_object_array_get_idx(
                                    availableModes,
                                    i_10 as size_t,
                                );
                                let mut mode: *mut PianoStationMode_t = 0
                                    as *mut PianoStationMode_t;
                                mode = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                ) as *mut PianoStationMode_t;
                                if mode.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                let mut modeId: *mut json_object = 0 as *mut json_object;
                                if json_object_object_get_ex(
                                    val_0,
                                    b"modeId\0" as *const u8 as *const libc::c_char,
                                    &mut modeId,
                                ) != 0
                                {
                                    (*mode).id = json_object_get_int(modeId);
                                    (*mode)
                                        .name = PianoJsonStrdup(
                                        val_0,
                                        b"modeName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .description = PianoJsonStrdup(
                                        val_0,
                                        b"modeDescription\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .isAlgorithmic = getBoolDefault(
                                        val_0,
                                        b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode)
                                        .isTakeover = getBoolDefault(
                                        val_0,
                                        b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode).active = active == (*mode).id;
                                }
                                (*reqData_7)
                                    .retModes = PianoListAppend(
                                    if ((*reqData_7).retModes).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*reqData_7).retModes).head
                                    },
                                    &mut (*mode).head,
                                ) as *mut PianoStationMode_t;
                                i_10 += 1;
                                i_10;
                            }
                        }
                    }
                }
            }
            25 => {
                current_block = 17034918949615525785;
                match current_block {
                    14870924983410776565 => {}
                    4367030874028593650 => {
                        let mut reqData_6: *mut PianoRequestDataGetStationInfo_t = (*req)
                            .data as *mut PianoRequestDataGetStationInfo_t;
                        let mut info: *mut PianoStationInfo_t = 0
                            as *mut PianoStationInfo_t;
                        info = &mut (*reqData_6).info;
                        let mut music: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"music\0" as *const u8 as *const libc::c_char,
                            &mut music,
                        ) != 0
                        {
                            let mut songs_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs_0,
                            ) != 0
                            {
                                let mut i_6: libc::c_int = 0 as libc::c_int;
                                while (i_6 as libc::c_ulong)
                                    < json_object_array_length(songs_0)
                                {
                                    let mut s_4: *mut json_object = json_object_array_get_idx(
                                        songs_0,
                                        i_6 as size_t,
                                    );
                                    let mut seedSong: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                    seedSong = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    ) as *mut PianoSong_t;
                                    if seedSong.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedSong)
                                        .title = PianoJsonStrdup(
                                        s_4,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .artist = PianoJsonStrdup(
                                        s_4,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .seedId = PianoJsonStrdup(
                                        s_4,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .songSeeds = PianoListAppend(
                                        if ((*info).songSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).songSeeds).head
                                        },
                                        &mut (*seedSong).head,
                                    ) as *mut PianoSong_t;
                                    i_6 += 1;
                                    i_6;
                                }
                            }
                            let mut artists_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists_0,
                            ) != 0
                            {
                                let mut i_7: libc::c_int = 0 as libc::c_int;
                                while (i_7 as libc::c_ulong)
                                    < json_object_array_length(artists_0)
                                {
                                    let mut a_0: *mut json_object = json_object_array_get_idx(
                                        artists_0,
                                        i_7 as size_t,
                                    );
                                    let mut seedArtist: *mut PianoArtist_t = 0
                                        as *mut PianoArtist_t;
                                    seedArtist = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    ) as *mut PianoArtist_t;
                                    if seedArtist.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedArtist)
                                        .name = PianoJsonStrdup(
                                        a_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedArtist)
                                        .seedId = PianoJsonStrdup(
                                        a_0,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .artistSeeds = PianoListAppend(
                                        if ((*info).artistSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).artistSeeds).head
                                        },
                                        &mut (*seedArtist).head,
                                    ) as *mut PianoArtist_t;
                                    i_7 += 1;
                                    i_7;
                                }
                            }
                        }
                        let mut feedback: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"feedback\0" as *const u8 as *const libc::c_char,
                            &mut feedback,
                        ) != 0
                        {
                            static mut keys: [*const libc::c_char; 2] = [
                                b"thumbsUp\0" as *const u8 as *const libc::c_char,
                                b"thumbsDown\0" as *const u8 as *const libc::c_char,
                            ];
                            let mut i_8: size_t = 0 as libc::c_int as size_t;
                            while i_8
                                < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                    as libc::c_ulong)
                                    .wrapping_div(
                                        ::std::mem::size_of::<*const libc::c_char>()
                                            as libc::c_ulong,
                                    )
                            {
                                let mut val: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    feedback,
                                    keys[i_8 as usize],
                                    &mut val,
                                ) == 0)
                                {
                                    let mut i_9: libc::c_int = 0 as libc::c_int;
                                    while (i_9 as libc::c_ulong) < json_object_array_length(val)
                                    {
                                        let mut s_5: *mut json_object = json_object_array_get_idx(
                                            val,
                                            i_9 as size_t,
                                        );
                                        let mut feedbackSong: *mut PianoSong_t = 0
                                            as *mut PianoSong_t;
                                        feedbackSong = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        ) as *mut PianoSong_t;
                                        if feedbackSong.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*feedbackSong)
                                            .title = PianoJsonStrdup(
                                            s_5,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .artist = PianoJsonStrdup(
                                            s_5,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .feedbackId = PianoJsonStrdup(
                                            s_5,
                                            b"feedbackId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .rating = (if getBoolDefault(
                                            s_5,
                                            b"isPositive\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        ) as libc::c_int != 0
                                        {
                                            PIANO_RATE_LOVE as libc::c_int
                                        } else {
                                            PIANO_RATE_BAN as libc::c_int
                                        }) as PianoSongRating_t;
                                        let mut v_0: *mut json_object = 0 as *mut json_object;
                                        (*feedbackSong)
                                            .length = (if json_object_object_get_ex(
                                            s_5,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v_0,
                                        ) != 0
                                        {
                                            json_object_get_int(v_0)
                                        } else {
                                            0 as libc::c_int
                                        }) as libc::c_uint;
                                        (*info)
                                            .feedback = PianoListAppend(
                                            if ((*info).feedback).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*info).feedback).head
                                            },
                                            &mut (*feedbackSong).head,
                                        ) as *mut PianoSong_t;
                                        i_9 += 1;
                                        i_9;
                                    }
                                }
                                i_8 = i_8.wrapping_add(1);
                                i_8;
                            }
                        }
                    }
                    11202235766349324107 => {
                        let settings: *mut PianoSettings_t = (*req).data
                            as *mut PianoSettings_t;
                        (*settings)
                            .explicitContentFilter = getBoolDefault(
                            result,
                            b"isExplicitContentFilterEnabled\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int != 0,
                        );
                        (*settings)
                            .username = PianoJsonStrdup(
                            result,
                            b"username\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    145651165234646754 => {
                        let mut reqData_5: *mut PianoRequestDataExplain_t = (*req).data
                            as *mut PianoRequestDataExplain_t;
                        let strSize: size_t = 768 as libc::c_int as size_t;
                        let mut explanations: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"explanations\0" as *const u8 as *const libc::c_char,
                            &mut explanations,
                        ) != 0
                        {
                            (*reqData_5)
                                .retExplain = malloc(
                                strSize
                                    .wrapping_mul(
                                        ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                    ),
                            ) as *mut libc::c_char;
                            strncpy(
                                (*reqData_5).retExplain,
                                b"We're playing this track because it features \0"
                                    as *const u8 as *const libc::c_char,
                                strSize,
                            );
                            let mut i_5: libc::c_int = 0 as libc::c_int;
                            while (i_5 as libc::c_ulong)
                                < json_object_array_length(explanations)
                            {
                                let mut e: *mut json_object = json_object_array_get_idx(
                                    explanations,
                                    i_5 as size_t,
                                );
                                let mut f: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    e,
                                    b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                    &mut f,
                                ) == 0)
                                {
                                    let mut s_3: *const libc::c_char = json_object_get_string(
                                        f,
                                    );
                                    PianoStrpcat((*reqData_5).retExplain, s_3, strSize);
                                    if (i_5 as libc::c_ulong)
                                        < (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b", \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else if i_5 as libc::c_ulong
                                        == (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b" and \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b".\0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    }
                                }
                                i_5 += 1;
                                i_5;
                            }
                        }
                    }
                    9240481512215375588 => {
                        let mut station_0: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*station_0).isCreator = 1 as libc::c_int as libc::c_char;
                    }
                    5908482871227205451 => {
                        let mut categories: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"categories\0" as *const u8 as *const libc::c_char,
                            &mut categories,
                        ) != 0
                        {
                            let mut i_4: libc::c_int = 0 as libc::c_int;
                            while (i_4 as libc::c_ulong)
                                < json_object_array_length(categories)
                            {
                                let mut c: *mut json_object = json_object_array_get_idx(
                                    categories,
                                    i_4 as size_t,
                                );
                                let mut tmpGenreCategory: *mut PianoGenreCategory_t = 0
                                    as *mut PianoGenreCategory_t;
                                tmpGenreCategory = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoGenreCategory_t>()
                                        as libc::c_ulong,
                                ) as *mut PianoGenreCategory_t;
                                if tmpGenreCategory.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*tmpGenreCategory)
                                    .name = PianoJsonStrdup(
                                    c,
                                    b"categoryName\0" as *const u8 as *const libc::c_char,
                                );
                                let mut stations_0: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    c,
                                    b"stations\0" as *const u8 as *const libc::c_char,
                                    &mut stations_0,
                                ) != 0
                                {
                                    let mut k_0: libc::c_int = 0 as libc::c_int;
                                    while (k_0 as libc::c_ulong)
                                        < json_object_array_length(stations_0)
                                    {
                                        let mut s_2: *mut json_object = json_object_array_get_idx(
                                            stations_0,
                                            k_0 as size_t,
                                        );
                                        let mut tmpGenre: *mut PianoGenre_t = 0
                                            as *mut PianoGenre_t;
                                        tmpGenre = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                        ) as *mut PianoGenre_t;
                                        if tmpGenre.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*tmpGenre)
                                            .name = PianoJsonStrdup(
                                            s_2,
                                            b"stationName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenre)
                                            .musicId = PianoJsonStrdup(
                                            s_2,
                                            b"stationToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenreCategory)
                                            .genres = PianoListAppend(
                                            if ((*tmpGenreCategory).genres).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*tmpGenreCategory).genres).head
                                            },
                                            &mut (*tmpGenre).head,
                                        ) as *mut PianoGenre_t;
                                        k_0 += 1;
                                        k_0;
                                    }
                                }
                                (*ph)
                                    .genreStations = PianoListAppend(
                                    if ((*ph).genreStations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).genreStations).head
                                    },
                                    &mut (*tmpGenreCategory).head,
                                ) as *mut PianoGenreCategory_t;
                                i_4 += 1;
                                i_4;
                            }
                        }
                    }
                    5260680050201874961 => {
                        let song_1: *mut PianoSong_t = (*req).data as *mut PianoSong_t;
                        (*song_1).rating = PIANO_RATE_TIRED;
                    }
                    11235674318412060590 => {
                        let mut tmpStation_0: *mut PianoStation_t = 0
                            as *mut PianoStation_t;
                        tmpStation_0 = calloc(
                            1 as libc::c_int as libc::c_ulong,
                            ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                        ) as *mut PianoStation_t;
                        if tmpStation_0.is_null() {
                            return PIANO_RET_OUT_OF_MEMORY;
                        }
                        PianoJsonParseStation(result, tmpStation_0);
                        let mut search: *mut PianoStation_t = PianoFindStationById(
                            (*ph).stations,
                            (*tmpStation_0).id,
                        );
                        if !search.is_null() {
                            (*ph)
                                .stations = PianoListDelete(
                                if ((*ph).stations).is_null() {
                                    0 as *mut PianoListHead_t
                                } else {
                                    &mut (*(*ph).stations).head
                                },
                                &mut (*search).head,
                            ) as *mut PianoStation_t;
                            PianoDestroyStation(search);
                            free(search as *mut libc::c_void);
                        }
                        (*ph)
                            .stations = PianoListAppend(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*tmpStation_0).head,
                        ) as *mut PianoStation_t;
                    }
                    10109057886293123569 => {
                        let mut reqData_4: *mut PianoRequestDataSearch_t = (*req).data
                            as *mut PianoRequestDataSearch_t;
                        let mut searchResult: *mut PianoSearchResult_t = 0
                            as *mut PianoSearchResult_t;
                        searchResult = &mut (*reqData_4).searchResult;
                        memset(
                            searchResult as *mut libc::c_void,
                            0 as libc::c_int,
                            ::std::mem::size_of::<PianoSearchResult_t>() as libc::c_ulong,
                        );
                        let mut artists: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"artists\0" as *const u8 as *const libc::c_char,
                            &mut artists,
                        ) != 0
                        {
                            let mut i_2: libc::c_int = 0 as libc::c_int;
                            while (i_2 as libc::c_ulong)
                                < json_object_array_length(artists)
                            {
                                let mut a: *mut json_object = json_object_array_get_idx(
                                    artists,
                                    i_2 as size_t,
                                );
                                let mut artist: *mut PianoArtist_t = 0
                                    as *mut PianoArtist_t;
                                artist = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                ) as *mut PianoArtist_t;
                                if artist.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*artist)
                                    .name = PianoJsonStrdup(
                                    a,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*artist)
                                    .musicId = PianoJsonStrdup(
                                    a,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .artists = PianoListAppend(
                                    if ((*searchResult).artists).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).artists).head
                                    },
                                    &mut (*artist).head,
                                ) as *mut PianoArtist_t;
                                i_2 += 1;
                                i_2;
                            }
                        }
                        let mut songs: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"songs\0" as *const u8 as *const libc::c_char,
                            &mut songs,
                        ) != 0
                        {
                            let mut i_3: libc::c_int = 0 as libc::c_int;
                            while (i_3 as libc::c_ulong)
                                < json_object_array_length(songs)
                            {
                                let mut s_1: *mut json_object = json_object_array_get_idx(
                                    songs,
                                    i_3 as size_t,
                                );
                                let mut song_0: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song_0 = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song_0.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*song_0)
                                    .title = PianoJsonStrdup(
                                    s_1,
                                    b"songName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .artist = PianoJsonStrdup(
                                    s_1,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .musicId = PianoJsonStrdup(
                                    s_1,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .songs = PianoListAppend(
                                    if ((*searchResult).songs).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).songs).head
                                    },
                                    &mut (*song_0).head,
                                ) as *mut PianoSong_t;
                                i_3 += 1;
                                i_3;
                            }
                        }
                    }
                    4983594971376015098 => {
                        let mut station: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*ph)
                            .stations = PianoListDelete(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*station).head,
                        ) as *mut PianoStation_t;
                        PianoDestroyStation(station);
                        free(station as *mut libc::c_void);
                    }
                    17372050596571538954 => {
                        let mut reqData_3: *mut PianoRequestDataRenameStation_t = (*req)
                            .data as *mut PianoRequestDataRenameStation_t;
                        free((*(*reqData_3).station).name as *mut libc::c_void);
                        (*(*reqData_3).station).name = strdup((*reqData_3).newName);
                    }
                    7297078374430259003 => {
                        let mut reqData_2: *mut PianoRequestDataRateSong_t = (*req).data
                            as *mut PianoRequestDataRateSong_t;
                        (*(*reqData_2).song).rating = (*reqData_2).rating;
                    }
                    17075014677070940716 => {
                        let mut reqData_1: *mut PianoRequestDataGetPlaylist_t = (*req)
                            .data as *mut PianoRequestDataGetPlaylist_t;
                        let mut playlist: *mut PianoSong_t = 0 as *mut PianoSong_t;
                        let mut items: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"items\0" as *const u8 as *const libc::c_char,
                            &mut items,
                        ) == 0)
                        {
                            let mut i_1: libc::c_int = 0 as libc::c_int;
                            loop {
                                if !((i_1 as libc::c_ulong)
                                    < json_object_array_length(items))
                                {
                                    current_block = 4488496028633655612;
                                    break;
                                }
                                let mut s_0: *mut json_object = json_object_array_get_idx(
                                    items,
                                    i_1 as size_t,
                                );
                                let mut song: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                if json_object_object_get_ex(
                                    s_0,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                    0 as *mut *mut json_object,
                                ) == 0
                                {
                                    free(song as *mut libc::c_void);
                                } else {
                                    static mut qualityMap: [*const libc::c_char; 4] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"lowQuality\0" as *const u8 as *const libc::c_char,
                                        b"mediumQuality\0" as *const u8 as *const libc::c_char,
                                        b"highQuality\0" as *const u8 as *const libc::c_char,
                                    ];
                                    static mut formatMap: [*const libc::c_char; 3] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"aacplus\0" as *const u8 as *const libc::c_char,
                                        b"mp3\0" as *const u8 as *const libc::c_char,
                                    ];
                                    let mut umap: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        s_0,
                                        b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                        &mut umap,
                                    ) != 0
                                    {
                                        let mut jsonEncoding: *mut json_object = 0
                                            as *mut json_object;
                                        let mut qmap: *mut json_object = 0 as *mut json_object;
                                        if json_object_object_get_ex(
                                            umap,
                                            qualityMap[(*reqData_1).quality as usize],
                                            &mut qmap,
                                        ) != 0
                                            && json_object_object_get_ex(
                                                qmap,
                                                b"encoding\0" as *const u8 as *const libc::c_char,
                                                &mut jsonEncoding,
                                            ) != 0
                                        {
                                            let mut encoding: *const libc::c_char = json_object_get_string(
                                                jsonEncoding,
                                            );
                                            let mut k: size_t = 0 as libc::c_int as size_t;
                                            while k
                                                < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                    as libc::c_ulong)
                                                    .wrapping_div(
                                                        ::std::mem::size_of::<*const libc::c_char>()
                                                            as libc::c_ulong,
                                                    )
                                            {
                                                if strcmp(formatMap[k as usize], encoding)
                                                    == 0 as libc::c_int
                                                {
                                                    (*song).audioFormat = k as PianoAudioFormat_t;
                                                    break;
                                                } else {
                                                    k = k.wrapping_add(1);
                                                    k;
                                                }
                                            }
                                            (*song)
                                                .audioUrl = PianoJsonStrdup(
                                                qmap,
                                                b"audioUrl\0" as *const u8 as *const libc::c_char,
                                            );
                                        } else {
                                            ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                            free(song as *mut libc::c_void);
                                            PianoDestroyPlaylist(playlist);
                                            current_block = 9169893888141833765;
                                            break;
                                        }
                                    }
                                    let mut v: *mut json_object = 0 as *mut json_object;
                                    (*song)
                                        .artist = PianoJsonStrdup(
                                        s_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .album = PianoJsonStrdup(
                                        s_0,
                                        b"albumName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .title = PianoJsonStrdup(
                                        s_0,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .trackToken = PianoJsonStrdup(
                                        s_0,
                                        b"trackToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .stationId = PianoJsonStrdup(
                                        s_0,
                                        b"stationId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .coverArt = PianoJsonStrdup(
                                        s_0,
                                        b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .detailUrl = PianoJsonStrdup(
                                        s_0,
                                        b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .fileGain = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackGain\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_double(v)
                                    } else {
                                        0.0f64
                                    }) as libc::c_float;
                                    (*song)
                                        .length = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackLength\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    }) as libc::c_uint;
                                    match if json_object_object_get_ex(
                                        s_0,
                                        b"songRating\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    } {
                                        1 => {
                                            (*song).rating = PIANO_RATE_LOVE;
                                        }
                                        _ => {}
                                    }
                                    playlist = PianoListAppend(
                                        if playlist.is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*playlist).head
                                        },
                                        &mut (*song).head,
                                    ) as *mut PianoSong_t;
                                }
                                i_1 += 1;
                                i_1;
                            }
                            match current_block {
                                9169893888141833765 => {}
                                _ => {
                                    (*reqData_1).retPlaylist = playlist;
                                }
                            }
                        }
                    }
                    6450597802325118133 => {
                        let mut stations: *mut json_object = 0 as *mut json_object;
                        let mut mix: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"stations\0" as *const u8 as *const libc::c_char,
                            &mut stations,
                        ) == 0)
                        {
                            let mut i: libc::c_int = 0 as libc::c_int;
                            while (i as libc::c_ulong)
                                < json_object_array_length(stations)
                            {
                                let mut tmpStation: *mut PianoStation_t = 0
                                    as *mut PianoStation_t;
                                let mut s: *mut json_object = json_object_array_get_idx(
                                    stations,
                                    i as size_t,
                                );
                                tmpStation = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                ) as *mut PianoStation_t;
                                if tmpStation.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                PianoJsonParseStation(s, tmpStation);
                                if (*tmpStation).isQuickMix != 0 {
                                    json_object_object_get_ex(
                                        s,
                                        b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                        &mut mix,
                                    );
                                }
                                (*ph)
                                    .stations = PianoListAppend(
                                    if ((*ph).stations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).stations).head
                                    },
                                    &mut (*tmpStation).head,
                                ) as *mut PianoStation_t;
                                i += 1;
                                i;
                            }
                            if !mix.is_null() {
                                let mut curStation: *mut PianoStation_t = (*ph).stations;
                                while !curStation.is_null() {
                                    let mut i_0: libc::c_int = 0 as libc::c_int;
                                    while (i_0 as libc::c_ulong) < json_object_array_length(mix)
                                    {
                                        let mut id: *mut json_object = json_object_array_get_idx(
                                            mix,
                                            i_0 as size_t,
                                        );
                                        if strcmp(json_object_get_string(id), (*curStation).id)
                                            == 0 as libc::c_int
                                        {
                                            (*curStation)
                                                .useQuickMix = 1 as libc::c_int as libc::c_char;
                                        }
                                        i_0 += 1;
                                        i_0;
                                    }
                                    curStation = (*curStation).head.next as *mut libc::c_void
                                        as *mut PianoStation_t;
                                }
                            }
                        }
                    }
                    12039483399334584727 => {
                        let mut reqData_0: *mut PianoRequestDataLogin_t = (*req).data
                            as *mut PianoRequestDataLogin_t;
                        match (*reqData_0).step as libc::c_int {
                            0 => {
                                let mut jsonTimestamp: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    result,
                                    b"syncTime\0" as *const u8 as *const libc::c_char,
                                    &mut jsonTimestamp,
                                ) == 0
                                {
                                    ret = PIANO_RET_INVALID_RESPONSE;
                                } else {
                                    let cryptedTimestamp: *const libc::c_char = json_object_get_string(
                                        jsonTimestamp,
                                    );
                                    let realTimestamp: time_t = time(0 as *mut time_t);
                                    let mut decryptedTimestamp: *mut libc::c_char = 0
                                        as *mut libc::c_char;
                                    let mut decryptedSize: size_t = 0;
                                    ret = PIANO_RET_ERR;
                                    decryptedTimestamp = PianoDecryptString(
                                        (*ph).partner.in_0,
                                        cryptedTimestamp,
                                        &mut decryptedSize,
                                    );
                                    if !decryptedTimestamp.is_null()
                                        && decryptedSize > 4 as libc::c_int as libc::c_ulong
                                    {
                                        let timestamp: libc::c_ulong = strtoul(
                                            decryptedTimestamp.offset(4 as libc::c_int as isize),
                                            0 as *mut *mut libc::c_char,
                                            0 as libc::c_int,
                                        );
                                        (*ph)
                                            .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                            as libc::c_int;
                                        ret = PIANO_RET_CONTINUE_REQUEST;
                                    }
                                    free(decryptedTimestamp as *mut libc::c_void);
                                    (*ph)
                                        .partner
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    let mut partnerId: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        result,
                                        b"partnerId\0" as *const u8 as *const libc::c_char,
                                        &mut partnerId,
                                    ) == 0
                                    {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        (*ph)
                                            .partner
                                            .id = json_object_get_int(partnerId) as libc::c_uint;
                                        (*reqData_0).step = ((*reqData_0).step).wrapping_add(1);
                                        (*reqData_0).step;
                                    }
                                }
                            }
                            1 => {
                                if !((*ph).user.listenerId).is_null() {
                                    PianoDestroyUserInfo(&mut (*ph).user);
                                }
                                (*ph)
                                    .user
                                    .listenerId = PianoJsonStrdup(
                                    result,
                                    b"userId\0" as *const u8 as *const libc::c_char,
                                );
                                (*ph)
                                    .user
                                    .authToken = PianoJsonStrdup(
                                    result,
                                    b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                );
                            }
                            _ => {}
                        }
                    }
                    10223170376184624358 => {
                        let mut reqData_8: *mut PianoRequestDataSetStationMode_t = (*req)
                            .data as *mut PianoRequestDataSetStationMode_t;
                        let mut active_0: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode_0: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode_0,
                        ) != 0
                        {
                            active_0 = json_object_get_int(activeMode_0);
                        }
                        if active_0 as libc::c_uint != (*reqData_8).id {
                            return PIANO_RET_ERR;
                        }
                    }
                    _ => {
                        let mut reqData_7: *mut PianoRequestDataGetStationModes_t = (*req)
                            .data as *mut PianoRequestDataGetStationModes_t;
                        let mut active: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode,
                        ) != 0
                        {
                            active = json_object_get_int(activeMode);
                        }
                        let mut availableModes: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"availableModes\0" as *const u8 as *const libc::c_char,
                            &mut availableModes,
                        ) != 0
                        {
                            let mut i_10: libc::c_int = 0 as libc::c_int;
                            while (i_10 as libc::c_ulong)
                                < json_object_array_length(availableModes)
                            {
                                let mut val_0: *mut json_object = json_object_array_get_idx(
                                    availableModes,
                                    i_10 as size_t,
                                );
                                let mut mode: *mut PianoStationMode_t = 0
                                    as *mut PianoStationMode_t;
                                mode = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                ) as *mut PianoStationMode_t;
                                if mode.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                let mut modeId: *mut json_object = 0 as *mut json_object;
                                if json_object_object_get_ex(
                                    val_0,
                                    b"modeId\0" as *const u8 as *const libc::c_char,
                                    &mut modeId,
                                ) != 0
                                {
                                    (*mode).id = json_object_get_int(modeId);
                                    (*mode)
                                        .name = PianoJsonStrdup(
                                        val_0,
                                        b"modeName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .description = PianoJsonStrdup(
                                        val_0,
                                        b"modeDescription\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .isAlgorithmic = getBoolDefault(
                                        val_0,
                                        b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode)
                                        .isTakeover = getBoolDefault(
                                        val_0,
                                        b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode).active = active == (*mode).id;
                                }
                                (*reqData_7)
                                    .retModes = PianoListAppend(
                                    if ((*reqData_7).retModes).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*reqData_7).retModes).head
                                    },
                                    &mut (*mode).head,
                                ) as *mut PianoStationMode_t;
                                i_10 += 1;
                                i_10;
                            }
                        }
                    }
                }
            }
            26 => {
                current_block = 10223170376184624358;
                match current_block {
                    14870924983410776565 => {}
                    4367030874028593650 => {
                        let mut reqData_6: *mut PianoRequestDataGetStationInfo_t = (*req)
                            .data as *mut PianoRequestDataGetStationInfo_t;
                        let mut info: *mut PianoStationInfo_t = 0
                            as *mut PianoStationInfo_t;
                        info = &mut (*reqData_6).info;
                        let mut music: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"music\0" as *const u8 as *const libc::c_char,
                            &mut music,
                        ) != 0
                        {
                            let mut songs_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"songs\0" as *const u8 as *const libc::c_char,
                                &mut songs_0,
                            ) != 0
                            {
                                let mut i_6: libc::c_int = 0 as libc::c_int;
                                while (i_6 as libc::c_ulong)
                                    < json_object_array_length(songs_0)
                                {
                                    let mut s_4: *mut json_object = json_object_array_get_idx(
                                        songs_0,
                                        i_6 as size_t,
                                    );
                                    let mut seedSong: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                    seedSong = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                    ) as *mut PianoSong_t;
                                    if seedSong.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedSong)
                                        .title = PianoJsonStrdup(
                                        s_4,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .artist = PianoJsonStrdup(
                                        s_4,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedSong)
                                        .seedId = PianoJsonStrdup(
                                        s_4,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .songSeeds = PianoListAppend(
                                        if ((*info).songSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).songSeeds).head
                                        },
                                        &mut (*seedSong).head,
                                    ) as *mut PianoSong_t;
                                    i_6 += 1;
                                    i_6;
                                }
                            }
                            let mut artists_0: *mut json_object = 0 as *mut json_object;
                            if json_object_object_get_ex(
                                music,
                                b"artists\0" as *const u8 as *const libc::c_char,
                                &mut artists_0,
                            ) != 0
                            {
                                let mut i_7: libc::c_int = 0 as libc::c_int;
                                while (i_7 as libc::c_ulong)
                                    < json_object_array_length(artists_0)
                                {
                                    let mut a_0: *mut json_object = json_object_array_get_idx(
                                        artists_0,
                                        i_7 as size_t,
                                    );
                                    let mut seedArtist: *mut PianoArtist_t = 0
                                        as *mut PianoArtist_t;
                                    seedArtist = calloc(
                                        1 as libc::c_int as libc::c_ulong,
                                        ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                    ) as *mut PianoArtist_t;
                                    if seedArtist.is_null() {
                                        return PIANO_RET_OUT_OF_MEMORY;
                                    }
                                    (*seedArtist)
                                        .name = PianoJsonStrdup(
                                        a_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*seedArtist)
                                        .seedId = PianoJsonStrdup(
                                        a_0,
                                        b"seedId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*info)
                                        .artistSeeds = PianoListAppend(
                                        if ((*info).artistSeeds).is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*(*info).artistSeeds).head
                                        },
                                        &mut (*seedArtist).head,
                                    ) as *mut PianoArtist_t;
                                    i_7 += 1;
                                    i_7;
                                }
                            }
                        }
                        let mut feedback: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"feedback\0" as *const u8 as *const libc::c_char,
                            &mut feedback,
                        ) != 0
                        {
                            static mut keys: [*const libc::c_char; 2] = [
                                b"thumbsUp\0" as *const u8 as *const libc::c_char,
                                b"thumbsDown\0" as *const u8 as *const libc::c_char,
                            ];
                            let mut i_8: size_t = 0 as libc::c_int as size_t;
                            while i_8
                                < (::std::mem::size_of::<[*const libc::c_char; 2]>()
                                    as libc::c_ulong)
                                    .wrapping_div(
                                        ::std::mem::size_of::<*const libc::c_char>()
                                            as libc::c_ulong,
                                    )
                            {
                                let mut val: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    feedback,
                                    keys[i_8 as usize],
                                    &mut val,
                                ) == 0)
                                {
                                    let mut i_9: libc::c_int = 0 as libc::c_int;
                                    while (i_9 as libc::c_ulong) < json_object_array_length(val)
                                    {
                                        let mut s_5: *mut json_object = json_object_array_get_idx(
                                            val,
                                            i_9 as size_t,
                                        );
                                        let mut feedbackSong: *mut PianoSong_t = 0
                                            as *mut PianoSong_t;
                                        feedbackSong = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                        ) as *mut PianoSong_t;
                                        if feedbackSong.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*feedbackSong)
                                            .title = PianoJsonStrdup(
                                            s_5,
                                            b"songName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .artist = PianoJsonStrdup(
                                            s_5,
                                            b"artistName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .feedbackId = PianoJsonStrdup(
                                            s_5,
                                            b"feedbackId\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*feedbackSong)
                                            .rating = (if getBoolDefault(
                                            s_5,
                                            b"isPositive\0" as *const u8 as *const libc::c_char,
                                            0 as libc::c_int != 0,
                                        ) as libc::c_int != 0
                                        {
                                            PIANO_RATE_LOVE as libc::c_int
                                        } else {
                                            PIANO_RATE_BAN as libc::c_int
                                        }) as PianoSongRating_t;
                                        let mut v_0: *mut json_object = 0 as *mut json_object;
                                        (*feedbackSong)
                                            .length = (if json_object_object_get_ex(
                                            s_5,
                                            b"trackLength\0" as *const u8 as *const libc::c_char,
                                            &mut v_0,
                                        ) != 0
                                        {
                                            json_object_get_int(v_0)
                                        } else {
                                            0 as libc::c_int
                                        }) as libc::c_uint;
                                        (*info)
                                            .feedback = PianoListAppend(
                                            if ((*info).feedback).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*info).feedback).head
                                            },
                                            &mut (*feedbackSong).head,
                                        ) as *mut PianoSong_t;
                                        i_9 += 1;
                                        i_9;
                                    }
                                }
                                i_8 = i_8.wrapping_add(1);
                                i_8;
                            }
                        }
                    }
                    11202235766349324107 => {
                        let settings: *mut PianoSettings_t = (*req).data
                            as *mut PianoSettings_t;
                        (*settings)
                            .explicitContentFilter = getBoolDefault(
                            result,
                            b"isExplicitContentFilterEnabled\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int != 0,
                        );
                        (*settings)
                            .username = PianoJsonStrdup(
                            result,
                            b"username\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    145651165234646754 => {
                        let mut reqData_5: *mut PianoRequestDataExplain_t = (*req).data
                            as *mut PianoRequestDataExplain_t;
                        let strSize: size_t = 768 as libc::c_int as size_t;
                        let mut explanations: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"explanations\0" as *const u8 as *const libc::c_char,
                            &mut explanations,
                        ) != 0
                        {
                            (*reqData_5)
                                .retExplain = malloc(
                                strSize
                                    .wrapping_mul(
                                        ::std::mem::size_of::<libc::c_char>() as libc::c_ulong,
                                    ),
                            ) as *mut libc::c_char;
                            strncpy(
                                (*reqData_5).retExplain,
                                b"We're playing this track because it features \0"
                                    as *const u8 as *const libc::c_char,
                                strSize,
                            );
                            let mut i_5: libc::c_int = 0 as libc::c_int;
                            while (i_5 as libc::c_ulong)
                                < json_object_array_length(explanations)
                            {
                                let mut e: *mut json_object = json_object_array_get_idx(
                                    explanations,
                                    i_5 as size_t,
                                );
                                let mut f: *mut json_object = 0 as *mut json_object;
                                if !(json_object_object_get_ex(
                                    e,
                                    b"focusTraitName\0" as *const u8 as *const libc::c_char,
                                    &mut f,
                                ) == 0)
                                {
                                    let mut s_3: *const libc::c_char = json_object_get_string(
                                        f,
                                    );
                                    PianoStrpcat((*reqData_5).retExplain, s_3, strSize);
                                    if (i_5 as libc::c_ulong)
                                        < (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b", \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else if i_5 as libc::c_ulong
                                        == (json_object_array_length(explanations))
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                    {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b" and \0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    } else {
                                        PianoStrpcat(
                                            (*reqData_5).retExplain,
                                            b".\0" as *const u8 as *const libc::c_char,
                                            strSize,
                                        );
                                    }
                                }
                                i_5 += 1;
                                i_5;
                            }
                        }
                    }
                    9240481512215375588 => {
                        let mut station_0: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*station_0).isCreator = 1 as libc::c_int as libc::c_char;
                    }
                    5908482871227205451 => {
                        let mut categories: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"categories\0" as *const u8 as *const libc::c_char,
                            &mut categories,
                        ) != 0
                        {
                            let mut i_4: libc::c_int = 0 as libc::c_int;
                            while (i_4 as libc::c_ulong)
                                < json_object_array_length(categories)
                            {
                                let mut c: *mut json_object = json_object_array_get_idx(
                                    categories,
                                    i_4 as size_t,
                                );
                                let mut tmpGenreCategory: *mut PianoGenreCategory_t = 0
                                    as *mut PianoGenreCategory_t;
                                tmpGenreCategory = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoGenreCategory_t>()
                                        as libc::c_ulong,
                                ) as *mut PianoGenreCategory_t;
                                if tmpGenreCategory.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*tmpGenreCategory)
                                    .name = PianoJsonStrdup(
                                    c,
                                    b"categoryName\0" as *const u8 as *const libc::c_char,
                                );
                                let mut stations_0: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    c,
                                    b"stations\0" as *const u8 as *const libc::c_char,
                                    &mut stations_0,
                                ) != 0
                                {
                                    let mut k_0: libc::c_int = 0 as libc::c_int;
                                    while (k_0 as libc::c_ulong)
                                        < json_object_array_length(stations_0)
                                    {
                                        let mut s_2: *mut json_object = json_object_array_get_idx(
                                            stations_0,
                                            k_0 as size_t,
                                        );
                                        let mut tmpGenre: *mut PianoGenre_t = 0
                                            as *mut PianoGenre_t;
                                        tmpGenre = calloc(
                                            1 as libc::c_int as libc::c_ulong,
                                            ::std::mem::size_of::<PianoGenre_t>() as libc::c_ulong,
                                        ) as *mut PianoGenre_t;
                                        if tmpGenre.is_null() {
                                            return PIANO_RET_OUT_OF_MEMORY;
                                        }
                                        (*tmpGenre)
                                            .name = PianoJsonStrdup(
                                            s_2,
                                            b"stationName\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenre)
                                            .musicId = PianoJsonStrdup(
                                            s_2,
                                            b"stationToken\0" as *const u8 as *const libc::c_char,
                                        );
                                        (*tmpGenreCategory)
                                            .genres = PianoListAppend(
                                            if ((*tmpGenreCategory).genres).is_null() {
                                                0 as *mut PianoListHead_t
                                            } else {
                                                &mut (*(*tmpGenreCategory).genres).head
                                            },
                                            &mut (*tmpGenre).head,
                                        ) as *mut PianoGenre_t;
                                        k_0 += 1;
                                        k_0;
                                    }
                                }
                                (*ph)
                                    .genreStations = PianoListAppend(
                                    if ((*ph).genreStations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).genreStations).head
                                    },
                                    &mut (*tmpGenreCategory).head,
                                ) as *mut PianoGenreCategory_t;
                                i_4 += 1;
                                i_4;
                            }
                        }
                    }
                    5260680050201874961 => {
                        let song_1: *mut PianoSong_t = (*req).data as *mut PianoSong_t;
                        (*song_1).rating = PIANO_RATE_TIRED;
                    }
                    11235674318412060590 => {
                        let mut tmpStation_0: *mut PianoStation_t = 0
                            as *mut PianoStation_t;
                        tmpStation_0 = calloc(
                            1 as libc::c_int as libc::c_ulong,
                            ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                        ) as *mut PianoStation_t;
                        if tmpStation_0.is_null() {
                            return PIANO_RET_OUT_OF_MEMORY;
                        }
                        PianoJsonParseStation(result, tmpStation_0);
                        let mut search: *mut PianoStation_t = PianoFindStationById(
                            (*ph).stations,
                            (*tmpStation_0).id,
                        );
                        if !search.is_null() {
                            (*ph)
                                .stations = PianoListDelete(
                                if ((*ph).stations).is_null() {
                                    0 as *mut PianoListHead_t
                                } else {
                                    &mut (*(*ph).stations).head
                                },
                                &mut (*search).head,
                            ) as *mut PianoStation_t;
                            PianoDestroyStation(search);
                            free(search as *mut libc::c_void);
                        }
                        (*ph)
                            .stations = PianoListAppend(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*tmpStation_0).head,
                        ) as *mut PianoStation_t;
                    }
                    10109057886293123569 => {
                        let mut reqData_4: *mut PianoRequestDataSearch_t = (*req).data
                            as *mut PianoRequestDataSearch_t;
                        let mut searchResult: *mut PianoSearchResult_t = 0
                            as *mut PianoSearchResult_t;
                        searchResult = &mut (*reqData_4).searchResult;
                        memset(
                            searchResult as *mut libc::c_void,
                            0 as libc::c_int,
                            ::std::mem::size_of::<PianoSearchResult_t>() as libc::c_ulong,
                        );
                        let mut artists: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"artists\0" as *const u8 as *const libc::c_char,
                            &mut artists,
                        ) != 0
                        {
                            let mut i_2: libc::c_int = 0 as libc::c_int;
                            while (i_2 as libc::c_ulong)
                                < json_object_array_length(artists)
                            {
                                let mut a: *mut json_object = json_object_array_get_idx(
                                    artists,
                                    i_2 as size_t,
                                );
                                let mut artist: *mut PianoArtist_t = 0
                                    as *mut PianoArtist_t;
                                artist = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoArtist_t>() as libc::c_ulong,
                                ) as *mut PianoArtist_t;
                                if artist.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*artist)
                                    .name = PianoJsonStrdup(
                                    a,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*artist)
                                    .musicId = PianoJsonStrdup(
                                    a,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .artists = PianoListAppend(
                                    if ((*searchResult).artists).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).artists).head
                                    },
                                    &mut (*artist).head,
                                ) as *mut PianoArtist_t;
                                i_2 += 1;
                                i_2;
                            }
                        }
                        let mut songs: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"songs\0" as *const u8 as *const libc::c_char,
                            &mut songs,
                        ) != 0
                        {
                            let mut i_3: libc::c_int = 0 as libc::c_int;
                            while (i_3 as libc::c_ulong)
                                < json_object_array_length(songs)
                            {
                                let mut s_1: *mut json_object = json_object_array_get_idx(
                                    songs,
                                    i_3 as size_t,
                                );
                                let mut song_0: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song_0 = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song_0.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                (*song_0)
                                    .title = PianoJsonStrdup(
                                    s_1,
                                    b"songName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .artist = PianoJsonStrdup(
                                    s_1,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                );
                                (*song_0)
                                    .musicId = PianoJsonStrdup(
                                    s_1,
                                    b"musicToken\0" as *const u8 as *const libc::c_char,
                                );
                                (*searchResult)
                                    .songs = PianoListAppend(
                                    if ((*searchResult).songs).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*searchResult).songs).head
                                    },
                                    &mut (*song_0).head,
                                ) as *mut PianoSong_t;
                                i_3 += 1;
                                i_3;
                            }
                        }
                    }
                    4983594971376015098 => {
                        let mut station: *mut PianoStation_t = (*req).data
                            as *mut PianoStation_t;
                        (*ph)
                            .stations = PianoListDelete(
                            if ((*ph).stations).is_null() {
                                0 as *mut PianoListHead_t
                            } else {
                                &mut (*(*ph).stations).head
                            },
                            &mut (*station).head,
                        ) as *mut PianoStation_t;
                        PianoDestroyStation(station);
                        free(station as *mut libc::c_void);
                    }
                    17372050596571538954 => {
                        let mut reqData_3: *mut PianoRequestDataRenameStation_t = (*req)
                            .data as *mut PianoRequestDataRenameStation_t;
                        free((*(*reqData_3).station).name as *mut libc::c_void);
                        (*(*reqData_3).station).name = strdup((*reqData_3).newName);
                    }
                    7297078374430259003 => {
                        let mut reqData_2: *mut PianoRequestDataRateSong_t = (*req).data
                            as *mut PianoRequestDataRateSong_t;
                        (*(*reqData_2).song).rating = (*reqData_2).rating;
                    }
                    17075014677070940716 => {
                        let mut reqData_1: *mut PianoRequestDataGetPlaylist_t = (*req)
                            .data as *mut PianoRequestDataGetPlaylist_t;
                        let mut playlist: *mut PianoSong_t = 0 as *mut PianoSong_t;
                        let mut items: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"items\0" as *const u8 as *const libc::c_char,
                            &mut items,
                        ) == 0)
                        {
                            let mut i_1: libc::c_int = 0 as libc::c_int;
                            loop {
                                if !((i_1 as libc::c_ulong)
                                    < json_object_array_length(items))
                                {
                                    current_block = 4488496028633655612;
                                    break;
                                }
                                let mut s_0: *mut json_object = json_object_array_get_idx(
                                    items,
                                    i_1 as size_t,
                                );
                                let mut song: *mut PianoSong_t = 0 as *mut PianoSong_t;
                                song = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoSong_t>() as libc::c_ulong,
                                ) as *mut PianoSong_t;
                                if song.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                if json_object_object_get_ex(
                                    s_0,
                                    b"artistName\0" as *const u8 as *const libc::c_char,
                                    0 as *mut *mut json_object,
                                ) == 0
                                {
                                    free(song as *mut libc::c_void);
                                } else {
                                    static mut qualityMap: [*const libc::c_char; 4] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"lowQuality\0" as *const u8 as *const libc::c_char,
                                        b"mediumQuality\0" as *const u8 as *const libc::c_char,
                                        b"highQuality\0" as *const u8 as *const libc::c_char,
                                    ];
                                    static mut formatMap: [*const libc::c_char; 3] = [
                                        b"\0" as *const u8 as *const libc::c_char,
                                        b"aacplus\0" as *const u8 as *const libc::c_char,
                                        b"mp3\0" as *const u8 as *const libc::c_char,
                                    ];
                                    let mut umap: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        s_0,
                                        b"audioUrlMap\0" as *const u8 as *const libc::c_char,
                                        &mut umap,
                                    ) != 0
                                    {
                                        let mut jsonEncoding: *mut json_object = 0
                                            as *mut json_object;
                                        let mut qmap: *mut json_object = 0 as *mut json_object;
                                        if json_object_object_get_ex(
                                            umap,
                                            qualityMap[(*reqData_1).quality as usize],
                                            &mut qmap,
                                        ) != 0
                                            && json_object_object_get_ex(
                                                qmap,
                                                b"encoding\0" as *const u8 as *const libc::c_char,
                                                &mut jsonEncoding,
                                            ) != 0
                                        {
                                            let mut encoding: *const libc::c_char = json_object_get_string(
                                                jsonEncoding,
                                            );
                                            let mut k: size_t = 0 as libc::c_int as size_t;
                                            while k
                                                < (::std::mem::size_of::<[*const libc::c_char; 3]>()
                                                    as libc::c_ulong)
                                                    .wrapping_div(
                                                        ::std::mem::size_of::<*const libc::c_char>()
                                                            as libc::c_ulong,
                                                    )
                                            {
                                                if strcmp(formatMap[k as usize], encoding)
                                                    == 0 as libc::c_int
                                                {
                                                    (*song).audioFormat = k as PianoAudioFormat_t;
                                                    break;
                                                } else {
                                                    k = k.wrapping_add(1);
                                                    k;
                                                }
                                            }
                                            (*song)
                                                .audioUrl = PianoJsonStrdup(
                                                qmap,
                                                b"audioUrl\0" as *const u8 as *const libc::c_char,
                                            );
                                        } else {
                                            ret = PIANO_RET_QUALITY_UNAVAILABLE;
                                            free(song as *mut libc::c_void);
                                            PianoDestroyPlaylist(playlist);
                                            current_block = 9169893888141833765;
                                            break;
                                        }
                                    }
                                    let mut v: *mut json_object = 0 as *mut json_object;
                                    (*song)
                                        .artist = PianoJsonStrdup(
                                        s_0,
                                        b"artistName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .album = PianoJsonStrdup(
                                        s_0,
                                        b"albumName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .title = PianoJsonStrdup(
                                        s_0,
                                        b"songName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .trackToken = PianoJsonStrdup(
                                        s_0,
                                        b"trackToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .stationId = PianoJsonStrdup(
                                        s_0,
                                        b"stationId\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .coverArt = PianoJsonStrdup(
                                        s_0,
                                        b"albumArtUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .detailUrl = PianoJsonStrdup(
                                        s_0,
                                        b"songDetailUrl\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*song)
                                        .fileGain = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackGain\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_double(v)
                                    } else {
                                        0.0f64
                                    }) as libc::c_float;
                                    (*song)
                                        .length = (if json_object_object_get_ex(
                                        s_0,
                                        b"trackLength\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    }) as libc::c_uint;
                                    match if json_object_object_get_ex(
                                        s_0,
                                        b"songRating\0" as *const u8 as *const libc::c_char,
                                        &mut v,
                                    ) != 0
                                    {
                                        json_object_get_int(v)
                                    } else {
                                        0 as libc::c_int
                                    } {
                                        1 => {
                                            (*song).rating = PIANO_RATE_LOVE;
                                        }
                                        _ => {}
                                    }
                                    playlist = PianoListAppend(
                                        if playlist.is_null() {
                                            0 as *mut PianoListHead_t
                                        } else {
                                            &mut (*playlist).head
                                        },
                                        &mut (*song).head,
                                    ) as *mut PianoSong_t;
                                }
                                i_1 += 1;
                                i_1;
                            }
                            match current_block {
                                9169893888141833765 => {}
                                _ => {
                                    (*reqData_1).retPlaylist = playlist;
                                }
                            }
                        }
                    }
                    6450597802325118133 => {
                        let mut stations: *mut json_object = 0 as *mut json_object;
                        let mut mix: *mut json_object = 0 as *mut json_object;
                        if !(json_object_object_get_ex(
                            result,
                            b"stations\0" as *const u8 as *const libc::c_char,
                            &mut stations,
                        ) == 0)
                        {
                            let mut i: libc::c_int = 0 as libc::c_int;
                            while (i as libc::c_ulong)
                                < json_object_array_length(stations)
                            {
                                let mut tmpStation: *mut PianoStation_t = 0
                                    as *mut PianoStation_t;
                                let mut s: *mut json_object = json_object_array_get_idx(
                                    stations,
                                    i as size_t,
                                );
                                tmpStation = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStation_t>() as libc::c_ulong,
                                ) as *mut PianoStation_t;
                                if tmpStation.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                PianoJsonParseStation(s, tmpStation);
                                if (*tmpStation).isQuickMix != 0 {
                                    json_object_object_get_ex(
                                        s,
                                        b"quickMixStationIds\0" as *const u8 as *const libc::c_char,
                                        &mut mix,
                                    );
                                }
                                (*ph)
                                    .stations = PianoListAppend(
                                    if ((*ph).stations).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*ph).stations).head
                                    },
                                    &mut (*tmpStation).head,
                                ) as *mut PianoStation_t;
                                i += 1;
                                i;
                            }
                            if !mix.is_null() {
                                let mut curStation: *mut PianoStation_t = (*ph).stations;
                                while !curStation.is_null() {
                                    let mut i_0: libc::c_int = 0 as libc::c_int;
                                    while (i_0 as libc::c_ulong) < json_object_array_length(mix)
                                    {
                                        let mut id: *mut json_object = json_object_array_get_idx(
                                            mix,
                                            i_0 as size_t,
                                        );
                                        if strcmp(json_object_get_string(id), (*curStation).id)
                                            == 0 as libc::c_int
                                        {
                                            (*curStation)
                                                .useQuickMix = 1 as libc::c_int as libc::c_char;
                                        }
                                        i_0 += 1;
                                        i_0;
                                    }
                                    curStation = (*curStation).head.next as *mut libc::c_void
                                        as *mut PianoStation_t;
                                }
                            }
                        }
                    }
                    12039483399334584727 => {
                        let mut reqData_0: *mut PianoRequestDataLogin_t = (*req).data
                            as *mut PianoRequestDataLogin_t;
                        match (*reqData_0).step as libc::c_int {
                            0 => {
                                let mut jsonTimestamp: *mut json_object = 0
                                    as *mut json_object;
                                if json_object_object_get_ex(
                                    result,
                                    b"syncTime\0" as *const u8 as *const libc::c_char,
                                    &mut jsonTimestamp,
                                ) == 0
                                {
                                    ret = PIANO_RET_INVALID_RESPONSE;
                                } else {
                                    let cryptedTimestamp: *const libc::c_char = json_object_get_string(
                                        jsonTimestamp,
                                    );
                                    let realTimestamp: time_t = time(0 as *mut time_t);
                                    let mut decryptedTimestamp: *mut libc::c_char = 0
                                        as *mut libc::c_char;
                                    let mut decryptedSize: size_t = 0;
                                    ret = PIANO_RET_ERR;
                                    decryptedTimestamp = PianoDecryptString(
                                        (*ph).partner.in_0,
                                        cryptedTimestamp,
                                        &mut decryptedSize,
                                    );
                                    if !decryptedTimestamp.is_null()
                                        && decryptedSize > 4 as libc::c_int as libc::c_ulong
                                    {
                                        let timestamp: libc::c_ulong = strtoul(
                                            decryptedTimestamp.offset(4 as libc::c_int as isize),
                                            0 as *mut *mut libc::c_char,
                                            0 as libc::c_int,
                                        );
                                        (*ph)
                                            .timeOffset = (realTimestamp - timestamp as libc::c_long)
                                            as libc::c_int;
                                        ret = PIANO_RET_CONTINUE_REQUEST;
                                    }
                                    free(decryptedTimestamp as *mut libc::c_void);
                                    (*ph)
                                        .partner
                                        .authToken = PianoJsonStrdup(
                                        result,
                                        b"partnerAuthToken\0" as *const u8 as *const libc::c_char,
                                    );
                                    let mut partnerId: *mut json_object = 0 as *mut json_object;
                                    if json_object_object_get_ex(
                                        result,
                                        b"partnerId\0" as *const u8 as *const libc::c_char,
                                        &mut partnerId,
                                    ) == 0
                                    {
                                        ret = PIANO_RET_INVALID_RESPONSE;
                                    } else {
                                        (*ph)
                                            .partner
                                            .id = json_object_get_int(partnerId) as libc::c_uint;
                                        (*reqData_0).step = ((*reqData_0).step).wrapping_add(1);
                                        (*reqData_0).step;
                                    }
                                }
                            }
                            1 => {
                                if !((*ph).user.listenerId).is_null() {
                                    PianoDestroyUserInfo(&mut (*ph).user);
                                }
                                (*ph)
                                    .user
                                    .listenerId = PianoJsonStrdup(
                                    result,
                                    b"userId\0" as *const u8 as *const libc::c_char,
                                );
                                (*ph)
                                    .user
                                    .authToken = PianoJsonStrdup(
                                    result,
                                    b"userAuthToken\0" as *const u8 as *const libc::c_char,
                                );
                            }
                            _ => {}
                        }
                    }
                    10223170376184624358 => {
                        let mut reqData_8: *mut PianoRequestDataSetStationMode_t = (*req)
                            .data as *mut PianoRequestDataSetStationMode_t;
                        let mut active_0: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode_0: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode_0,
                        ) != 0
                        {
                            active_0 = json_object_get_int(activeMode_0);
                        }
                        if active_0 as libc::c_uint != (*reqData_8).id {
                            return PIANO_RET_ERR;
                        }
                    }
                    _ => {
                        let mut reqData_7: *mut PianoRequestDataGetStationModes_t = (*req)
                            .data as *mut PianoRequestDataGetStationModes_t;
                        let mut active: libc::c_int = -(1 as libc::c_int);
                        let mut activeMode: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"currentModeId\0" as *const u8 as *const libc::c_char,
                            &mut activeMode,
                        ) != 0
                        {
                            active = json_object_get_int(activeMode);
                        }
                        let mut availableModes: *mut json_object = 0 as *mut json_object;
                        if json_object_object_get_ex(
                            result,
                            b"availableModes\0" as *const u8 as *const libc::c_char,
                            &mut availableModes,
                        ) != 0
                        {
                            let mut i_10: libc::c_int = 0 as libc::c_int;
                            while (i_10 as libc::c_ulong)
                                < json_object_array_length(availableModes)
                            {
                                let mut val_0: *mut json_object = json_object_array_get_idx(
                                    availableModes,
                                    i_10 as size_t,
                                );
                                let mut mode: *mut PianoStationMode_t = 0
                                    as *mut PianoStationMode_t;
                                mode = calloc(
                                    1 as libc::c_int as libc::c_ulong,
                                    ::std::mem::size_of::<PianoStationMode_t>() as libc::c_ulong,
                                ) as *mut PianoStationMode_t;
                                if mode.is_null() {
                                    return PIANO_RET_OUT_OF_MEMORY;
                                }
                                let mut modeId: *mut json_object = 0 as *mut json_object;
                                if json_object_object_get_ex(
                                    val_0,
                                    b"modeId\0" as *const u8 as *const libc::c_char,
                                    &mut modeId,
                                ) != 0
                                {
                                    (*mode).id = json_object_get_int(modeId);
                                    (*mode)
                                        .name = PianoJsonStrdup(
                                        val_0,
                                        b"modeName\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .description = PianoJsonStrdup(
                                        val_0,
                                        b"modeDescription\0" as *const u8 as *const libc::c_char,
                                    );
                                    (*mode)
                                        .isAlgorithmic = getBoolDefault(
                                        val_0,
                                        b"isAlgorithmicMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode)
                                        .isTakeover = getBoolDefault(
                                        val_0,
                                        b"isTakeoverMode\0" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int != 0,
                                    );
                                    (*mode).active = active == (*mode).id;
                                }
                                (*reqData_7)
                                    .retModes = PianoListAppend(
                                    if ((*reqData_7).retModes).is_null() {
                                        0 as *mut PianoListHead_t
                                    } else {
                                        &mut (*(*reqData_7).retModes).head
                                    },
                                    &mut (*mode).head,
                                ) as *mut PianoStationMode_t;
                                i_10 += 1;
                                i_10;
                            }
                        }
                    }
                }
            }
            11 | 13 | 18 | 19 | 21 | 22 | 24 | _ => {}
        }
    }
    json_object_put(j);
    return ret;
}
